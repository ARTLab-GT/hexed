/*! \page hil Hexed Interface Language

Hexed is designed to be used in two ways.
You can use the C++ library \ref hexed to integrate it directly into your own code.
However, for the likely case that you don't want to program in C++, Hexed also supports a command line interface.
To distinguish it from the library, the command to _execute Hexed_ is `hexecute` (apologies for my terrible sense of humor).
Without any arguments, `hexecute` will begin an interactive session where you can enter commands in a language called the Hexed Interface Language (HIL).
Alternatively, you can provide a single argument which is the name of a file containing HIL commands.
It will then execute these commands as though you had entered them in an interactive session.

__The Hexed Interface Language is a simple scripting language designed for interfacing with Hexed.__
Creating a whole scripting language just to interface with a CFD solver may seem excessive,
but in fact it addresses some of my greatest frustrations with computational analysis.
Most CFD solvers behave roughly like a washing machine: you adjust a few numbers, hit "go", and hope it gives you what you want.
Usually it does, but occasionally it starts spiraling out of control and you have to manually intervene.
This design is generally adequate to solve easy problems, but more challenging cases often call for more granular control.
For example, suppose you have a hypersonic case where the only way you manage to avoid a crash is by starting with a CFL number of 0.001,
exponentially increasing it by factors of 2 every 1000 time steps until it reaches 10,
switching from local to global time stepping when the residual drops below \f$ 10^{-5} \f$,
and terminating the simulation when the residual drops below \f$ 10^{-8} \f$ or when the CPU time exceeds 3 days, whichever comes first.
Suppose also you want to visualize the flowfield every 100 time steps in the beginning of the simulation to understand the initial transients,
but only every 10000 iterations near the end to save disk space,
and you want to update your restart file every 1000 iterations but save a _separate_ restart file when you switch to global time stepping
so that you don't lose your progress if the global time parameters turn out to be flawed.
Because there is an infinite variety of convoluted pathways a simulation might take,
many solvers implement a multitude of ridiculously specific input parameters and/or require you to manually babysit a simulation
and tweak parameters on the fly.
What we need to recognize is that the real purpose of a CFD solver is to do things that you can't do --
in particular, reading geometry/mesh files, running iterations, and writing visualization files.
To address general use cases, the solver should expose these functions directly
and give you full control over the high-level iteration process.
Of course, there should be builtin defaults to let you run basic cases without any significant programming,
but you should be able to modify the iteration logic without dealing with the solver's source code.

Initially, I thought the best way to achieve this ideal would be to implement bindings to Hexed in an existing scripting language (namely Python).
However, this turned out to have several problems:
- It required much more boilerplate code than I would have liked.
- It made it much harder to debug memory errors, since binding systems tend to introduce memeory leaks and interfere with memory checking tools.
- It doesn't provide an easy way to implement user-defined callback functions (e.g. mesh refinement criteria, integral error metrics)
  that execute in parallel and at C++ speed.

Technically, most CFD solvers _already_ implement a custom scripting language, since input parameters are provided via a text file with custom syntax.
Hexed simply makes its input language Turing-complete with the ability to parse operators (`=`, `+`, `*`, `&`, etc.)
and basic control flow.
The goal of the HIL is to be as simple as possible (both to implement and to learn) while providing all the functionality that you strictly need.

\section literals Types and Literals
Values in HIL have one of 3 types:
- Integer (32-bit signed)
- [Float](https://en.wikipedia.org/wiki/Floating-point_arithmetic) (64-bit)
- String

Note that there is not boolean type.
The integers 0 and 1 are used to represent logical true and false.

You can create one of these values with a _literal_ (as opposed to an _expression_ or a variable evaluation).
Integer and float literals are the same as in any language.
Strings are enclosed in `{}` instead of quotes
to avoid exponential pileup of escape sequences in nested \ref Macros.
Matched pars of `{}` in strings are included literally.
To include an unmatched `{` or `}` in a string, you can escape it with a `\`.
To include an actual `\`, you must escape it with a second `\`.
Strings can include newlines.

Examples:
- `5` and `012` are integer literals.
- `1.0`, `4.`, `0.25`, `.01`, and `5e-4` are float literals.
- `{some chars}` is a string containing the characters `some chars`.
-
~~~{.html}
{{string} \\ with \} special
chars}
~~~
is a string containing the characters
~~~{.html}
{string} \ with } special
chars
~~~

\warning
If you have never programmed in a low-level language before, beware of [integer overflow](https://en.wikipedia.org/wiki/Integer_overflow).

\section Operators
HIL supports a variety of _operators_, which in this context means
things that take in input values (operands), which can be literals or variable references, and produce an output.
Some of these operators are implemented as functions in other languages, but HIL has no concept of a function.
So-called unary operators are placed directly before their operand and binary operators are placed between their operands.
The operators are listed below with their precedence.
Operators with a lower precedence level are evaluated before those with a higher precedence number,
and operators with the same precedence level are evaluated left-to-right.
`()` can be used to override the precedence order and evaluate the enclosed expression(s) first.

Syntactic category | Precedence level | Operator name | Operand types          | Behavior
-------------------|------------------|---------------|------------------------|---------
unary              | 0                | `-`           | integer, float         | inverts sign
^                  | ^                | `!`           | integer                | logical _not_ (`1`, if operand is zero, else `0`)
^                  | ^                | `#`           | string                 | evaluates size of string
^                  | ^                | `sqrt`        | integer, float         | square root (as float)
^                  | ^                | `read`        | string                 | operand is a file path; returns the file contents as a string
^                  | ^                | `print`       | any                    | prints to stdout (without adding a newline) and evaluates to the empty string
^                  | ^                | `println`     | any                    | prints to stdout and then prints a newline (like the Python `print` function) and evaluates to the empty string
^                  | ^                | `shell`       | string                 | executes the operand in the system shell and returns the return code (integer)
^                  | ^                | `$`           | string                 | \ref Macros "macro substitution"
binary             | 1                | `^`           | integer, float         | raises left operand to power of right operand
^                  | ^                | `#`           | string-integer         | returns the _i_ th character of the left operand as a string where _i_ is the right operand
^                  | 2                | `%`           | integer                | modulo
^                  | ^                | `/`           | integer, float         | division
^                  | ^                | `*`           | integer, float         | multiplication
^                  | 3                | `-`           | integer, float         | subtraction
^                  | ^                | `+`           | integer, float, string | For numeric-numeric, addition. For strings, concatenation. If only one argument is a string, the other is converted to a string representation.
^                  | 4                | `==`          | any                    | Evaluates to integer `1` if operands are equal, otherwise `0`. Operands must both be strings or neither.
^                  | ^                | `!=`          | any                    | Evaluates to integer `1` if operands are inequal, otherwise `0` (including if both operands are NaN). Operands must both be strings or neither.
^                  | ^                | `>=`          | integer, float         | `1` if left operand is greater than or equal to right, else `0`
^                  | ^                | `<=`          | integer, float         | `1` if left operand is less than or equal to right, else `0`
^                  | ^                | `>`           | integer, float         | `1` if left operand is greater than right, else `0`
^                  | ^                | `<`           | integer, float         | `1` if left operand is less than right, else `0`
^                  | 5                | `&`           | integer, float         | logical _and_ (`0` if either operand is `0`, else `1`)
^                  | ^                | \|            | integer, float         | logical _or_ (`0` if both operands are `0`, else `1`)
^                  | 6                | `=`           | any                    | \ref variables "Assigns" the value of the left operand to the right operand, which must be a variable name. Evaluates to the value of the right operand.

__Notes:__
- If an operator can be interpreted as unary or binary, it is interpreted as binary.
- If a binary operator accepts both integer and float operands, then the result will be an integer if both operands are integers and a float otherwise.
- The left operand of binary `#` must be a string and the right must be an integer.
- An operator expression which is not nested inside another expression is called a _statement_.
- A statement is terminated by either a newline or a `;` (as long as this terminating character is not inside a string literal).

\section variables Variables and Assignment
The `=` operator can be used to assign a value to a variable.
Variable names may contain letters (case-sensitive), digits, and underscores, but cannot start with a digit.
Variables are created and their type determened when they are assigned a value; variables need not be declared.
Once a variable is created, its value can be referenced in subsequent expressions and its type cannot be changed.
Attempting to assign a value to a variable of a different type will produce an exception,
with the exception that an integer may be assigned to a float (it will be automatically converted and the variable will continue to be a float).
However, HIL is technically dynamically typed since the type that a variable can depend on the path a program takes at runtime.

HIL comes with some builtin variables which are already defined at the start of your program,
and special variables whose value influences the behavior of the solver (i.e. input parameters).
There are also some variables, which I call _Heisenberg variables_ that produce side effects when you evaluate them.
You can't assign to these variables, and exactly what happens when you evaluate them is specially defined for each one.
They are called "Heisenberg" because the fact that observing their value changes the state of the program
is reminiscent of the collapse of the wave function in quantum mechanics.
See \ref builtins and \ref outputs for a list of such variablels.

Technically, an assignment statement is an expression which evaluates to the value of the right-hand-side.
Also, a sequence of statements (assignment or otherwise) evaluates to the value of the last one.
So, for example,
~~~
x = (println {hello world!}; y = z = 0; 15)
~~~
prints `hello world!`, then assigns 0 to both `y` and `z`, then assigns 15 to `x`.
However, these technicalities are unlikely to be relevant to using Hexed.

\section Macros
In HIL, transfer of control flow (e.g. conditionals, iteration, subroutines, recursion) is accomplished by a macro substitution mechanic.
HIL is an interpreted language, meaning that the text of the program is executed as it is parsed.
If the character `$` is encountered while parsing (not inside a string literal),
it must be immediately follwed by a string value (literal, variable, or expression).
This string is then prepended to the remaining text of the program.
For example, suppose you have set `my_string = {1 + 1}` at some point in the program.
Then `x = $my_string` is equivalent to `x = 1 + 1`.
This can be done recursively.
For example, `macro = {println {infinite loop!}; $macro}; $macro` will print "infinite loop!" repeatedly until you kill the process.
Believe it or not, macro substitution can be used to emulate pretty much all of the control flow mechanics that most languages explicitly implement,
if you're willing to write a little extra boilerplate code.
For example, the HIL code
~~~{.html}
case0 = {println {case 0}}
case1 = {println {case 1}}
$$({case} + (predicate != 0))
~~~
is essentially equivalent to the Python code
~~~{.py}
if predicate:
    print("case 0")
else:
    print("case 1")
~~~

\section builtins Builtin Variables
The HIL includes a number of variables, both ordinary and Heisenberg, which are automatically defined at the start of your program.
This section lists the builtin variables that are simply useful for scripting
but not directly related to the input and output functions of the CFD solver itself.
See \ref inputs and \ref outputs for definitions of variables that directly interact with the solver.

\subsection builtin_list List of Builtin Variables

<hr>
\subsubsection Constants
All of the quantities in the `hexed::constants` namespace are included as float variables.
The names are the same as in the C++ library, without the namespace.
So if you want Boltzmann's constant, which in C++ would be `hexed::constants::boltzmann`, you just have to write `boltzmann`.

<hr>
\subsubsection huge
__type:__ float \n
Maximum representable float value (equal to `std::numeric_limits<double>::%max`).

<hr>
\subsubsection newline
__type:__ string \n
A string containing a single newline character, so you can write strings containing newlines on a single line.

<hr>
\subsubsection closebr
__type:__ string \n
A string containg a single `}`, so you can write strings containing an unmatched `}` without explicitly escaping it.

<hr>
\subsubsection true
__type:__ integer \n
Alias for the integer 1, for more readable logical operations.

<hr>
\subsubsection false
__type:__ integer \n
Alias for the integer 0, for more readable logical operations

<hr>
\subsubsection repl
__type:__ string \n
Macro which starts a Read-Evaluate-Print Loop (a.k.a. an interactive session).
Statements executed in the REPL will have read/srite access to the namespace of the program.

<hr>
\subsubsection quit
__type:__ string \n
Macro which, when invoked from the REPL, quits the REPL.
The program which invoked \ref repl will continue executing.
This is different from \ref exit because it terminates only the REPL, not the interpreter itself.

<hr>
\subsubsection ask
__type:__ Heisenberg string \n
Queries stdin (command line input) and gets characters until a newline is received.
Evaluates to a string containing those characters.

<hr>
\subsubsection exit
__type:__ Heisenberg string \n
Terminates the HIL interpreter and evaluates to an empty string.
This is different from \ref quit in that it can be invoked from anywhere (not just the REPL)
and even if it is invoked from the REPL, statements after the \ref repl invokation will not be executed
(because it terminates the whole interpreter).

<hr>
\subsubsection throw
__type:__ Heisenberg string \n
Throws an exception in the C++ implementation of HIL.
Potentially useful if the C++ code contains subsequent statements after the invokation of the HIL interpreter which you don't want to execute.

<hr>

*/
