/*! \page parameters Solver Parameters

\section inputs Input Parameters
This section lists variables that directly affect the behavior of the solver.
Some of them are preset to default values with the intent that you should override them,
and some are __not__ defined and __must__ be defined by you.

\subsection important_imputs Important Input Parameters
Setting these parameters appropriately is critical to get the right answer,
and you should generally think about them every time you run a simulation.

<hr>
\subsubsection n_dim
__type:__ integer \n
Number of dimensions.
Must be at least 1 and at most 3.

<hr>
\subsubsection done
__type:__ string \n
__default:__ `{println {Error: you forgot to a set stop condition} & throw}` \n
Termination condition.
This should be a macro that evaluates to an integer.
It will be evaluated at each iteration, and the simulation will continue iff it evaluates to \ref false.
As should be clear from the default value, you __must__ set this variable yourself.

<hr>
\subsubsection local_time
__type:__ integer \n
__default:__ \ref true \n
If \ref true, use local time stepping, otherwase use global.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection max_safety
__type:__ float \n
__default:__ 0.7 \n
Maximum allowable safety factor on the [CFL condition](https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition)
for time step determination.
The time step will be either this number times the estimated maximum stable time step or \ref max_time_step, whichever is smaller.
This parameter is applicable to both local and global time stepping.
If the actual safety factor (accounting for \ref max_time_step constraints) is greater than 1 the scheme will almost certainly be unstable.
Thus even if you intend for your time integration not to be CFL-driven, it is strongly recommended that you keep this parameter less than 1
and simply make your \ref max_time_step small enough to be the active constraint.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection max_time_step
__type:__ float \n
__default:__ \ref huge \n
Maximum allowable time step.
The time step will be either this number or \ref max_safety times the estimated maximum stable time step, whichever is smaller.
This parameter is only meaningful for global time stepping.
If you intend for your time stepping to be CFL driven, simply keep this number large enough not to be the active constraint.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection transport_model
__type:__ string \n
__default:__ `{inviscid}` \n
Specifies model to use for molecular transport coefficients (viscosity and thermal conductivity).
Accepted values:
- `{inviscid}`
- `{sutherland}`: Uses sutherland's law for air (non-constant Prandtl number)

<hr>
\subsubsection thermal_bc
__type:__ string \n
__default:__ `{heat_flux = 0.}` \n
Only applicable when \ref surface_bc = `{no_slip}`.
Specifies thermal boundary condition.
Default gives an adiabatic wall.
Accepted values:
- `{heat_flux = x}`: Prescribes the wall heat flux (out of the domain, into the wall) to be `x`.
- `{temperature = x}`: Prescribes the temperature at the wall to be `x`.
- `{internal_energy = x}`: Prescribes the internal energy at the wall to be `x`.
  For now, since you're stuck in the CPG world, this is equivalent to `{temperature = x*(heat_rat - 1)/specific_gas_air}`.
- `{emissivity = x; conduction = y; temperature = z}`: \anchor thermal_equilibrium_bc
  Specifies that the wall is in thermal equalibrium according to a simple 1D heat equation.
  Specifically, sets the heat flux equal to the sum of the radiative cooling flux and the thermal conduction through the wall.
  The radiative cooling flux is determined by the [Stefan-Boltzmann Law](https://en.wikipedia.org/wiki/Stefan%E2%80%93Boltzmann_law)
  law with the emissivity \f$ \sigma \f$ given by `emissivity`.
  The conductive flux is determined by assuming that the wall has a small but finite thickness and the temperature on the non-air side is known.
  Specifically, it is equal to \f$ kL(T_w - T_p) \f$ where \f$ k \f$ is the thermal conductivity of the wall material,
  \f$ L \f$ is the wall thickness, \f$ T_w \f$ is the current wall temperature, and \f$ T_p \f$ is the prescribed temperature.
  The product \f$ kL \f$ is equal to `conduction`
  and the prescribed temperature \f$ T_p \f$ is `temperature`.
  You don't have to specify all 3 parameters -- they all default to 0.
  You may specify `emissivity` __and/or__ you may specify the other parameters,
  but if you specify either `conduction` or `temperature` you must specify both.
  If your wall is highly conductive, you might need to reduce \ref heat_flux_coercion to maintain stability.

<hr>
\subsubsection row_size
__type:__ integer \n
__default:__ 6 \n
\ref basis_row_size "Row size" of polynomial basis.
Must be at lead 2 and at most `hexed::config::max_row_size`.

<hr>
\subsubsection attack
__type:__ float \n
__default:__ `0.` \n
Angle of attack (radian, as specified in \ref units).

<hr>
\subsubsection sideslip
__type:__ float \n
__default:__ `0.` \n
Sideslip angle (radian, as specified in \ref units).

<hr>
\subsubsection art_visc_width
__type:__ float \n
__default:__ `-1.` \n
If set to a positive number, turns on aritificial viscosity with a smoothness-based coefficient
and sets the smoothness width to `art_visc_width`.

<hr>
\subsubsection refine_if
__type:__ string \n
__default:__ `{false}` \n
Mesh refinement criterion.
Should be an expression that can be evaluated for each mesh element
in an environment that includes the variables assigned by `hexed::hil_properties::element()`.
If this expression evaluates to \ref true (and \ref unrefine_if evaluates to \ref false), the element will be refined.
Otherwise it will not.

<hr>
\subsubsection mesh_extreme mesh_extreme00, mesh_extreme01, mesh_extreme10, mesh_extreme11, mesh_extreme20, mesh_extreme21
__type:__ float \n
__default:__ 0, 1, 0, 1, 0, 1 \n
Mesh extremes.
That is, all elements will have coordinates \f$ x_0, x_1, x_2 \f$ such that `mesh_extreme00` \f$ \le x_0 \le \f$ `mesh_extreme01`, etc.
If each mesh dimension is an integer multiple of the initial element size, then the above inequalities are equalities.
Of course, only the first \ref n_dim dimensions are considered.

\subsubsection extremal_bc extremal_bc00, extremal_bc01, extremal_bc10, extremal_bc11, extremal_bc20, extremal_bc21
__type:__ string \n
__default:__ `{characteristic}` \n
Boundary conditions for extremal boundaries (defined by \ref mesh_extreme).

<hr>
\subsubsection n_cheby_flow
__type:__ integer \n
__default:__ 1 \n
Number of Chebyshev acceleration stages to use for physical flow.
Increasing this number will help the flow converge faster when/where it is diffusion-dominated but slow it down when/where it is convection-dominated.
Also, it seems to be difficult to maintain stability if this number is greater than roughly 10.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection n_cheby_av
__type:__ integer \n
__default:__ 0.7 \n
Number of Chebyshev acceleration stages to use for diffusion equation for smoothness-based artificial viscosity.
Increasing this number will help the artificial viscosity coefficient converge faster
but cause a larger fraction of the time to be spent in the aritificial viscosity calculation.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection av_advect_iters
__type:__ integer \n
__default:__ 1 \n
Number of pseudotime iterations to run in artificial viscosity advection equation per nominal iteration
(i.e. per `hexed::Solver::set_art_visc_smoothness` call).
Increasing this number will help the artificial viscosity coefficient converge faster
but cause a larger fraction of the CPU time to be spent in the aritificial viscosity calculation.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection flow_iters
__type:__ integer \n
__default:__ 1 \n
Number of physical flow iterations to run per nominal iteration
(i.e. per `hexed::Solver::update` call).
Increasing this number can help balance the amount of CPU time spent in the physical flow relative to the artificial viscosity iteration
if `n_cheby_av` is larger than `n_cheby_flow`.
The disadvantage is it can cause the \ref iteration count to be misleading.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection init_layer_splits
__type:__ integer \n
__default:__ 0 \n
Number of times to call \ref split_layers during initial mesh generation (immediately after surface-based refinement but before state initialization).
If you don't edit \ref layer_split_points, then the wall spacing will be \f$ 3^{-\mathtt{\text{init_layer_splits}}} \f$ times the local isotropic mesh spacing.
The default value of 0 is appropriate for inviscid simulations, but for high Reynolds-number viscous simulations it should be greater than zero.
There currently is not a well-established best practice for how large it needs to be,
but having the boundary layer be one or two wall layers thick often works well for subsonic simulations,
and significantly more layers are often required for hypersonic simulations with a cold wall.

<hr>
\subsubsection max_ref_level
__type:__ float \n
__default:__ 10 \n
When performing geometry-based refinement with \ref set_geometry_refinement,
elements will not be refined beyond this refinement level.
This prevents excessive refinement in certain no-win scenarios such as sharp edges.
This parameter must often be adjusted based on the scale of the geometry.

<hr>

\subsection useful_inputs Useful Input Parameters
You will probably want to adjust these parameters for some simulations, but you can often leave them alone.

<hr>
\subsubsection init_ref_level
__type:__ integer \n
__default:__ 3 \n
Number of levels to refine the mesh in \ref init_refinement before surface geometry is introduced.
May be any nonnegative integer, up to time and memory constraints.

<hr>
\subsubsection surface_bc
__type:__ string \n
__default:__ `{auto}` \n
Specifies surface boundary condition.
If `{auto}`, surface boundary condition will be determined automatically depending on the value of \ref transport_model.
`{inviscid}` &rarr; `{nonpenetration}` and `{sutherland}` &rarr; `{no_slip}`.
Otherwise, the name of a supported \ref boundary_conditions "Boundary condition type".

<hr>
\subsubsection temperature_offset
__type:__ float \n
__default:__ `0.` \n
Applicable when altitude is specified.
Sets the temperature offset passed to `hexed::standard_atmosphere`.

<hr>
\subsubsection geometry_uncertainty
__type:__ float \n
__default:__ 3e-3 \n
When performing geometry-based refinement with \ref set_geometry_refinement,
a nondimensional uncertainty metric for the surface representation will be compared to this value,
and any elements with a larger value will be refined.
Thus reducing this number results in a finer mesh and vice versa,
although the default value produces reasonable results in a wide range of cases, in my opinion.

<hr>
\subsubsection art_visc_constant
__type:__ float \n
__default:__ `-1.` \n
If set to a positive number, turns on aritificial viscosity and sets the artificial viscosity coefficient to be uniformly equal to `art_visc_constant`.

<hr>
\subsubsection fix_therm_admis
__type:__ integer \n
__default:__ \ref false \n
If \ref true, check thermodynamic admissibility (positive density, nonnegative energy, non-NaN state) after every time integration stage
and if problems are found, run as many Laplacian smearing iterations as neccessary to restore admissibility.
Results in a major robustness improvement for hypersonic cases and comes at a modest performance cost.

<hr>
\subsubsection working_dir
__type:__ string \n
__default:__ `{hexed_out/}` \n
Directory in which to write output files.
Path can be relative or absolute.
If the directory does not exist, it will be created.
Any modifications to this variable must take place before the solver is initialized.

<hr>
\subsubsection vis_freq
__type:__ integer \n
__default:__ 10000 \n
Visualization files will be written every `vis_freq` iterations.

<hr>
\subsubsection print_freq
__type:__ integer \n
__default:__ 100 \n
Solver status will be printed to stdout every `print_freq` iterations.

<hr>
\subsubsection unrefine_if
__type:__ string \n
__default:__ `{false}` \n
Mesh unrefinement criterion.
Behaves the same as \ref refine_if except that if this expression evaluates to \ref true (and \ref refine_if evaluates to \ref false),
the element will be unrefined (subject to refinement level constraints).

<hr>
\subsubsection max_refinement_iters
__type:__ integer \n
__default:__ 100 \n
Maximum number of refinement sweeps to run if refinement convergence is not achieved.

<hr>
\subsubsection n_smooth
__type:__ integer \n
__default:__ 30 \n
Number of mesh smoothing iterations to run after every surface-geometry-based refinement sweep.

<hr>
\subsubsection geom_n_segments
__type:__ integer \n
__default:__ 1000 \n
Number of subdivisions to use when discretizing 2D CAD geometry with `hexed::Occt::segments`.

<hr>
\subsubsection vis_surface
__type:__ integer \n
__default:__ \ref true \n
Whether to visualize surface data when \ref visualize is invoked.

<hr>
\subsubsection vis_field
__type:__ integer \n
__default:__ \ref true \n
Whether to visualize field data when \ref visualize is invoked.

<hr>
\subsubsection vis_tecplot
__type:__ integer \n
__default:__ \ref true \n
If \ref true, write visualization files in Tecplot format (requires compilation with `use_tecplot` `ON`).

<hr>
\subsubsection vis_xdmf
__type:__ integer \n
__default:__ \ref true \n
If \ref true, write visualization files in XDMF format (requires compilation with `use_xdmf` `ON`).

<hr>
\subsubsection vis_field_vars
__type:__ string \n
__default:__ `state_vars + art_visc_expr` \n
\ref struct_expr "Structured expression" specifying which field variables to visualize.

<hr>
\subsubsection vis_surface_vars
__type:__ string \n
__default:__ `state_vars + visc_stress_expr + heat_flux_expr` \n
\ref struct_expr "Structured expression" specifying which surface variables to visualize.

<hr>
\subsubsection vis_n_sample
__type:__ integer \n
__default:__ 10 \n
Each element will be visualized at sample points distributed in a uniformly-spaced structured block with `vis_n_sample` points on each edge.
If you want, you can think of this as the visualization \ref basis_row_size "row size".

<hr>
\subsubsection print_vars
__type:__ string \n
__default:__ `iteration_expr + residual_expr + av_advection_residual_expr + av_diffusion_residual_expr + flow_time_expr + time_step_expr` \n
\ref struct_expr "Structured expression" specifying what quantities to print when the solver status is printed.

<hr>
\subsubsection integrand_field
__type:__ string \n
__default:__ `{}` \n
\ref struct_expr "Structured expression" specifying what quantities integrate when field integrals are computed.

<hr>
\subsubsection integrand_surface
__type:__ string \n
__default:__ `{}` \n
\ref struct_expr "Structured expression" specifying what quantities integrate when surface integrals are computed.

<hr>
\subsubsection max_angle
__type:__ float \n
__default:__ `10*degree`
Maximum allowable angle between adjacent panels when discretizing 3D CAD geometry with `hexed::Occt::triangles`.

<hr>
\subsubsection max_deflection
__type:__ float \n
__default:__ \ref huge \n
Maximum allowable linear deflection of surface panels when discretizing 3D CAD geometry with `hexed::Occt::triangles` (dimensional).

<hr>
\subsubsection flood_fill_start flood_fill_start0, flood_fill_start1, flood_fill_start2
__type:__ float \n
__default:__ \ref huge, huge, huge \n
Location to start the flood fill algorithm when \ref add_geom is evaluated.
If any of the coordinates are not within the \ref mesh_extreme "mesh extremes" (which is the case by default),
the flood fill start location will effectively default to the minimum corner of the domain
(`mesh_extreme00`, `mesh_extreme10`, `mesh_extreme20`).

<hr>
\subsubsection init_cond
__type:__ string \n
__default:__
~~~{.unformatted}
{state0 = freestream0
 state1 = freestream1
 state2 = freestream2
 state3 = freestream3
 state4 = freestream4
}
~~~
\ref struct_expr "Structured expression" which sets the state variables `state0`, `state1`, ... to the desired initial condition.
It shall be evaluated in an environment that includes the variables `pos0`, `pos1`, `pos2`, and `time`.

<hr>
\subsubsection fix_admis_max_safety
__type:__ float\n
__default:__ 0.7 \n
Maximum safety factor for Laplacian smearing iterations when fixing thermodynamic admissibility.
\note Not defined until \ref create_solver is evaluated.
\see \ref fix_therm_admis

<hr>
\subsubsection av_advect_max_safety
__type:__ float\n
__default:__ 0.7 \n
Maximum safety factor on pseudotime step in advection equation for smoothness-based artificial viscosity.
Analogous to \ref max_safety.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection av_diff_max_safety
__type:__ float\n
__default:__ 0.7 \n
Maximum safety factor on pseudotime step in diffusion equation for smoothness-based artificial viscosity.
Analogous to \ref max_safety.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection layer_split_points
__type:__ string \n
__default:__ `{split0 = 1./3.;}` \n
\ref struct_expr "Structured expression" defining the aspect ratio of anisotropic wall layers created by \ref split_layers.
The values of the variables in the expression determine the split points in order from closest to the wall to farthest.
The names of the variables are irrelevant.

<hr>

\subsection esoteric_inputs Esoteric Input Parameters
You will probably never need to worry about these parameters.
They are tunable in principle, but in practice the same values tend to work for pretty much every problem.
In some cases, even I don't fully understand why the accepted defaults work.

<hr>
\subsubsection mesh_extreme_eps
__type:__ float \n
__default:__ `1e-6` \n
Comparison tolerance to use when deterimining whether points are inside or outside mesh extremes.
Relative to domain size.

<hr>
\subsubsection av_diff_iters
__type:__ integer \n
__default:__ 1 \n
Number of pseudotime iterations to run in artificial viscosity diffusion equation per nominal iteration
(i.e. per `hexed::Solver::set_art_visc_smoothness` call).
Increasing this number will help the artificial viscosity coefficient converge faster
but cause a larger fraction of the CPU time to be spent in the aritificial viscosity calculation.
\note This was useful before Chebyshev acceleration was discovered.
Increasing \ref n_cheby_av instead will usually be more productive, up to the limit where stability falls apart.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection av_diff_ratio
__type:__ float\n
__default:__ 0.1 \n
Determines amount of to smear artificial viscosity coefficient for smoothness-based artificial viscosity.
A larger number means that the artificial viscosity field will be smoother but also spread further from the shocks.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection av_visc_mult
__type:__ float\n
__default:__ 30. \n
Final linear scaling parameter on smoothness-based artificial viscosity coefficient.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection av_unscaled_max
__type:__ float\n
__default:__ 2e-4 \n
Maximum amount of artificial viscosity allowed before dimensional scaling.
If this value is too small, artificial viscosity will not be sufficient to fully capture shocks.
If it is too large, excessively small time steps may be encountered during the initial transient phase of the simulation.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection av_advect_max_res
__type:__ float\n
__default:__ 1e-3 \n
Limit on the residual in the advection equation for smoothness-based artificial viscosity determination
to improve robustness when weak instabilities are encountered.
\note Not defined until \ref create_solver is evaluated.

<hr>
\subsubsection vis_lts_constraints
__type:__ integer \n
__default:__ \ref false \n
If \ref true, visualize the local time step constraints due to convection and diffusion, respectively.

<hr>
\subsubsection iter_width
__type:__ integer \n
__default:__ 10 \n
Visualization file names will contain iteration numbers with leading zeros added such that there are at least `iter_width` digits.

<hr>
\subsubsection heat_flux_coercion
__type:__ float \n
__default:__ 2. \n
When weakly applying heat flux boundary conditions, this determines how strongly the heat flux is coerced to match the prescribed value.
If this number is too large, the simulation might be unstable, but if it too small the boundary condition might not be fully satisfied.
The default value is adequate for almost all cases, but there are rare situations in which it might need to be reduced.

<hr>
\subsubsection buffer_dist
__type:__ float \n
__default:__ `0.8*sqrt(n_dim)` \n
During the surface element deletion step of mesh generation, elements will be deleted iff their center is within `buffer_dist*nom_sz` of the geometry surface.
As long as `buffer_dist >= .5*sqrt(n_dim)`, this guarantees that none of the remaining elements will intersect the surface,
but as the default suggests, a somewhat larger value can help to ensure viable mesh quality.

<hr>
\subsubsection shock_sub_iters
__type:__ integer \n
__default:__ 10
number of sub-iterations to run in each nominal iteration to get efficient Chebyshev-accelerated diffusion (when $\ref set_shock has been called)

<hr>
\subsubsection ramping_initial_iters
__type:__ integer \n
__default:__ 1000 \n
number of initial iterations to run at a small safety factor (\ref ramping_initial_safety) to let the artificial viscosity catch up (when $\ref set_ramping has been called)

<hr>
\subsubsection ramping_initial_safety
__type:__ float \n
__default:__ 3e-3 \n
safety factor to use in initial iterations

<hr>
\subsubsection ramping_final_safety
__type:__ float \n
__default:__ 0.7 \n
will revert to this factor after initial iterations are complete (when $\ref set_ramping)

<hr>

\section commands Command Variables & Macros
The following variables are used to execute actions.
Some are Heisenberg variables which, when evaluated, cause the solver to perform certain tasks,
while others are simply HIL macros.
Most of the time you shouldn't need to know about most of these variables.
The only ones you need to use in every simulation are `init` and `run.
The remaining ones are either called by those two are are only necessary for specific situations,
but all are made available to you to help you deal with edge cases that the default behavior does not cover.
See example cases for standard best practices.

\subsection command_list List of Command Variables

<hr>
\subsubsection init
__type:__ string (macro) \n
Generates mesh and initializes solver.
Behavior is roughly the following:
-# creates working directory if it does not already exist
-# copies the inpute file to the working directory for the user's future reference
-# sets an automatically-determined variables
-# calls \ref create_solver
-# calls \ref init_refinement
-# calls \ref add_geom
-# calls \ref refine as many times as appropriate
-# calls \ref split_layers as many times as appropriate
-# calls \ref init_state
-# visualizes solution

<hr>
\subsubsection run
__type:__ string (macro) \n
Executes solution (requires \ref init to have been called).
Behavior is roughly the following:
-# creates \ref runtime_cmd "runtime_cmd.hil" if it does not already exist.
-# calls \ref iterate as many times as appropriate
-# visualizes solution

<hr>
\subsubsection iterate
__type:__ string (macro) \n
Executes one iteration (called by \ref run).
Behavior is roughly the following:
-# calls \ref update
-# computes residuals
-# prints history variables
-# visualizes solution
-# executes any commands in \ref runtime_cmd "runtime_cmd.hil" and empties the file

The user can modify the behavior of the iteration loop by adding additional \ref hil "HIL" code to the beginning or the end of this macro.

<hr>
\subsubsection create_solver
__type:__ Heisenberg integer \n
Creates a `hexed::Solver` object and returns 0.
Mesh contains a single element and the flow is uninitialized.

<hr>
\subsubsection init_refinement
__type:__ Heisenberg integer \n
Performs initial refinment (not based on geometry surface) and returns 0.

<hr>
\subsubsection add_geom
__type:__ Heisenberg integer \n
Inserts geometry into mesh and returns 0.
You can define 0 or more string variables named `geom0`, `geom1`, `geom2`, ... containing paths to geometry definition files.
Paths can be absolute or relative to execution directory (not \ref working_dir).
Geometry variable numbers must start at 0 and be consecutive.
E.g., if you define `geom0 = leading.txt`, `geom1 = main.txt`, `geom3 = trailing.txt`, then `geom3` will be ignored.
If these geometries split the domain into disjoint regions,
then the region containing the \ref flood_fill_start "flood fill start" shall be meshed.
Geometry file format is inferred from the file extension, which is case-insensitive.
The following extension/format combinations are supported:
- `.csv`: Comma Separated Value format (2D only).
  A comma-delimited table with at least 2 columns, which are interpreted as \f$ x_0 \f$ and \f$ x_1 \f$ coordinates of the nodes of a polygonal curve,
  in \ref units "standard units".
  Curve is treated as open -- if you are trying to model a closed shape, simply make the first point (approximately) equal to the last.
- `.igs`, `.iges`: [IGES](https://en.wikipedia.org/wiki/IGES) CAD format (2D or 3D).
  For 2D simulations, the model edges will be extracted and projected onto the \f$ (x_0, x_1) \f$ plane.
  For 3D simulations, the model surfaces will be used.
  Units are read from the file and converted.
- `.stp`, `.step`: [STEP](https://en.wikipedia.org/wiki/ISO_10303-21) CAD format. As above.
- `.stl`: [STL](https://en.wikipedia.org/wiki/STL_(file_format)) 3D geometry format (3D only).
  ASCII or binary formats accepted.
  Units are assumed to be \ref units "standard".

<hr>
\subsubsection refine
__type:__ Heisenberg integer \n
Performs one refinement sweep and returns 0.
Elements are refined or unrefined based on \ref refine_if and \ref unrefine_if.

<hr>
\subsubsection init_state
__type:__ Heisenberg integer \n
Initializes the solver state to \ref init_cond and returns 0.

<hr>
\subsubsection visualize
__type:__ Heisenberg integer \n
Writes visualization files and returns 0.

<hr>
\subsubsection compute_residuals
__type:__ Heisenberg string \n
Evaluates the residuals and assigns them to float variables \ref residual_momentum, \ref residual_density, \ref residual_energy.
Returns the empty string.

<hr>
\subsubsection compute_forces
__type:__ string (macro) \n
Computes aerodynamic forces and force coefficients.
Will assign values to the following variables
- `force0`
- `force1`
- `force2`
- `drag`
- `lift`
- `side_force`
- `drag_coef`
- `lift_coef`
- `side_force_coef`

Any of the above which are not applicable to the dimensionality of the problem are set to zero.
This macro involves computing integrals, so it has non-negligible performance overhead if called very frequently.

<hr>
\subsubsection print_forces
__type:__ string (macro) \n
Calls \ref compute_forces and prints the results in a pretty way.

<hr>
\subsubsection plot_history
__type:__ string (macro) \n
Creates a real-time, interactive plot of the convergence history.
Specifically, it starts a background process which creates a `hexed_utils.History_plot` instance in a Python interpreter.
Usually, this macro should be executed before \ref init and \ref run.

<hr>
\subsubsection update
__type:__ Heisenberg string \n
Executes \ref print_freq solver iterations and returns an empty string.
Each "solver iteration" consists of:
-# Calling `hexed::Solver::set_art_visc_constant`, if applicable.
-# Calling `hexed::Solver::set_art_visc_smoothness`, if applicable.
-# Calling `hexed::Solver::update`.

<hr>
\subsubsection integrate_field
__type:__ Heisenberg string \n
Computes integrals of the variables in \ref integrand_field over the domain by the native quadrature rule of the numerical scheme.
The integrals of the variables are assigned to float variables names `integral_field_var` where `var` is the name of the variable.
Returns an empty string.

<hr>
\subsubsection integrate_surface
__type:__ Heisenberg string \n
Computes integrals of the variables in \ref integrand_surface over the geometry surface by the native quadrature rule of the numerical scheme.
The integrals of the variables are assigned to float variables names `integral_surface_var` where `var` is the name of the variable.
Returns an empty string.

<hr>
\subsubsection split_layers
__type:__ Heisenberg integer \n
Creates anisotropic wall layers by splitting the last wall layer (the layer of extruded elements closest to the geometry surface) into thinner layers.
The layer will be split at user-specified set of points controlled by \ref layer_split_points.
For each split point, the layer will be cut by the level surface where the wall-normal reference coordinate equals that value.
Thus split points should be strictly increasing and in the interval (0, 1).
For example, to split the last wall layer into 4 approximately equal parts, you could set `layer_split_points = {split0 = 0.25; split1 = 0.5; split2 = 0.75}` and then evaluate `split_layers`.
The state of the original layer will be interpolated into the new layers, so layer splitting can be performed dynamically as a simulation is running.
Evaluates to 0.

<hr>
\subsubsection set_geometry_refinement
__type:__ string (macro) \n
Sets \ref refine_if and \ref unrefine_if to refine elements in order to efficiently resolve the geometry surface.
\see \ref max_ref_level
\see \ref geometry_uncertainty

<hr>
\subsubsection set_shock
__type:__ string (macro) \n
Configures settings to be good for shock capturing (in particular turning on smoothness-based artificial viscosity).

<hr>
\subsubsection set_ramping
__type:__ string (macro) \n
Implements a crude CFL ramping scheme.
The CFL safety factor is initially set to a very small value (\ref ramping_initial_safety)
and then after a set number of iterations (\ref ramping_initial_iters) it is instantaneously increased to a reasonable value (\ref ramping_final_safety).
The reason why this is necessary is that the artificial viscosity coefficient can take time to adjust to the flow conditions,
so an initial condition where the flow does not satisfy the boundary conditions and the artificial viscosity coefficient is zero can cause robustness problems.
It is usually only necessary in supersonic viscous simulations.

<hr>
\subsubsection set_aerothermo
__type:__ string (macro) \n
Configures settings to be good for aerothermodynamics.
Assumes $\ref set_shock has already been called.
Automaticall calls $\ref set_ramping.

<hr>

\section outputs Output Parameters
The following variables are defined and/or updated by the solver in order to provide information to you.
Some are Heisenberg variables whereas others are writable,
but you should not write to them even if you are technically able to.
Not all of these variables are defined at the start of the simulation.
See individual documentation for details.

\subsection output_list List of Output Parameters

<hr>
\subsubsection input_file
__type:__ string \n
If \ref hexecute was invoked from an input file, `input_file` will be the path to the input file (relative or absolute as provided by user).
If this is an interactive session, it will be an empty string.

<hr>
\subsubsection version
__type:__ string \n
Version of Hexed you are running in `{major.minor.patch}` format.

<hr>
\subsubsection version_major
__type:__ int \n
Major (first) component of \ref version.

<hr>
\subsubsection version_minor
__type:__ int \n
Minor (second) component of \ref version.

<hr>
\subsubsection version_patch
__type:__ int \n
Patch (third) component of \ref version.

<hr>
\subsubsection commit
__type:__ string \n
Commit hash of the source code your Hexed binary was compiled from.
If you're running a release version, this should be redundant with \ref version,
but if you're running a development version, it tells you how far ahead of the latest release you are.

<hr>
\subsubsection license
__type:__ string \n
Information about the copyright of this software and the license, if any, under which it was provided to you.

<hr>
\subsubsection iteration
__type:__ integer \n
Number of iterations executed since solver was created.
Equal to \ref print_freq times the number of \ref update evaluations.

<hr>
\subsubsection wall_time
__type:__ float \n
Wall clock time (seconds) elapsed since solver was created.
Not to be confused with \ref flow_time -- if the distinction isn't clear, here is an example:
if you start a simulation and then take a 5-minute break to make coffee,
if your simulation is still running upon your return the wall time will be 5*60s = 300s.

<hr>
\subsubsection flow_time
__type:__ float \n
Amount of time (seconds) elapsed in the physical flow since the simulation started.
Only meaningful for global time stepping.
Not to be confused with \ref wall_time -- if the distinction isn't clear, here is an example:
if you have a shock propagating at 100 m/s and run your simulation with global time stepping
until the flow time reaches 0.01 s, then the shock will have propaged a distance of 1 m.

<hr>
\subsubsection time_step
__type:__ float \n
Time step taken in the most recent iteration.
Only meaningful for global time stepping.

<hr>
\subsubsection header
__type:__ Heisenberg string \n
The names of the \ref print_vars variables as a comma-delimited list.

<hr>
\subsubsection report
__type:__ Heisenberg string \n
Evaluates \ref compute_residuals and then returns the values of the \ref print_vars variables as a comma-delimited list.

<hr>
\subsubsection residual_momentum
__type:__ float \n
Magnitude of the dimensional residual of the vector momentum equation.
Begins the simulation uninitialized and is only assigned when \ref compute_residuals is evaluated.

<hr>
\subsubsection residual_density
__type:__ float \n
Dimensional residual of the continuity equation.
Begins the simulation uninitialized and is only assigned when \ref compute_residuals is evaluated.

<hr>
\subsubsection residual_energy
__type:__ float \n
Dimensional residual of the energy equation.
Begins the simulation uninitialized and is only assigned when \ref compute_residuals is evaluated.

<hr>
\subsubsection av_advection_residual
__type:__ float \n
Residual of artificial viscosity advection equation.
Begins the simulation uninitialized and is only assigned when \ref update is evaluated with smoothness-based artificial viscosity.

<hr>
\subsubsection av_diffusion_residual
__type:__ float \n
Residual of artificial viscosity diffusion equation.
Begins the simulation uninitialized and is only assigned when \ref update is evaluated with smoothness-based artificial viscosity.

<hr>
\subsubsection n_elements
__type:__ Heisenberg integer \n
The number of elements currently in the mesh.

<hr>
\subsubsection performance_report
__type:__ Heisenberg string \n
Human-readable summary of kernel performance metrics for all iterations that have been run in the current simulation.

<hr>

*/
