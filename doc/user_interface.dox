/*! \page user_interface User Interface
Hexed is designed to be used in two ways.
You can use the C++ library \ref hexed to integrate it directly into your own code.
However, for the likely case that you don't want to program in C++, Hexed also supports a command line interface.
To distinguish it from the library, the command to _execute Hexed_ is `hexecute` (apologies for my terrible sense of humor).
Without any arguments, `hexecute` will begin an interactive session where you can enter commands in the \ref hil.
Alternatively, you can provide a single argument which is the name of a file containing \ref hil commands.
It will then execute these commands as though you had entered them in an interactive session.

\section hil Hexed Interface Language
__The Hexed Interface Language (HIL) is a simple scripting language designed for interfacing with Hexed.__
Creating a whole scripting language just to interface with a CFD solver may seem excessive,
but in fact it addresses some of my greatest frustrations with computational analysis.
Most CFD solvers behave roughly like a washing machine: you adjust a few numbers, hit "go", and hope it gives you what you want.
Usually it does, but occasionally it starts spiraling out of control and you have to manually intervene.
This design is generally adequate to solve easy problems, but more challenging cases often call for more granular control.
For example, suppose you have a hypersonic case where the only way you manage to avoid a crash is by starting with a CFL number of 0.001,
exponentially increasing it by factors of 2 every 1000 time steps until it reaches 10,
switching from local to global time stepping when the residual drops below \f$ 10^{-5} \f$,
and terminating the simulation when the residual drops below \f$ 10^{-8} \f$ or when the CPU time exceeds 3 days, whichever comes first.
Suppose also you want to visualize the flowfield every 100 time steps in the beginning of the simulation to understand the initial transients,
but only every 10000 iterations near the end to save disk space,
and you want to update your restart file every 1000 iterations but save a _separate_ restart file when you switch to global time stepping
so that you don't lose your progress if the global time parameters turn out to be flawed.
Because there is an infinite variety of convoluted pathways a simulation might take,
many solvers implement a multitude of ridiculously specific input parameters and/or require you to manually babysit a simulation
and tweak parameters on the fly.
What we need to recognize is that the real purpose of a CFD solver is to do things that you can't do --
in particular, reading geometry/mesh files, running iterations, and writing visualization files.
To address general use cases, the solver should expose these functions directly
and give you full control over the high-level iteration process.
Of course, there should be builtin defaults to let you run basic cases without any significant programming,
but you should be able to modify the iteration logic without dealing with the solver's source code.

Initially, I thought the best way to achieve this ideal would be to implement bindings to Hexed in an existing scripting language (namely Python).
However, this turned out to have several problems:
- It required much more boilerplate code than I would have liked.
- It made it much harder to debug memory errors, since binding systems tend to introduce memeory leaks and interfere with memory checking tools.
- It doesn't provide an easy way to implement user-defined callback functions (e.g. mesh refinement criteria, integral error metrics)
  that execute in parallel and at C++ speed.

Technically, most CFD solvers _already_ implement a custom scripting language, since input parameters are provided via a text file with custom syntax.
Hexed simply makes its input language Turing-complete with the ability to parse operators (`=`, `+`, `*`, `&`, etc.)
and basic control flow.
The goal of the HIL is to be as simple as possible (both to implement and to learn) while providing all the functionality that you strictly need.

\subsection literals Types and Literals
Values in HIL have one of 3 types:
- Integer (32-bit signed)
- [Float](https://en.wikipedia.org/wiki/Floating-point_arithmetic) (64-bit)
- String

Note that there is not boolean type.
The integers 0 and 1 are used to represent logical true and false.

You can create one of these values with a _literal_ (as opposed to an _expression_ or a variable evaluation).
Integer and float literals are the same as in any language.
Strings are enclosed in `{}` instead of quotes
to avoid exponential pileup of escape sequences in nested \ref Macros.
Matched pars of `{}` in strings are included literally.
To include an unmatched `{` or `}` in a string, you can escape it with a `\`.
To include an actual `\`, you must escape it with a second `\`.
Strings can include newlines.

Examples:
- `5` and `012` are integer literals.
- `1.0`, `4.`, `0.25`, `.01`, and `5e-4` are float literals.
- `{some chars}` is a string containing the characters `some chars`.
-
~~~{.html}
{{string} \\ with \} special
chars}
~~~
is a string containing the characters
~~~{.html}
{string} \ with } special
chars
~~~

\warning
If you have never programmed in a low-level language before, beware of [integer overflow](https://en.wikipedia.org/wiki/Integer_overflow).

\subsection Operators
HIL supports a variety of _operators_, which in this context means
things that take in input values (operands), which can be literals or variable references, and produce an output.
Some of these operators are implemented as functions in other languages, but HIL has no concept of a function.
So-called unary operators are placed directly before their operand and binary operators are placed between their operands.
The operators are listed below with their precedence.
Operators with a lower precedence level are evaluated before those with a higher precedence number,
and operators with the same precedence level are evaluated left-to-right.
`()` can be used to override the precedence order and evaluate the enclosed expression(s) first.

Syntactic category | Precedence level | Operator name | Operand types          | Behavior
-------------------|------------------|---------------|------------------------|---------
unary              | 0                | `-`           | integer, float         | inverts sign
^                  | ^                | `!`           | integer                | logical _not_ (`1`, if operand is zero, else `0`)
^                  | ^                | `#`           | string                 | evaluates size of string
^                  | ^                | `sqrt`        | integer, float         | square root (as float)
^                  | ^                | `read`        | string                 | operand is a file path; returns the file contents as a string
^                  | ^                | `print`       | any                    | prints to stdout (without adding a newline) and evaluates to the empty string
^                  | ^                | `println`     | any                    | prints to stdout and then prints a newline (like the Python `print` function) and evaluates to the empty string
^                  | ^                | `shell`       | string                 | executes the operand in the system shell and returns the return code (integer)
^                  | ^                | `$`           | string                 | \ref Macros "macro substitution"
binary             | 1                | `^`           | integer, float         | raises left operand to power of right operand
^                  | ^                | `#`           | string-integer         | returns the _i_ th character of the left operand as a string where _i_ is the right operand
^                  | 2                | `%`           | integer                | modulo
^                  | ^                | `/`           | integer, float         | division
^                  | ^                | `*`           | integer, float         | multiplication
^                  | 3                | `-`           | integer, float         | subtraction
^                  | ^                | `+`           | integer, float, string | For numeric-numeric, addition. For strings, concatenation. If only one argument is a string, the other is converted to a string representation.
^                  | 4                | `==`          | any                    | Evaluates to integer `1` if operands are equal, otherwise `0`. Operands must both be strings or neither.
^                  | ^                | `!=`          | any                    | Evaluates to integer `1` if operands are inequal, otherwise `0` (including if both operands are NaN). Operands must both be strings or neither.
^                  | ^                | `>=`          | integer, float         | `1` if left operand is greater than or equal to right, else `0`
^                  | ^                | `<=`          | integer, float         | `1` if left operand is less than or equal to right, else `0`
^                  | ^                | `>`           | integer, float         | `1` if left operand is greater than right, else `0`
^                  | ^                | `<`           | integer, float         | `1` if left operand is less than right, else `0`
^                  | 5                | `&`           | integer, float         | logical _and_ (`0` if either operand is `0`, else `1`)
^                  | ^                | \|            | integer, float         | logical _or_ (`0` if both operands are `0`, else `1`)
^                  | 6                | `=`           | any                    | \ref variables "Assigns" the value of the left operand to the right operand, which must be a variable name. Evaluates to the value of the right operand.

__Notes:__
- If an operator can be interpreted as unary or binary, it is interpreted as binary.
- If a binary operator accepts both integer and float operands, then the result will be an integer if both operands are integers and a float otherwise.
- The left operand of binary `#` must be a string and the right must be an integer.
- An operator expression which is not nested inside another expression is called a _statement_.
- A statement is terminated by either a newline or a `;` (as long as this terminating character is not inside a string literal).

\subsection variables Variables and Assignment
The `=` operator can be used to assign a value to a variable.
Variable names may contain letters (case-sensitive), digits, and underscores, but cannot start with a digit.
Variables are created and their type determened when they are assigned a value; variables need not be declared.
Once a variable is created, its value can be referenced in subsequent expressions and its type cannot be changed.
Attempting to assign a value to a variable of a different type will produce an exception,
with the exception that an integer may be assigned to a float (it will be automatically converted and the variable will continue to be a float).
However, HIL is technically dynamically typed since the type that a variable can depend on the path a program takes at runtime.

HIL comes with some builtin variables which are already defined at the start of your program,
and special variables whose value influences the behavior of the solver (i.e. input parameters).
There are also some variables, which I call _Heisenberg variables_ that produce side effects when you evaluate them.
You can't assign to these variables, and exactly what happens when you evaluate them is specially defined for each one.
They are called "Heisenberg" because the fact that observing their value changes the state of the program
is reminiscent of the collapse of the wave function in quantum mechanics.
See \ref builtins and \ref outputs for a list of such variablels.

Technically, an assignment statement is an expression which evaluates to the value of the right-hand-side.
Also, a sequence of statements (assignment or otherwise) evaluates to the value of the last one.
So, for example,
~~~
x = (println {hello world!}; y = z = 0; 15)
~~~
prints `hello world!`, then assigns 0 to both `y` and `z`, then assigns 15 to `x`.
However, these technicalities are unlikely to be relevant to using Hexed.

\subsection Macros
In HIL, transfer of control flow (e.g. conditionals, iteration, subroutines, recursion) is accomplished by a macro substitution mechanic.
HIL is an interpreted language, meaning that the text of the program is executed as it is parsed.
If the character `$` is encountered while parsing (not inside a string literal),
it must be immediately follwed by a string value (literal, variable, or expression).
This string is then prepended to the remaining text of the program.
For example, suppose you have set `my_string = {1 + 1}` at some point in the program.
Then `x = $my_string` is equivalent to `x = 1 + 1`.
This can be done recursively.
For example, `macro = {println {infinite loop!}; $macro}; $macro` will print "infinite loop!" repeatedly until you kill the process.
Believe it or not, macro substitution can be used to emulate pretty much all of the control flow mechanics that most languages explicitly implement,
if you're willing to write a little extra boilerplate code.
For example, the HIL code
~~~{.html}
case0 = {println {case 0}}
case1 = {println {case 1}}
$$({case} + (predicate != 0))
~~~
is essentially equivalent to the Python code
~~~{.py}
if predicate:
    print("case 0")
else:
    print("case 1")
~~~

\subsection builtins Builtin Variables
The HIL includes a number of variables, both ordinary and Heisenberg, which are automatically defined at the start of your program.
This section lists the builtin variables that are simply useful for scripting
but not directly related to the input and output functions of the CFD solver itself.
See \ref inputs and \ref outputs for definitions of variables that directly interact with the solver.

<hr>
\subsubsection Constants
All of the quantities in the `hexed::constants` namespace are included as float variables.
The names are the same as in the C++ library, without the namespace.
So if you want Boltzmann's constant, which in C++ would be `hexed::constants::boltzmann`, you just have to write `boltzmann`.

<hr>
\subsubsection huge
__type:__ float \n
Maximum representable float value (equal to `std::numeric_limits<double>::%max`).

<hr>
\subsubsection newline
__type:__ string \n
A string containing a single newline character, so you can write strings containing newlines on a single line.

<hr>
\subsubsection closebr
__type:__ string \n
A string containg a single `}`, so you can write strings containing an unmatched `}` without explicitly escaping it.

<hr>
\subsubsection true
__type:__ integer \n
Alias for the integer 1, for more readable logical operations.

<hr>
\subsubsection false
__type:__ integer \n
Alias for the integer 0, for more readable logical operations

<hr>
\subsubsection repl
__type:__ string \n
Macro which starts a Read-Evaluate-Print Loop (a.k.a. an interactive session).
Statements executed in the REPL will have read/srite access to the namespace of the program.

<hr>
\subsubsection quit
__type:__ string \n
Macro which, when invoked from the REPL, quits the REPL.
The program which invoked \ref repl will continue executing.
This is different from \ref exit because it terminates only the REPL, not the interpreter itself.

<hr>
\subsubsection ask
__type:__ Heisenberg string \n
Queries stdin (command line input) and gets characters until a newline is received.
Evaluates to a string containing those characters.

<hr>
\subsubsection exit
__type:__ Heisenberg string \n
Terminates the HIL interpreter and evaluates to an empty string.
This is different from \ref quit in that it can be invoked from anywhere (not just the REPL)
and even if it is invoked from the REPL, statements after the \ref repl invokation will not be executed
(because it terminates the whole interpreter).

<hr>
\subsubsection throw
__type:__ Heisenberg string \n
Throws an exception in the C++ implementation of HIL.
Potentially useful if the C++ code contains subsequent statements after the invokation of the HIL interpreter which you don't want to execute.

<hr>

\section inputs Input Parameters
This section lists variables that directly affect the behavior of the solver.
Some of them are preset to default values with the intent that you should override them,
and some are __not__ defined and __must__ be defined by you.

<hr>
\subsubsection n_dim
__type:__ integer \n
Number of dimensions.
Must be at least 1 and at most 3.

<hr>
\subsubsection row_size
__type:__ integer \n
__default:__ 6 \n
\ref basis_row_size "Row size" of polynomial basis.
Must be at lead 2 and at most `hexed::config::max_row_size`.

<hr>
\subsubsection init_ref_level
__type:__ integer \n
__default:__ 3 \n
Number of levels to refine the mesh before surface geometry is introduced.
May be any nonnegative integer, up to time and memory constraints.

<hr>
\subsubsection transport_model
__type:__ string \n
__default:__ `{inviscid}` \n
Specifies model to use for molecular transport coefficients (viscosity and thermal conductivity).
Accepted values:
- `{inviscid}`
- `{sutherland}`: Uses sutherland's law for air (non-constant Prandtl number)

<hr>
\subsubsection thermal_bc
__type:__ string \n
__default:__ `{heat_flux = 0.}` \n
Only applicable when \ref surface_bc = `{no_slip}`.
Specifies thermal boundary condition.
Default gives an adiabatic wall.
Accepted values:
- `{heat_flux = x}`: Prescribes the wall heat flux (out of the domain, into the wall) to be `x`.
- `{temperature = x}`: Prescribes the temperature at the wall to be `x`.
- `{internal_energy = x}`: Prescribes the internal energy at the wall to be `x`.
  For now, since you're stuck in the CPG world, this is equivalent to `{temperature = x*(heat_rat - 1)/specific_gas_air}`.
- `{emissivity = x}`: Radiative equilibrium BC where the surface emissivity is prescribed to be `x`.

<hr>
\subsubsection surface_bc
__type:__ string \n
__default:__ `{auto}` \n
Specifies surface boundary condition.
If `{auto}`, surface boundary condition will be determined automatically depending on the value of \ref transport_model.
`{inviscid}` &rarr; `{nonpenetration}` and `{sutherland}` &rarr; `{no_slip}`.
Otherwise, the name of a supported \ref boundary_conditions "Boundary condition type".

<hr>
\subsubsection temperature_offset
__type:__ float \n
__default:__ `0.` \n
Applicable when altitude is specified.
Sets the temperature offset passed to `hexed::standard_atmosphere`.

<hr>
\subsubsection attack
__type:__ float \n
__default:__ `0.` \n
Angle of attack (radian, as specified in \ref units).

<hr>
\subsubsection sideslip
__type:__ float \n
__default:__ `0.` \n
Sideslip angle (radian, as specified in \ref units).

<hr>
\subsubsection art_visc_constant
__type:__ float \n
__default:__ `-1.` \n
If set to a positive number, turns on aritificial viscosity and sets the artificial viscosity coefficient to be uniformly equal to `art_visc_constant`.

<hr>
\subsubsection art_visc_width
__type:__ float \n
__default:__ `-1.` \n
If set to a positive number, turns on aritificial viscosity with a smoothness-based coefficient
and sets the smoothness width to `art_visc_width`.

<hr>
\subsubsection fix_therm_admis
__type:__ integer \n
__default:__ \ref false \n
If \ref true, check thermodynamic admissibility (positive density, nonnegative energy, non-NaN state) after every time integration stage
and if problems are found, run as many Laplacian smearing iterations as neccessary to restore admissibility.
Results in a major robustness improvement for hypersonic cases and comes at a modest performance cost.

<hr>
\subsubsection working_dir
__type:__ string \n
__default:__ `{hexed_out/}` \n
Directory in which to write output files.
Path can be relative or absolute.
If the directory does not exist, it will be created.
Any modifications to this variable must take place before the solver is initialized.

<hr>
\subsubsection vis_freq
__type:__ integer \n
__default:__ 10000 \n
Visualization files will be written every `vis_freq` iterations.

<hr>
\subsubsection iter_width
__type:__ integer \n
__default:__ 10 \n
Visualization file names will contain iteration numbers with leading zeros added such that there are at least `iter_width` digits.

<hr>
\subsubsection print_freq
__type:__ integer \n
__default:__ 100 \n
Solver status will be printed to stdout every `print_freq` iterations.

<hr>
\subsubsection surface_refine
__type:__ string \n
__default:__ `{false}` \n
Refinement criterion for surface-geometry-based refinement sweeps.
Should be an expression that can be evaluated for each mesh element
in an environment that includes the variables assigned by `hexed::hil_properties::element()`.
If this expression evaluates to \ref true, the element will be refined.
Otherwise it will not.

<hr>
\subsubsection surface_unrefine
__type:__ string \n
__default:__ `{ref_level > init_ref_level & !is_extruded}` \n
Unrefinement criterion for surface-geometry-based refinement sweeps.
Behaves the same as \ref surface_refine except that if this expression evaluates to \ref true, the element will be unrefined
(subject to refinement level constraints).

<hr>
\subsubsection surface_max_iters
__type:__ integer \n
__default:__ 100 \n
Maximum number of surface-geometry-based refinement sweeps to run if refinement convergence is not achieved.

<hr>
\subsubsection n_smooth
__type:__ integer \n
__default:__ 30 \n
Number of mesh smoothing iterations to run after every surface-geometry-based refinement sweep.

<hr>
\subsubsection wall_spacing
__type:__ float \n
__default:__ -1. \n
If set to a positive number, anisotropic wall layers will be generated.
The ratio of the height of the first layer to the total height of the layers (which may be nonuniform) will be `wall_spacing`.

<hr>
\subsubsection wall_layers
__type:__ integer \n
__default:__ 1 \n
If anisotropic layers are generated, the first `wall_layers` layers will have thickness determined by `wall_spacing`,
and the remaining layers will exponentially increase in thickness to keep the aniso-iso transition as smooth as possible.

<hr>
\subsubsection geom_n_segments
__type:__ integer \n
__default:__ 1000 \n
Number of subdivisions to use when discretizing 2D CAD geometry with `hexed::Occt::segments`.

<hr>
\subsubsection vis_surface
__type:__ integer \n
__default:__ \ref true \n
Whether to visualize surface data when \ref visualize is invoked.

<hr>
\subsubsection vis_field
__type:__ integer \n
__default:__ \ref true \n
Whether to visualize field data when \ref visualize is invoked.

<hr>
\subsubsection vis_tecplot
__type:__ integer \n
__default:__ \ref true \n
If \ref true, write visualization files in Tecplot format (requires compilation with `use_tecplot` `ON`).

<hr>
\subsubsection vis_xdmf
__type:__ integer \n
__default:__ \ref true \n
If \ref true, write visualization files in XDMF format (requires compilation with `use_xdmf` `ON`).

<hr>
\subsubsection vis_lts_constraints
__type:__ integer \n
__default:__ \ref false \n
If \ref true, visualize the local time step constraints due to convection and diffusion, respectively.

<hr>
\subsubsection vis_field_vars
__type:__ string \n
__default:__ `state_vars + art_visc_expr` \n
\ref struct_expr "Structured expression" specifying which field variables to visualize.

<hr>
\subsubsection vis_surface_vars
__type:__ string \n
__default:__ `state_vars + visc_stress_expr + heat_flux_expr` \n
\ref struct_expr "Structured expression" specifying which surface variables to visualize.

<hr>
\subsubsection vis_n_sample
__type:__ integer \n
__default:__ 10 \n
Each element will be visualized at sample points distributed in a uniformly-spaced structured block with `vis_n_sample` points on each edge.
If you want, you can think of this as the visualization \ref basis_row_size "row size".

<hr>
\subsubsection print_vars
__type:__ string \n
__default:__ `iteration_expr + residual_expr + av_advection_residual_expr + av_diffusion_residual_expr + flow_time_expr + time_step_expr` \n
\ref struct_expr "Structured expression" specifying what quantities to print when the solver status is printed.

<hr>
\subsubsection integrand_field
__type:__ string \n
__default:__ `{}` \n
\ref struct_expr "Structured expression" specifying what quantities integrate when field integrals are computed.

<hr>
\subsubsection integrand_surface
__type:__ string \n
__default:__ `{}` \n
\ref struct_expr "Structured expression" specifying what quantities integrate when surface integrals are computed.

<hr>
\subsubsection max_angle
__type:__ float \n
__default:__ `10*degree`
Maximum allowable angle between adjacent panels when discretizing 3D CAD geometry with `hexed::Occt::triangles`.

<hr>
\subsubsection max_deflection
__type:__ float \n
__default:__ \ref huge \n
Maximum allowable linear deflection of surface panels when discretizing 3D CAD geometry with `hexed::Occt::triangles` (dimensional).

<hr>
\subsubsection mesh_extreme_eps
__type:__ float \n
__default:__ `1e-6` \n
Comparison tolerance to use when deterimining whether points are inside or outside mesh extremes.
Relative to domain size.

\section outputs Output Parameters
The following variables are defined and/or updated by the solver in order to provide information to you.
Some are Heisenberg variables and some are writable,
but you should not write to them even if you are technically able to.

*/
