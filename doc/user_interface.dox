/*! \page user_interface User Interface
Hexed is designed to be used in two ways.
You can use the C++ library \ref hexed to integrate it directly into your own code.
However, for the likely case that you don't want to program in C++, Hexed also supports a command line interface.
To distinguish it from the library, the command to _execute Hexed_ is `hexecute` (apologies for my terrible sense of humor).
Without any arguments, `hexecute` will begin an interactive session where you can enter commands in the \ref hil.
Alternatively, you can provide a single argument which is the name of a file containing \ref hil commands.
It will then execute these commands as though you had entered them in an interactive session.

\section hil Hexed Interface Language
__The Hexed Interface Language (HIL) is a simple scripting language designed for interfacing with Hexed.__
Creating a whole scripting language just to interface with a CFD solver may seem excessive,
but in fact it addresses some of my greatest frustrations with computational analysis.
Most CFD solvers behave roughly like a washing machine: you adjust a few numbers, hit "go", and hope it gives you what you want.
Usually it does, but occasionally it starts spiraling out of control and you have to manually intervene.
This design is generally adequate to solve easy problems, but more challenging cases often call for more granular control.
For example, suppose you have a hypersonic case where the only way you manage to avoid a crash is by starting with a CFL number of 0.001,
exponentially increasing it by factors of 2 every 1000 time steps until it reaches 10,
switching from local to global time stepping when the residual drops below \f$ 10^{-5} \f$,
and terminating the simulation when the residual drops below $10^{-8}$ or when the CPU time exceeds 3 days, whichever comes first.
Suppose also you want to visualize the flowfield every 100 time steps in the beginning of the simulation to understand the initial transients,
but only every 10000 iterations near the end to save disk space,
and you want to update your restart file every 1000 iterations but save a _separate_ restart file when you switch to global time stepping
so that you don't lose your progress if the global time parameters turn out to be flawed.
Because there is an infinite variety of convoluted pathways a simulation might take,
many solvers implement a multitude of ridiculously specific input parameters and/or require you to manually babysit a simulation
and tweak parameters on the fly.
What we need to recognize is that the real purpose of a CFD solver is to do things that you can't do --
in particular, reading geometry/mesh files, running iterations, and writing visualization files.
To address general use cases, the solver should expose these functions directly
and give you full control over the high-level iteration process.
Of course, there should be builtin defaults to let you run basic cases without any significant programming,
but you should be able to modify the iteration logic without dealing with the solver's source code.

Initially, I thought the best way to achieve this ideal would be to implement bindings to Hexed in an existing scripting language (namely Python).
However, this turned out to have several problems:
- It required much more boilerplate code than I would have liked.
- It made it much harder to debug memory errors, since binding systems tend to introduce memeory leaks and interfere with memory checking tools.
- It doesn't provide an easy way to implement user-defined callback functions (e.g. mesh refinement criteria, integral error metrics)
  that execute in parallel and at C++ speed.

Technically, most CFD solvers _already_ implement a custom scripting language, since input parameters are provided via a text file with custom syntax.
Hexed simply makes its input language Turing-complete with the ability to parse operators (`=`, `+`, `*`, `&`, etc.)
and basic control flow.
The goal of the HIL is to be as simple as possible (both to implement and to learn) while providing all the functionality that you strictly need.

\subsection literals Types and Literals
Values in HIL have one of 3 types:
- Integer (32-bit signed)
- [Float](https://en.wikipedia.org/wiki/Floating-point_arithmetic) (64-bit)
- String

Note that there is not boolean type.
The integers 0 and 1 are used to represent logical true and false.

You can create one of these values with a _literal_ (as opposed to an _expression_ or a variable evaluation).
Integer and float literals are the same as in any language.
Strings are enclosed in `{}` instead of quotes
to avoid exponential pileup of escape sequences in nested \ref Macros.
Matched pars of `{}` in strings are included literally.
To include an unmatched `{` or `}` in a string, you can escape it with a `\`.
To include an actual `\`, you must escape it with a second `\`.
Strings can include newlines.

Examples:
- `5` and `012` are integer literals.
- `1.0`, `4.`, `0.25`, `.01`, and `5e-4` are float literals.
- `{some chars}` is a string containing the characters `some chars`.
-
~~~{.html}
{{string} \\ with \} special
chars}
~~~
is a string containing the characters
~~~{.html}
{string} \ with } special
chars
~~~

\subsection operators Operators and Expressions
HIL supports a variety of _operators_, which in this context means
things that take in input values (operands) and produce an output.
Some of these operators are implemented as functions in other languages, but HIL has no concept of a function.
So-called unary operators are placed directly before their operand and binary operators are placed between their operands.
The operators are listed below with their precedence.
Operators with a lower precedence number are evaluated before those with a higher precedence number,
and operators with the same precedence number are evaluated left-to-right.

Syntactic category | Precedence | Operator name | Operand types            | Behavior
-------------------|------------|---------------|--------------------------|---------
unary              | 0          | `-`           | integer, float         | inverts sign
^                  | ^          | `!`           | integer                | logical _not_ (`1`, if operand is zero, else `0`)
^                  | ^          | `#`           | string                 | evaluates size of string
^                  | ^          | `sqrt`        | integer, float         | square root (as float)
^                  | ^          | `read`        | string                 | operand is a file path; returns the file contents as a string
^                  | ^          | `print`       | any                    | prints to stdout (without adding a newline)
^                  | ^          | `println`     | any                    | prints to stdout and then prints a newline (like the Python `print` function)
^                  | ^          | `shell`       | string                 | executes the operand in the system shell and returns the return code (integer)
binary             | 1          | `^`           | integer, float         | raises left operand to power of right operand
^                  | ^          | `#`           | string-integer         | returns the _i_ th character of the left operand as a string where _i_ is the right operand
^                  | 2          | `%`           | integer                | modulo
^                  | ^          | `/`           | integer, float         | division
^                  | ^          | `*`           | integer, float         | multiplication
^                  | 3          | `-`           | integer, float         | subtraction
^                  | ^          | `+`           | integer, float, string | For numeric-numeric, addition. For strings, concatenation. If only one argument is a string, the other is converted to a string representation.
^                  | 4          | `==`          | any                    | Evaluates to integer `1` if operands are equal, otherwise `0`. Operands must both be strings or neither.
^                  | ^          | `!=`          | any                    | Evaluates to integer `1` if operands are inequal, otherwise `0` (including if both operands are NaN). Operands must both be strings or neither.
^                  | ^          | `>=`          | integer, float         | `1` if left operand is greater than or equal to right, else `0`
^                  | ^          | `<=`          | integer, float         | `1` if left operand is less than or equal to right, else `0`
^                  | ^          | `>`           | integer, float         | `1` if left operand is greater than right, else `0`
^                  | ^          | `<`           | integer, float         | `1` if left operand is less than right, else `0`
^                  | 5          | `&`           | integer, float         | logical _and_ (`0` if either operand is `0`, else `1`)
^                  | ^          | \|            | integer, float         | logical _or_ (`0` if both operands are `0`, else `1`)

__Notes:__
- If an operator can be interpreted as unary or binary, it is interpreted as binary.
- If a binary operator accepts both integer and float operands, then the result will be an integer if both operands are integers and a float otherwise.
- The left operand of binary `#` must be a string and the right must be an integer.

The result of applying an operator (and any nested operators) is called an _expression_.
`()` can be used to override the precedence order and evaluate the enclosed expression(s) first.

\subsection Macros
*/
