<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hexed: hexed::Accessible_mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hexed
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhexed_1_1Accessible__mesh.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classhexed_1_1Accessible__mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hexed::Accessible_mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A mesh that supports access to the actual elements with the numerical data they contain.  
 <a href="classhexed_1_1Accessible__mesh.html#details">More...</a></p>

<p><code>#include &lt;Accessible_mesh.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hexed::Accessible_mesh:</div>
<div class="dyncontent">
<div class="center"><img src="classhexed_1_1Accessible__mesh__inherit__graph.png" border="0" usemap="#ahexed_1_1Accessible__mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="ahexed_1_1Accessible__mesh_inherit__map" id="ahexed_1_1Accessible__mesh_inherit__map">
<area shape="rect" title="A mesh that supports access to the actual elements with the numerical data they contain." alt="" coords="5,80,187,107"/>
<area shape="rect" href="classhexed_1_1Mesh.html" title=" " alt="" coords="44,5,148,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for hexed::Accessible_mesh:</div>
<div class="dyncontent">
<div class="center"><img src="classhexed_1_1Accessible__mesh__coll__graph.png" border="0" usemap="#ahexed_1_1Accessible__mesh_coll__map" alt="Collaboration graph"/></div>
<map name="ahexed_1_1Accessible__mesh_coll__map" id="ahexed_1_1Accessible__mesh_coll__map">
<area shape="rect" title="A mesh that supports access to the actual elements with the numerical data they contain." alt="" coords="5,80,187,107"/>
<area shape="rect" href="classhexed_1_1Mesh.html" title=" " alt="" coords="44,5,148,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1ab0f54ca7133f206e142033ef03af5e"><td class="memItemLeft" align="right" valign="top"><a id="a1ab0f54ca7133f206e142033ef03af5e"></a>
typedef <a class="el" href="classhexed_1_1Vector__view.html">Vector_view</a>&lt; <a class="el" href="classhexed_1_1Vertex.html">Vertex</a> &amp;, <a class="el" href="classhexed_1_1Vertex_1_1Non__transferable__ptr.html">Vertex::Non_transferable_ptr</a>, &amp;ptr_convert&lt; <a class="el" href="classhexed_1_1Vertex.html">Vertex</a> &amp;, <a class="el" href="classhexed_1_1Vertex_1_1Non__transferable__ptr.html">Vertex::Non_transferable_ptr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a1ab0f54ca7133f206e142033ef03af5e">vertex_view</a></td></tr>
<tr class="memdesc:a1ab0f54ca7133f206e142033ef03af5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef for the <a class="el" href="classhexed_1_1Vector__view.html" title="Provides a view of an existing container (e.g., std::vector) as a Sequence.">Vector_view</a> used to access <a class="el" href="classhexed_1_1Vertex.html" title="Represents a vertex in a deformed grid.">Vertex</a> objects <br /></td></tr>
<tr class="separator:a1ab0f54ca7133f206e142033ef03af5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac8dcff19a5d2d6b368022c1e345726c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#ac8dcff19a5d2d6b368022c1e345726c7">Accessible_mesh</a> (<a class="el" href="classhexed_1_1Storage__params.html">Storage_params</a> params, double <a class="el" href="classhexed_1_1Accessible__mesh.html#aae6e7b4d0bb2d83c76310d3d7d46cd75">root_size</a>)</td></tr>
<tr class="separator:ac8dcff19a5d2d6b368022c1e345726c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d554232b4e98166c8a2b4f41091c60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a33d554232b4e98166c8a2b4f41091c60">Accessible_mesh</a> (std::string file_name, std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt; extremal_bcs, <a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> *=nullptr, <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *surface_bc=nullptr)</td></tr>
<tr class="memdesc:a33d554232b4e98166c8a2b4f41091c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads mesh from a file created by <code>Mesh::write</code>.  <a href="classhexed_1_1Accessible__mesh.html#a33d554232b4e98166c8a2b4f41091c60">More...</a><br /></td></tr>
<tr class="separator:a33d554232b4e98166c8a2b4f41091c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9467a193c906de5f428848aaacc0d3e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a9467a193c906de5f428848aaacc0d3e5">Accessible_mesh</a> (std::string file_name, std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt;, std::vector&lt; <a class="el" href="classhexed_1_1Mesh__bc.html">Mesh_bc</a> * &gt;)</td></tr>
<tr class="memdesc:a9467a193c906de5f428848aaacc0d3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads mesh from a file created by <code>Mesh::write</code>.  <a href="classhexed_1_1Accessible__mesh.html#a9467a193c906de5f428848aaacc0d3e5">More...</a><br /></td></tr>
<tr class="separator:a9467a193c906de5f428848aaacc0d3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6e7b4d0bb2d83c76310d3d7d46cd75"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#aae6e7b4d0bb2d83c76310d3d7d46cd75">root_size</a> () override</td></tr>
<tr class="separator:aae6e7b4d0bb2d83c76310d3d7d46cd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a64e099967dbdf237ea399a5365812c"><td class="memItemLeft" align="right" valign="top"><a id="a4a64e099967dbdf237ea399a5365812c"></a>
<a class="el" href="classhexed_1_1Storage__params.html">Storage_params</a>&#160;</td><td class="memItemRight" valign="bottom"><b>storage_params</b> ()</td></tr>
<tr class="separator:a4a64e099967dbdf237ea399a5365812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ecd0dc541b4ab70332bfb5e01a3e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1View__by__type.html">View_by_type</a>&lt; <a class="el" href="classhexed_1_1Element.html">Element</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a75ecd0dc541b4ab70332bfb5e01a3e8e">cartesian</a> ()</td></tr>
<tr class="separator:a75ecd0dc541b4ab70332bfb5e01a3e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc7bbc01877090be05fdff0be946b33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1View__by__type.html">View_by_type</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a4fc7bbc01877090be05fdff0be946b33">deformed</a> ()</td></tr>
<tr class="separator:a4fc7bbc01877090be05fdff0be946b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3effbd55bbf2c058f389d3ac8eb64fa9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a3effbd55bbf2c058f389d3ac8eb64fa9">add_element</a> (int ref_level, bool is_deformed, std::vector&lt; int &gt; position) override</td></tr>
<tr class="separator:a3effbd55bbf2c058f389d3ac8eb64fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6390156bbfbca027484f61e76faeb61e"><td class="memItemLeft" align="right" valign="top"><a id="a6390156bbfbca027484f61e76faeb61e"></a>
<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a6390156bbfbca027484f61e76faeb61e">element</a> (int ref_level, bool is_deformed, int serial_n)</td></tr>
<tr class="memdesc:a6390156bbfbca027484f61e76faeb61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element. If the parameters to not describe an existing element, throw an exception. <br /></td></tr>
<tr class="separator:a6390156bbfbca027484f61e76faeb61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7d0ec4b4cc6afb921f37a6e7da8724"><td class="memItemLeft" align="right" valign="top"><a id="adf7d0ec4b4cc6afb921f37a6e7da8724"></a>
<a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt; <a class="el" href="classhexed_1_1Element.html">Element</a> &amp; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#adf7d0ec4b4cc6afb921f37a6e7da8724">elements</a> ()</td></tr>
<tr class="memdesc:adf7d0ec4b4cc6afb921f37a6e7da8724"><td class="mdescLeft">&#160;</td><td class="mdescRight">access all elements, both Cartesian and deformed <br /></td></tr>
<tr class="separator:adf7d0ec4b4cc6afb921f37a6e7da8724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aceabd0f4df9e018d6b940bdddf8550"><td class="memItemLeft" align="right" valign="top"><a id="a6aceabd0f4df9e018d6b940bdddf8550"></a>
<a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt; <a class="el" href="classhexed_1_1Kernel__element.html">Kernel_element</a> &amp; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>kernel_elements</b> ()</td></tr>
<tr class="separator:a6aceabd0f4df9e018d6b940bdddf8550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85439beaa6ec6be4644fe16eff7c31a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a85439beaa6ec6be4644fe16eff7c31a9">connect_cartesian</a> (int ref_level, std::array&lt; int, 2 &gt; serial_n, <a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Element.html">Element</a> &gt; dir, std::array&lt; bool, 2 &gt; is_deformed={false, false}) override</td></tr>
<tr class="separator:a85439beaa6ec6be4644fe16eff7c31a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad943521772329fef40d8e0611204e4b4"><td class="memItemLeft" align="right" valign="top"><a id="ad943521772329fef40d8e0611204e4b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#ad943521772329fef40d8e0611204e4b4">connect_deformed</a> (int ref_level, std::array&lt; int, 2 &gt; serial_n, <a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt; direction) override</td></tr>
<tr class="memdesc:ad943521772329fef40d8e0611204e4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that two elements are connected via a deformed face. Requires both elements to be deformed. <br /></td></tr>
<tr class="separator:ad943521772329fef40d8e0611204e4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4a24c118927a27e206ed8cbc30ec4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a7e4a24c118927a27e206ed8cbc30ec4d">connect_hanging</a> (int coarse_ref_level, int coarse_serial, std::vector&lt; int &gt; fine_serial, <a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt;, bool coarse_deformed=false, std::vector&lt; bool &gt; fine_deformed={false, false, false, false}, std::array&lt; bool, 2 &gt; stretch={false, false}) override</td></tr>
<tr class="separator:a7e4a24c118927a27e206ed8cbc30ec4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f7e7d24c869c2a908aff7a6bfdb15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt; <a class="el" href="classhexed_1_1Element__connection.html">Element_connection</a> &amp; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a218f7e7d24c869c2a908aff7a6bfdb15">element_connections</a> ()</td></tr>
<tr class="separator:a218f7e7d24c869c2a908aff7a6bfdb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea3d96d4fd9dcb85e205f005c58bcdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a6ea3d96d4fd9dcb85e205f005c58bcdd">add_boundary_condition</a> (<a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *, <a class="el" href="classhexed_1_1Mesh__bc.html">Mesh_bc</a> *) override</td></tr>
<tr class="separator:a6ea3d96d4fd9dcb85e205f005c58bcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc87bb841d80af3862fac169703b12b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#afc87bb841d80af3862fac169703b12b0">connect_boundary</a> (int ref_level, bool is_deformed, int element_serial_n, int i_dim, int face_sign, int bc_serial_n) override</td></tr>
<tr class="separator:afc87bb841d80af3862fac169703b12b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80ead80a6bd76fa30b95e5e55152f93"><td class="memItemLeft" align="right" valign="top"><a id="ad80ead80a6bd76fa30b95e5e55152f93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#ad80ead80a6bd76fa30b95e5e55152f93">disconnect_boundary</a> (int bc_sn) override</td></tr>
<tr class="memdesc:ad80ead80a6bd76fa30b95e5e55152f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete all boundary connections involving a certain boundary condition <br /></td></tr>
<tr class="separator:ad80ead80a6bd76fa30b95e5e55152f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf033c481081295a52ba9fc355b547c"><td class="memItemLeft" align="right" valign="top"><a id="a9cf033c481081295a52ba9fc355b547c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a9cf033c481081295a52ba9fc355b547c">cleanup</a> () override</td></tr>
<tr class="memdesc:a9cf033c481081295a52ba9fc355b547c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some work that has to happen after you manually add elements and/or connections. <br /></td></tr>
<tr class="separator:a9cf033c481081295a52ba9fc355b547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b061d00acf3595b6c1ba9aaf257f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a35b061d00acf3595b6c1ba9aaf257f36">add_tree</a> (std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt; extremal_bcs, <a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt; origin=<a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;::Zero(3)) override</td></tr>
<tr class="memdesc:a35b061d00acf3595b6c1ba9aaf257f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes meshing with bin/quad/<a href="https://en.wikipedia.org/wiki/Octree">octree</a> topology.  <a href="classhexed_1_1Accessible__mesh.html#a35b061d00acf3595b6c1ba9aaf257f36">More...</a><br /></td></tr>
<tr class="separator:a35b061d00acf3595b6c1ba9aaf257f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbb6de6ed43d840d5fc0e742a94997c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a8bbb6de6ed43d840d5fc0e742a94997c">set_surface</a> (<a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> *geometry, <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *surface_bc, <a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#ga8554c6170729f01c7572574837ecf618">Eigen::VectorXd</a> flood_fill_start=<a class="elRef" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#a422ddeef58bedc7bddb1d4357688d761">Eigen::VectorXd::Zero</a>(3)) override</td></tr>
<tr class="memdesc:a8bbb6de6ed43d840d5fc0e742a94997c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the surface geometry to be meshed as a boundary.  <a href="classhexed_1_1Accessible__mesh.html#a8bbb6de6ed43d840d5fc0e742a94997c">More...</a><br /></td></tr>
<tr class="separator:a8bbb6de6ed43d840d5fc0e742a94997c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd23370c8d348e57bc09cb97153ca8c"><td class="memItemLeft" align="right" valign="top"><a id="a4fd23370c8d348e57bc09cb97153ca8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_unref_locks</b> (std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt; lock_if=<a class="el" href="namespacehexed_1_1criteria.html#acf972478516de191c744fb288460c0f4">criteria::never</a>) override</td></tr>
<tr class="separator:a4fd23370c8d348e57bc09cb97153ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0468319f657ad8aa9732c42eead1091"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#af0468319f657ad8aa9732c42eead1091">update</a> (std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt; refine_criterion=<a class="el" href="namespacehexed_1_1criteria.html#a86ceaaf056ff2cec5d7ebb2c32f3d4cd">criteria::always</a>, std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt; unrefine_criterion=<a class="el" href="namespacehexed_1_1criteria.html#acf972478516de191c744fb288460c0f4">criteria::never</a>) override</td></tr>
<tr class="memdesc:af0468319f657ad8aa9732c42eead1091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates tree mesh based on user-supplied (un)refinement criteria.  <a href="classhexed_1_1Accessible__mesh.html#af0468319f657ad8aa9732c42eead1091">More...</a><br /></td></tr>
<tr class="separator:af0468319f657ad8aa9732c42eead1091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113f9237fe66ca1798d4cd265616cc3c"><td class="memItemLeft" align="right" valign="top"><a id="a113f9237fe66ca1798d4cd265616cc3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a113f9237fe66ca1798d4cd265616cc3c">set_all_smooth</a> () override</td></tr>
<tr class="memdesc:a113f9237fe66ca1798d4cd265616cc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets <code>need_smooth</code> to <code>true</code> for all vertices to perform global relaxation (only effective until the next <code><a class="el" href="classhexed_1_1Accessible__mesh.html#af0468319f657ad8aa9732c42eead1091" title="Updates tree mesh based on user-supplied (un)refinement criteria.">update()</a></code> cycle) <br /></td></tr>
<tr class="separator:a113f9237fe66ca1798d4cd265616cc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe952d543dc73dfe1ae683428abf4fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a4fe952d543dc73dfe1ae683428abf4fd">relax</a> (double factor=0.9) override</td></tr>
<tr class="memdesc:a4fe952d543dc73dfe1ae683428abf4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relax the vertices to improve mesh quality.  <a href="classhexed_1_1Accessible__mesh.html#a4fe952d543dc73dfe1ae683428abf4fd">More...</a><br /></td></tr>
<tr class="separator:a4fe952d543dc73dfe1ae683428abf4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b183489199fb7c8b402a835f42bfdc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a6b183489199fb7c8b402a835f42bfdc5">surface_bc_sn</a> () override</td></tr>
<tr class="separator:a6b183489199fb7c8b402a835f42bfdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47090445e36a9abc72c46c6db752b71b"><td class="memItemLeft" align="right" valign="top"><a id="a47090445e36a9abc72c46c6db752b71b"></a>
<a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>surface_geometry</b> ()</td></tr>
<tr class="separator:a47090445e36a9abc72c46c6db752b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b81a04a8f528c84d9f069b982c97395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Vector__view.html">Vector_view</a>&lt; <a class="el" href="classhexed_1_1Boundary__condition.html">Boundary_condition</a> &amp;, <a class="el" href="classhexed_1_1Boundary__condition.html">Boundary_condition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a3b81a04a8f528c84d9f069b982c97395">boundary_conditions</a> ()</td></tr>
<tr class="separator:a3b81a04a8f528c84d9f069b982c97395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af51f2c20b12e8303f9019e061dd318"><td class="memItemLeft" align="right" valign="top"><a id="a9af51f2c20b12e8303f9019e061dd318"></a>
<a class="el" href="classhexed_1_1Boundary__condition.html">Boundary_condition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a9af51f2c20b12e8303f9019e061dd318">boundary_condition</a> (int bc_sn)</td></tr>
<tr class="memdesc:a9af51f2c20b12e8303f9019e061dd318"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a boundary condition owned by this mesh by its serial number <br /></td></tr>
<tr class="separator:a9af51f2c20b12e8303f9019e061dd318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e579c747de296caf53e9bcb1368473e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt; <a class="el" href="classhexed_1_1Boundary__connection.html">Boundary_connection</a> &amp; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a4e579c747de296caf53e9bcb1368473e">boundary_connections</a> ()</td></tr>
<tr class="separator:a4e579c747de296caf53e9bcb1368473e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65899ec69850aa30f233615c28e642dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt; <a class="el" href="classhexed_1_1Refined__face.html">Refined_face</a> &amp; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a65899ec69850aa30f233615c28e642dd">refined_faces</a> ()</td></tr>
<tr class="separator:a65899ec69850aa30f233615c28e642dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db83bed2889b068881e50453f54d6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt; <a class="el" href="classhexed_1_1Hanging__vertex__matcher.html">Hanging_vertex_matcher</a> &amp; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a4db83bed2889b068881e50453f54d6e8">hanging_vertex_matchers</a> ()</td></tr>
<tr class="separator:a4db83bed2889b068881e50453f54d6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac503d1e3749acd1e0cf81a7bd88f16dc"><td class="memItemLeft" align="right" valign="top"><a id="ac503d1e3749acd1e0cf81a7bd88f16dc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#ac503d1e3749acd1e0cf81a7bd88f16dc">n_elements</a> () override</td></tr>
<tr class="memdesc:ac503d1e3749acd1e0cf81a7bd88f16dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elements currently in the mesh <br /></td></tr>
<tr class="separator:ac503d1e3749acd1e0cf81a7bd88f16dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3180165c91e00a1f3b193dab13a3651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Mesh_1_1Connection__validity.html">Connection_validity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#ac3180165c91e00a1f3b193dab13a3651">valid</a> () override</td></tr>
<tr class="memdesc:ac3180165c91e00a1f3b193dab13a3651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>Connection_validity</code> object describing whether the mesh connectivity is valid.  <a href="classhexed_1_1Accessible__mesh.html#ac3180165c91e00a1f3b193dab13a3651">More...</a><br /></td></tr>
<tr class="separator:ac3180165c91e00a1f3b193dab13a3651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52e0ad3fee57fd7523d551c0d5cd4ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Accessible__mesh.html#a1ab0f54ca7133f206e142033ef03af5e">vertex_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#ad52e0ad3fee57fd7523d551c0d5cd4ff">vertices</a> ()</td></tr>
<tr class="separator:ad52e0ad3fee57fd7523d551c0d5cd4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472153bc396bbbc2ae6b50818dc87615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a472153bc396bbbc2ae6b50818dc87615">extrude</a> (bool collapse=false, double offset=0, bool force=false) override</td></tr>
<tr class="separator:a472153bc396bbbc2ae6b50818dc87615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2cf35e2e029c9a2918a5dec6e7ae28"><td class="memItemLeft" align="right" valign="top"><a id="a9f2cf35e2e029c9a2918a5dec6e7ae28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#a9f2cf35e2e029c9a2918a5dec6e7ae28">connect_rest</a> (int bc_sn) override</td></tr>
<tr class="memdesc:a9f2cf35e2e029c9a2918a5dec6e7ae28"><td class="mdescLeft">&#160;</td><td class="mdescRight">connects all yet-unconnected faces to a boundary condition specified by serial number <br /></td></tr>
<tr class="separator:a9f2cf35e2e029c9a2918a5dec6e7ae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3611a801b0fe441cd8a9e2494aae00"><td class="memItemLeft" align="right" valign="top"><a id="afe3611a801b0fe441cd8a9e2494aae00"></a>
std::vector&lt; <a class="el" href="structhexed_1_1Mesh_1_1elem__handle.html">elem_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#afe3611a801b0fe441cd8a9e2494aae00">elem_handles</a> () override</td></tr>
<tr class="memdesc:afe3611a801b0fe441cd8a9e2494aae00"><td class="mdescLeft">&#160;</td><td class="mdescRight">get handles for all elements currently in the mesh, in no particular order (mostly for testing/debugging) <br /></td></tr>
<tr class="separator:afe3611a801b0fe441cd8a9e2494aae00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0061e8feb6cc2a496fce6edd6c3889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Vector__view.html">Vector_view</a>&lt; <a class="el" href="classhexed_1_1Element__connection.html">Element_connection</a> &amp;, <a class="el" href="classhexed_1_1Element__face__connection.html">Element_face_connection</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt; *, ptr_convert&lt; <a class="el" href="classhexed_1_1Element__connection.html">Element_connection</a> &amp;, <a class="el" href="classhexed_1_1Element__face__connection.html">Element_face_connection</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt; * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#acd0061e8feb6cc2a496fce6edd6c3889">extruded_connections</a> ()</td></tr>
<tr class="separator:acd0061e8feb6cc2a496fce6edd6c3889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476d557c89322ab03fd1d2005c3a9404"><td class="memItemLeft" align="right" valign="top"><a id="a476d557c89322ab03fd1d2005c3a9404"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (std::string file_name) override</td></tr>
<tr class="separator:a476d557c89322ab03fd1d2005c3a9404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34404cb79aa9ee7dc0b91f6586b087d"><td class="memItemLeft" align="right" valign="top"><a id="af34404cb79aa9ee7dc0b91f6586b087d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#af34404cb79aa9ee7dc0b91f6586b087d">export_polymesh</a> (std::string dir_name) override</td></tr>
<tr class="memdesc:af34404cb79aa9ee7dc0b91f6586b087d"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the mesh in the OpenFOAM PolyMesh format <br /></td></tr>
<tr class="separator:af34404cb79aa9ee7dc0b91f6586b087d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4f8311e92cf8af972ac8e2bd1e8dff"><td class="memItemLeft" align="right" valign="top"><a id="a3b4f8311e92cf8af972ac8e2bd1e8dff"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3b4f8311e92cf8af972ac8e2bd1e8dff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Mesh__by__type.html">Mesh_by_type</a>&lt; <a class="el" href="classhexed_1_1Element.html">Element</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mbt</b> ()</td></tr>
<tr class="separator:a3b4f8311e92cf8af972ac8e2bd1e8dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhexed_1_1Mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhexed_1_1Mesh')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhexed_1_1Mesh.html">hexed::Mesh</a></td></tr>
<tr class="memitem:a125f26f5c68c35eb6ed8bb22a3431741 inherit pub_methods_classhexed_1_1Mesh"><td class="memItemLeft" align="right" valign="top"><a id="a125f26f5c68c35eb6ed8bb22a3431741"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a125f26f5c68c35eb6ed8bb22a3431741">extrude</a> (<a class="el" href="classhexed_1_1Layer__sequence.html">Layer_sequence</a> layers)</td></tr>
<tr class="memdesc:a125f26f5c68c35eb6ed8bb22a3431741 inherit pub_methods_classhexed_1_1Mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a125f26f5c68c35eb6ed8bb22a3431741 inherit pub_methods_classhexed_1_1Mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af5f1a31a672de8ae002f4f4f279f094a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Accessible__mesh.html#af5f1a31a672de8ae002f4f4f279f094a">buffer_dist</a></td></tr>
<tr class="memdesc:af5f1a31a672de8ae002f4f4f279f094a"><td class="mdescLeft">&#160;</td><td class="mdescRight">how far must the center of an element be from the geometry relative to the nominal size  <a href="classhexed_1_1Accessible__mesh.html#af5f1a31a672de8ae002f4f4f279f094a">More...</a><br /></td></tr>
<tr class="separator:af5f1a31a672de8ae002f4f4f279f094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8f54fd3eb4b5083167473dcf0021d26e"><td class="memItemLeft" align="right" valign="top"><a id="a8f54fd3eb4b5083167473dcf0021d26e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset_verts</b> () override</td></tr>
<tr class="separator:a8f54fd3eb4b5083167473dcf0021d26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d19c815847ab1d9fa815f09f889f17"><td class="memItemLeft" align="right" valign="top"><a id="ad8d19c815847ab1d9fa815f09f889f17"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>restore_verts</b> () override</td></tr>
<tr class="separator:ad8d19c815847ab1d9fa815f09f889f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A mesh that supports access to the actual elements with the numerical data they contain. </p>
<p>This level of access is required by the numerical scheme but should be hidden from the library user, who should not be concerned with numerical details. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac8dcff19a5d2d6b368022c1e345726c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dcff19a5d2d6b368022c1e345726c7">&#9670;&nbsp;</a></span>Accessible_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hexed::Accessible_mesh::Accessible_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Storage__params.html">Storage_params</a>&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>root_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>parameters specifying what data is stored in each <a class="el" href="classhexed_1_1Element.html" title="Stores data associated with one mesh element.">Element</a> (row size, number of dimensions, etc.) </td></tr>
    <tr><td class="paramname">root_size</td><td>defines the <a class="el" href="classhexed_1_1Accessible__mesh.html#aae6e7b4d0bb2d83c76310d3d7d46cd75">root_size</a> of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33d554232b4e98166c8a2b4f41091c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d554232b4e98166c8a2b4f41091c60">&#9670;&nbsp;</a></span>Accessible_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hexed::Accessible_mesh::Accessible_mesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt;&#160;</td>
          <td class="paramname"><em>extremal_bcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> *&#160;</td>
          <td class="paramname"><em>geometry</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *&#160;</td>
          <td class="paramname"><em>surface_bc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads mesh from a file created by <code>Mesh::write</code>. </p>
<p>Acquires ownership of boundary condition pointers. This variant is only for tree meshing. The surface boundary condition and geometry arguments must be specified iff the original mesh had a surface geometry (else exception). </p>

</div>
</div>
<a id="a9467a193c906de5f428848aaacc0d3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9467a193c906de5f428848aaacc0d3e5">&#9670;&nbsp;</a></span>Accessible_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hexed::Accessible_mesh::Accessible_mesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt;&#160;</td>
          <td class="paramname"><em>flow_bcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhexed_1_1Mesh__bc.html">Mesh_bc</a> * &gt;&#160;</td>
          <td class="paramname"><em>mesh_bcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads mesh from a file created by <code>Mesh::write</code>. </p>
<p>Acquires ownership of boundary condition pointers. This variant is not for tree meshing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ea3d96d4fd9dcb85e205f005c58bcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea3d96d4fd9dcb85e205f005c58bcdd">&#9670;&nbsp;</a></span>add_boundary_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hexed::Accessible_mesh::add_boundary_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *&#160;</td>
          <td class="paramname"><em>flow_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Mesh__bc.html">Mesh_bc</a> *&#160;</td>
          <td class="paramname"><em>mesh_bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquires owenership of <code>*flow_bc</code> and <code>*mesh_bc</code> and constructs a <code><a class="el" href="classhexed_1_1Boundary__condition.html">Boundary_condition</a></code> from them. Returns a serial number which uniquely identifies the new boundary condition among this <code><a class="el" href="classhexed_1_1Mesh.html">Mesh</a></code>'s boundary conditions. It is recommended to use this with <code>new</code>, like the constructor for <code>std::unique_ptr</code>. </p>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#a26aaf2fbbc6d8faa4ac4d494a72a0c53">hexed::Mesh</a>.</p>

</div>
</div>
<a id="a3effbd55bbf2c058f389d3ac8eb64fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3effbd55bbf2c058f389d3ac8eb64fa9">&#9670;&nbsp;</a></span>add_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hexed::Accessible_mesh::add_element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_deformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an element at specified nominal position and serial number which uniquely identifies it among elements of this mesh with the same refinement level and deformedness. </p>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#a8fd53d5f29f47e9a826f977324cea4a6">hexed::Mesh</a>.</p>

</div>
</div>
<a id="a35b061d00acf3595b6c1ba9aaf257f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b061d00acf3595b6c1ba9aaf257f36">&#9670;&nbsp;</a></span>add_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Accessible_mesh::add_tree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt;&#160;</td>
          <td class="paramname"><em>extremal_bcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;&#160;</td>
          <td class="paramname"><em>origin</em> = <code><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;::Zero(3)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes meshing with bin/quad/<a href="https://en.wikipedia.org/wiki/Octree">octree</a> topology. </p>
<p>Creates a tree initialized with one element with ref level 0. Technically, free-form elements can also be created in the same mesh, but they will not be connected to the tree. Only one tree can be created. Connections and boundary conditions are set automatically for tree elements, so tree meshes should always automatically be valid unless you explicitly invalidate it with <code><a class="el" href="classhexed_1_1Mesh.html#a6777399f709f4e04937aad4d0812dbd0" title="delete all boundary connections involving a certain boundary condition">Mesh::disconnect_boundary</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extremal_bcs</td><td>Boundary conditions to apply to elements with exposed faces at the extremal boundaries of the tree. Takes ownership of objects that the vector entries point to. It must contain exactly <code>2*n_dim</code> entries. E.g. <code>extremal_bcs[0]</code> is the boundary condition to apply to the minimum \(x_0\) face, <code>extremal_bcs[1]</code> is the BC for the maximum \(x_0\) face, <code>extremal_bcs[2]</code> is for minimum \(x_1\). </td></tr>
    <tr><td class="paramname">origin</td><td>The minimal corner of the tree root will be located at <code>origin</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#a3dcaa709d3c08d62e01b2015b9ce071b">hexed::Mesh</a>.</p>

</div>
</div>
<a id="a3b81a04a8f528c84d9f069b982c97395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b81a04a8f528c84d9f069b982c97395">&#9670;&nbsp;</a></span>boundary_conditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Vector__view.html">Vector_view</a>&lt;<a class="el" href="classhexed_1_1Boundary__condition.html">Boundary_condition</a>&amp;, <a class="el" href="classhexed_1_1Boundary__condition.html">Boundary_condition</a>&gt; hexed::Accessible_mesh::boundary_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a view of all Bounday_condition objects owned by this mesh </dd></dl>

</div>
</div>
<a id="a4e579c747de296caf53e9bcb1368473e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e579c747de296caf53e9bcb1368473e">&#9670;&nbsp;</a></span>boundary_connections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt;<a class="el" href="classhexed_1_1Boundary__connection.html">Boundary_connection</a>&amp;&gt;&amp; hexed::Accessible_mesh::boundary_connections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a view of all connections between an element and a boundary condition </dd></dl>

</div>
</div>
<a id="a75ecd0dc541b4ab70332bfb5e01a3e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ecd0dc541b4ab70332bfb5e01a3e8e">&#9670;&nbsp;</a></span>cartesian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1View__by__type.html">View_by_type</a>&lt; <a class="el" href="classhexed_1_1Element.html">Element</a>&gt;&amp; hexed::Accessible_mesh::cartesian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classhexed_1_1View__by__type.html">View_by_type</a> containing only the Cartesian elements in the mesh </dd></dl>

</div>
</div>
<a id="afc87bb841d80af3862fac169703b12b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc87bb841d80af3862fac169703b12b0">&#9670;&nbsp;</a></span>connect_boundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Accessible_mesh::connect_boundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_deformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>element_serial_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bc_serial_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect a face of an element to a boundary condition. This BC will now be applied to that face. <code>i_dim</code> and <code>face_sign</code> are used to identify which face of the element is participating in the boundary condition. </p>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#ae3c8266c6f822f81660f3fb516635316">hexed::Mesh</a>.</p>

</div>
</div>
<a id="a85439beaa6ec6be4644fe16eff7c31a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85439beaa6ec6be4644fe16eff7c31a9">&#9670;&nbsp;</a></span>connect_cartesian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Accessible_mesh::connect_cartesian </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 2 &gt;&#160;</td>
          <td class="paramname"><em>serial_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Element.html">Element</a> &gt;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; bool, 2 &gt;&#160;</td>
          <td class="paramname"><em>is_deformed</em> = <code>{false,&#160;false}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify that two elements are connected via a Cartesian face. Note: although the interface is stipulated to be Cartesian, the elements themselves can be deformed </p>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#a3096fabc8a2771e3b735d66277fe3707">hexed::Mesh</a>.</p>

</div>
</div>
<a id="a7e4a24c118927a27e206ed8cbc30ec4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4a24c118927a27e206ed8cbc30ec4d">&#9670;&nbsp;</a></span>connect_hanging()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Accessible_mesh::connect_hanging </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarse_ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarse_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>fine_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>coarse_deformed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>fine_deformed</em> = <code>{false,&#160;false,&#160;false,&#160;false}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; bool, 2 &gt;&#160;</td>
          <td class="paramname"><em>stretch</em> = <code>{false,&#160;false}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>specify that an element of refinement level <code>coarse_ref_level</code> is connected to some elements of refinement level <code>coarse_ref_level + 1</code>. Coarse element comes first in <code><a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a></code>. <code>coarse_deformed</code> and <code>fine_deformed</code> specify whether the elements are Cartesian or deformed. If any of the elements are Cartesian, the entire face is assumed to be Cartesian. In this case, all the vertices must occupy their nominal positions and the <code><a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a></code> must be appropriate for a Cartesian connection. If these requirements are not satisfied, the invocation is incorrect. The number of fine elements can be any power of 2 (with a maximum of 2^(<code>n_dim - 1</code>)). In order to match the faces when less than the maximum number of elements is used, <code>stretch</code> specifies along which dimensions the fine elements are to be stretched to match the coarse. Only the first <code>n_dim - 1</code> elements of <code>stretch</code> are meaningful. The rest are ignored. </p>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#a6a742b360e5885827d2c07d0f2d82e0f">hexed::Mesh</a>.</p>

</div>
</div>
<a id="a4fc7bbc01877090be05fdff0be946b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc7bbc01877090be05fdff0be946b33">&#9670;&nbsp;</a></span>deformed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1View__by__type.html">View_by_type</a>&lt;<a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a>&gt;&amp; hexed::Accessible_mesh::deformed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classhexed_1_1View__by__type.html">View_by_type</a> containing only the deformed elements in the mesh </dd></dl>

</div>
</div>
<a id="a218f7e7d24c869c2a908aff7a6bfdb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218f7e7d24c869c2a908aff7a6bfdb15">&#9670;&nbsp;</a></span>element_connections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt;<a class="el" href="classhexed_1_1Element__connection.html">Element_connection</a>&amp;&gt;&amp; hexed::Accessible_mesh::element_connections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a view of all connections between elements, including one connection for every fine element in hanging node connections. </dd></dl>

</div>
</div>
<a id="a472153bc396bbbc2ae6b50818dc87615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472153bc396bbbc2ae6b50818dc87615">&#9670;&nbsp;</a></span>extrude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Accessible_mesh::extrude </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collapse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extrudes a layer of elements from unconnected faces:</p><ol type="1">
<li>Extrudes one deformed element from every unconnected face of every deformed element.</li>
<li>Connects the new elements to the faces they were generated from.</li>
<li>Connects the new elements to each other to maintain the connectivity of the faces they were generated from.</li>
<li>If the parent elements have any boundary connections, those are also applied to the corresponding faces of the extruded elements. When this is complete, the number of unconnected faces (of deformed elements) remains unchanged, but the unconnected faces now belong to new, extruded elements which can be snapped to surface geometry in a well-conditioned fashion. If <code>collapse == true</code> then the new elements will be collapsed in the extrusion direction, such that they have zero volume and exist purely on the extruded face. If the mesh has already been extruded once and <code>offset</code> is specified, the interior vertices of the extruded element will then be moved some distance toward the interior neighbor depending on the value of <code>offset</code>, where <code>offset == 0</code> yields no motion and <code>offset == 1</code> moves them exactly to the neighbor. If the mesh has not been extruded, the vertices shall be moved in an unspecified manner (but maintaining a valid mesh state). Offsetting thus provides a rudimentary way of creating anisotropic wall layers. If <code>force == false</code> (default) then in a tree mesh, only tree elements will be extruded from (which is necessary because some of the extruded elements from the previous refinement sweep may have non-surface-facing exposed faces). If <code>force == true</code> then all exposed faces will be extruded from. </li>
</ol>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>apparently the mesh needs to know about the basis after all... </dd></dl>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#a370e64cb387b9e5d64d0faff056a10f2">hexed::Mesh</a>.</p>

</div>
</div>
<a id="acd0061e8feb6cc2a496fce6edd6c3889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0061e8feb6cc2a496fce6edd6c3889">&#9670;&nbsp;</a></span>extruded_connections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Vector__view.html">Vector_view</a>&lt;<a class="el" href="classhexed_1_1Element__connection.html">Element_connection</a>&amp;, <a class="el" href="classhexed_1_1Element__face__connection.html">Element_face_connection</a>&lt;<a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a>&gt;*, ptr_convert&lt;<a class="el" href="classhexed_1_1Element__connection.html">Element_connection</a>&amp;, <a class="el" href="classhexed_1_1Element__face__connection.html">Element_face_connection</a>&lt;<a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a>&gt;*&gt; &gt; hexed::Accessible_mesh::extruded_connections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a view of all <a class="el" href="classhexed_1_1Element__connection.html">Element_connection</a> between extruded elements and the elemens they were extruded from </dd></dl>

</div>
</div>
<a id="a4db83bed2889b068881e50453f54d6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db83bed2889b068881e50453f54d6e8">&#9670;&nbsp;</a></span>hanging_vertex_matchers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt;<a class="el" href="classhexed_1_1Hanging__vertex__matcher.html">Hanging_vertex_matcher</a>&amp;&gt;&amp; hexed::Accessible_mesh::hanging_vertex_matchers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a view of all <a class="el" href="classhexed_1_1Hanging__vertex__matcher.html">Hanging_vertex_matcher</a> objects owned by this mesh (there will be one for every hanging node connection) </dd></dl>

</div>
</div>
<a id="a65899ec69850aa30f233615c28e642dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65899ec69850aa30f233615c28e642dd">&#9670;&nbsp;</a></span>refined_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Sequence.html">Sequence</a>&lt;<a class="el" href="classhexed_1_1Refined__face.html">Refined_face</a>&amp;&gt;&amp; hexed::Accessible_mesh::refined_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a view of all <a class="el" href="classhexed_1_1Refined__face.html">Refined_face</a> objects owned by this mesh (there will be one for every hanging node connection) </dd></dl>

</div>
</div>
<a id="a4fe952d543dc73dfe1ae683428abf4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe952d543dc73dfe1ae683428abf4fd">&#9670;&nbsp;</a></span>relax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Accessible_mesh::relax </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>0.9</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relax the vertices to improve mesh quality. </p>
<p>By default, relaxation is performed incrementally &ndash; only vertices of elements that are new in the most recent <code><a class="el" href="classhexed_1_1Accessible__mesh.html#af0468319f657ad8aa9732c42eead1091" title="Updates tree mesh based on user-supplied (un)refinement criteria.">update()</a></code> cycle are smoothed. To smooth all, call <code><a class="el" href="classhexed_1_1Accessible__mesh.html#a113f9237fe66ca1798d4cd265616cc3c" title="sets need_smooth to true for all vertices to perform global relaxation (only effective until the next...">set_all_smooth()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>A larger number yields more change in the mesh. 0 =&gt; no update, 1 =&gt; "full" update, &gt; 1 allowed but suspect </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#aa4accd9af409be6e7401ba9849c724a3">hexed::Mesh</a>.</p>

</div>
</div>
<a id="aae6e7b4d0bb2d83c76310d3d7d46cd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6e7b4d0bb2d83c76310d3d7d46cd75">&#9670;&nbsp;</a></span>root_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hexed::Accessible_mesh::root_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Nominal size ( \(\Delta h\)) of elements with refinement level 0. </dd></dl>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#afa4b58fbf44b95a693c392312afa5911">hexed::Mesh</a>.</p>

</div>
</div>
<a id="a8bbb6de6ed43d840d5fc0e742a94997c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbb6de6ed43d840d5fc0e742a94997c">&#9670;&nbsp;</a></span>set_surface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Accessible_mesh::set_surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> *&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *&#160;</td>
          <td class="paramname"><em>surface_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#ga8554c6170729f01c7572574837ecf618">Eigen::VectorXd</a>&#160;</td>
          <td class="paramname"><em>flood_fill_start</em> = <code><a class="elRef" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#a422ddeef58bedc7bddb1d4357688d761">Eigen::VectorXd::Zero</a>(3)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the surface geometry to be meshed as a boundary. </p>
<p>Acquires ownership of the objects pointed to <code>geometry</code> and <code>surface_bc</code>. The geometric surface represented by <code>geometry</code> is now a boundary of the domain and its boundary condition is <code>surface_bc</code>. The flood fill algorithm is then executed starting at <code>flood_fill_start</code> to determine which elements are in the domain and extrusion is executed to create a suitably body-fitted mesh. <code>flood_fill_start</code> must have at least <code>n_dim</code> entries and extra entries are ignored. If the mesh is excessively coarse, there may be no elements in the domain as they are all too close to the surfaces. So, <code><a class="el" href="classhexed_1_1Mesh.html#aee55ffd3b0dff849f5f7f315fe76b450" title="Updates tree mesh based on user-supplied (un)refinement criteria.">Mesh::update</a></code> should be calling a few times before <code>Mesh::set_surfaces</code>. Any surfaces defined by previous invokations of <code>set_surface</code> are forgotten. sets the <code><a class="el" href="classhexed_1_1Element.html#a3d44aa7a67b705b7f5132fb2664c9dfc" title="if this is set to true, Mesh_interface::update() won&#39;t unrefine it">Element::unrefinement_locked</a></code> member of all elements </p>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#a5b62dd6ec4bbedaba0901bf7e6235118">hexed::Mesh</a>.</p>

</div>
</div>
<a id="a6b183489199fb7c8b402a835f42bfdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b183489199fb7c8b402a835f42bfdc5">&#9670;&nbsp;</a></span>surface_bc_sn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hexed::Accessible_mesh::surface_bc_sn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>what is the serial number of the geometry surface BC? </p>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#aca2d99625f2882f76c9af3c9f1617682">hexed::Mesh</a>.</p>

</div>
</div>
<a id="af0468319f657ad8aa9732c42eead1091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0468319f657ad8aa9732c42eead1091">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hexed::Accessible_mesh::update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>refine_criterion</em> = <code><a class="el" href="namespacehexed_1_1criteria.html#a86ceaaf056ff2cec5d7ebb2c32f3d4cd">criteria::always</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>unrefine_criterion</em> = <code><a class="el" href="namespacehexed_1_1criteria.html#acf972478516de191c744fb288460c0f4">criteria::never</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates tree mesh based on user-supplied (un)refinement criteria. </p>
<p>Evaluates <code>refine_criterion</code> and <code>unrefine_criterion</code> on every element in the tree (if a tree exists). Whenever <code>refine_criterion</code> is <code>true</code> and <code>unrefine_criterion</code> is <code>false</code>, that element is refined. Whenever <code>unrefine_criterion</code> is <code>true</code> and <code>refine_criterion</code> is <code>false</code> for a complete group of sibling elements, that group is unrefined. Since extruded elements cannot be directly refined or unrefined, their extrusion parents inherit their (un)refinement flags and any unrefinement locks. In order to satisfy some criteria regarding the refinement level of neighbors, some additional elements may be refined and some elements may not be unrefined. Both criteria must be thread-safe and must not depend on the order in which elements are processed. The flood fill and extrusion are also updated. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the mesh was changed, else <code>false</code> </dd></dl>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#aee55ffd3b0dff849f5f7f315fe76b450">hexed::Mesh</a>.</p>

</div>
</div>
<a id="ac3180165c91e00a1f3b193dab13a3651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3180165c91e00a1f3b193dab13a3651">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Mesh_1_1Connection__validity.html">Mesh::Connection_validity</a> hexed::Accessible_mesh::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>Connection_validity</code> object describing whether the mesh connectivity is valid. </p>
<p>Suggested uses:</p><ul>
<li><code>if (mesh.valid()) {\\...do something that requires a valid mesh}</code></li>
<li><code>mesh.valid().assert_valid();</code> </li>
</ul>

<p>Implements <a class="el" href="classhexed_1_1Mesh.html#a2dee7ff404064623d050a665c0668a1f">hexed::Mesh</a>.</p>

</div>
</div>
<a id="ad52e0ad3fee57fd7523d551c0d5cd4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52e0ad3fee57fd7523d551c0d5cd4ff">&#9670;&nbsp;</a></span>vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Accessible__mesh.html#a1ab0f54ca7133f206e142033ef03af5e">Accessible_mesh::vertex_view</a> hexed::Accessible_mesh::vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a view of all <a class="el" href="classhexed_1_1Vertex.html" title="Represents a vertex in a deformed grid.">Vertex</a> objects used by elements in this mesh. Each vertex will appear exactly once, even if it is shared by multiple elements. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af5f1a31a672de8ae002f4f4f279f094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f1a31a672de8ae002f4f4f279f094a">&#9670;&nbsp;</a></span>buffer_dist</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hexed::Accessible_mesh::buffer_dist</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how far must the center of an element be from the geometry relative to the nominal size </p>
<p>Defaults to \( \frac{\sqrt{n_d}}{2} \). You can modify it, but it cannot be less than this. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/micaiah/orgs/artlab/hexed/include/Accessible_mesh.hpp</li>
<li>/home/micaiah/orgs/artlab/hexed/src/Accessible_mesh.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehexed.html">hexed</a></li><li class="navelem"><a class="el" href="classhexed_1_1Accessible__mesh.html">Accessible_mesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
