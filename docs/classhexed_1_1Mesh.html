<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hexed: hexed::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hexed
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhexed_1_1Mesh.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classhexed_1_1Mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hexed::Mesh Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Mesh.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hexed::Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="classhexed_1_1Mesh__inherit__graph.png" border="0" usemap="#ahexed_1_1Mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="ahexed_1_1Mesh_inherit__map" id="ahexed_1_1Mesh_inherit__map">
<area shape="rect" title=" " alt="" coords="44,5,148,32"/>
<area shape="rect" href="classhexed_1_1Accessible__mesh.html" title="A mesh that supports access to the actual elements with the numerical data they contain." alt="" coords="5,80,187,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh_1_1Connection__validity.html">Connection_validity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object to provide information about whether the mesh connectivity is valid and if not, why.  <a href="classhexed_1_1Mesh_1_1Connection__validity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhexed_1_1Mesh_1_1elem__handle.html">elem_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum information required to identify an element  <a href="structhexed_1_1Mesh_1_1elem__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh_1_1Reset__vertices.html">Reset_vertices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily resets the vertices of a mesh to their nominal positions for debugging.  <a href="classhexed_1_1Mesh_1_1Reset__vertices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa4b58fbf44b95a693c392312afa5911"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#afa4b58fbf44b95a693c392312afa5911">root_size</a> ()=0</td></tr>
<tr class="separator:afa4b58fbf44b95a693c392312afa5911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manual mesh creation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section attention"><dt>Attention</dt><dd>You <b>must</b> call <code><a class="el" href="classhexed_1_1Mesh.html#ae20ae45d78a931096c374703ee583629" title="Does some work that has to happen after you manually add elements and/or connections.">cleanup()</a></code> in between calling any of these functions and doing anything else (like relaxing vertices). </dd></dl>
</div></td></tr>
<tr class="memitem:a8fd53d5f29f47e9a826f977324cea4a6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a8fd53d5f29f47e9a826f977324cea4a6">add_element</a> (int ref_level, bool is_deformed, std::vector&lt; int &gt; position)=0</td></tr>
<tr class="separator:a8fd53d5f29f47e9a826f977324cea4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3096fabc8a2771e3b735d66277fe3707"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a3096fabc8a2771e3b735d66277fe3707">connect_cartesian</a> (int ref_level, std::array&lt; int, 2 &gt; serial_n, <a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Element.html">Element</a> &gt; dir, std::array&lt; bool, 2 &gt; is_deformed={false, false})=0</td></tr>
<tr class="separator:a3096fabc8a2771e3b735d66277fe3707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dd2149c6d68bb6a1b564454a675c39"><td class="memItemLeft" align="right" valign="top"><a id="ab5dd2149c6d68bb6a1b564454a675c39"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#ab5dd2149c6d68bb6a1b564454a675c39">connect_deformed</a> (int ref_level, std::array&lt; int, 2 &gt; serial_n, <a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt; direction)=0</td></tr>
<tr class="memdesc:ab5dd2149c6d68bb6a1b564454a675c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that two elements are connected via a deformed face. Requires both elements to be deformed. <br /></td></tr>
<tr class="separator:ab5dd2149c6d68bb6a1b564454a675c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a742b360e5885827d2c07d0f2d82e0f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a6a742b360e5885827d2c07d0f2d82e0f">connect_hanging</a> (int coarse_ref_level, int coarse_serial, std::vector&lt; int &gt; fine_serial, <a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt;, bool coarse_deformed=false, std::vector&lt; bool &gt; fine_deformed={false, false, false, false}, std::array&lt; bool, 2 &gt; stretch={false, false})=0</td></tr>
<tr class="separator:a6a742b360e5885827d2c07d0f2d82e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aaf2fbbc6d8faa4ac4d494a72a0c53"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a26aaf2fbbc6d8faa4ac4d494a72a0c53">add_boundary_condition</a> (<a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *flow_bc, <a class="el" href="classhexed_1_1Mesh__bc.html">Mesh_bc</a> *mesh_bc)=0</td></tr>
<tr class="separator:a26aaf2fbbc6d8faa4ac4d494a72a0c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c8266c6f822f81660f3fb516635316"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#ae3c8266c6f822f81660f3fb516635316">connect_boundary</a> (int ref_level, bool is_deformed, int element_serial_n, int i_dim, int face_sign, int bc_serial_n)=0</td></tr>
<tr class="separator:ae3c8266c6f822f81660f3fb516635316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6777399f709f4e04937aad4d0812dbd0"><td class="memItemLeft" align="right" valign="top"><a id="a6777399f709f4e04937aad4d0812dbd0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a6777399f709f4e04937aad4d0812dbd0">disconnect_boundary</a> (int bc_sn)=0</td></tr>
<tr class="memdesc:a6777399f709f4e04937aad4d0812dbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete all boundary connections involving a certain boundary condition <br /></td></tr>
<tr class="separator:a6777399f709f4e04937aad4d0812dbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d58986c1af851494e90ba4ac9153a6"><td class="memItemLeft" align="right" valign="top"><a id="a97d58986c1af851494e90ba4ac9153a6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a97d58986c1af851494e90ba4ac9153a6">connect_rest</a> (int bc_sn)=0</td></tr>
<tr class="memdesc:a97d58986c1af851494e90ba4ac9153a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">connects all yet-unconnected faces to a boundary condition specified by serial number <br /></td></tr>
<tr class="separator:a97d58986c1af851494e90ba4ac9153a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370e64cb387b9e5d64d0faff056a10f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a370e64cb387b9e5d64d0faff056a10f2">extrude</a> (bool collapse=false, double offset=0, bool force=false)=0</td></tr>
<tr class="separator:a370e64cb387b9e5d64d0faff056a10f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125f26f5c68c35eb6ed8bb22a3431741"><td class="memItemLeft" align="right" valign="top"><a id="a125f26f5c68c35eb6ed8bb22a3431741"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a125f26f5c68c35eb6ed8bb22a3431741">extrude</a> (<a class="el" href="classhexed_1_1Layer__sequence.html">Layer_sequence</a> layers)</td></tr>
<tr class="memdesc:a125f26f5c68c35eb6ed8bb22a3431741"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a125f26f5c68c35eb6ed8bb22a3431741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20ae45d78a931096c374703ee583629"><td class="memItemLeft" align="right" valign="top"><a id="ae20ae45d78a931096c374703ee583629"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#ae20ae45d78a931096c374703ee583629">cleanup</a> ()=0</td></tr>
<tr class="memdesc:ae20ae45d78a931096c374703ee583629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some work that has to happen after you manually add elements and/or connections. <br /></td></tr>
<tr class="separator:ae20ae45d78a931096c374703ee583629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Automated tree meshing</div></td></tr>
<tr class="memitem:a3dcaa709d3c08d62e01b2015b9ce071b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a3dcaa709d3c08d62e01b2015b9ce071b">add_tree</a> (std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt; extremal_bcs, <a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt; origin=<a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;::Zero(3))=0</td></tr>
<tr class="memdesc:a3dcaa709d3c08d62e01b2015b9ce071b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes meshing with bin/quad/<a href="https://en.wikipedia.org/wiki/Octree">octree</a> topology.  <a href="classhexed_1_1Mesh.html#a3dcaa709d3c08d62e01b2015b9ce071b">More...</a><br /></td></tr>
<tr class="separator:a3dcaa709d3c08d62e01b2015b9ce071b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b62dd6ec4bbedaba0901bf7e6235118"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a5b62dd6ec4bbedaba0901bf7e6235118">set_surface</a> (<a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> *geometry, <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *surface_bc, <a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#ga8554c6170729f01c7572574837ecf618">Eigen::VectorXd</a> flood_fill_start=<a class="elRef" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#a422ddeef58bedc7bddb1d4357688d761">Eigen::VectorXd::Zero</a>(3))=0</td></tr>
<tr class="memdesc:a5b62dd6ec4bbedaba0901bf7e6235118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the surface geometry to be meshed as a boundary.  <a href="classhexed_1_1Mesh.html#a5b62dd6ec4bbedaba0901bf7e6235118">More...</a><br /></td></tr>
<tr class="separator:a5b62dd6ec4bbedaba0901bf7e6235118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf1bc261e23f8468ebe8e47e1b2b9c9"><td class="memItemLeft" align="right" valign="top"><a id="a8cf1bc261e23f8468ebe8e47e1b2b9c9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_unref_locks</b> (std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt; lock_if=<a class="el" href="namespacehexed_1_1criteria.html#acf972478516de191c744fb288460c0f4">criteria::never</a>)=0</td></tr>
<tr class="separator:a8cf1bc261e23f8468ebe8e47e1b2b9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee55ffd3b0dff849f5f7f315fe76b450"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#aee55ffd3b0dff849f5f7f315fe76b450">update</a> (std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt; refine_criterion=<a class="el" href="namespacehexed_1_1criteria.html#a86ceaaf056ff2cec5d7ebb2c32f3d4cd">criteria::always</a>, std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt; unrefine_criterion=<a class="el" href="namespacehexed_1_1criteria.html#acf972478516de191c744fb288460c0f4">criteria::never</a>)=0</td></tr>
<tr class="memdesc:aee55ffd3b0dff849f5f7f315fe76b450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates tree mesh based on user-supplied (un)refinement criteria.  <a href="classhexed_1_1Mesh.html#aee55ffd3b0dff849f5f7f315fe76b450">More...</a><br /></td></tr>
<tr class="separator:aee55ffd3b0dff849f5f7f315fe76b450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2306ebd341ff18ecc6b9b003b74bb2"><td class="memItemLeft" align="right" valign="top"><a id="a0c2306ebd341ff18ecc6b9b003b74bb2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a0c2306ebd341ff18ecc6b9b003b74bb2">set_all_smooth</a> ()=0</td></tr>
<tr class="memdesc:a0c2306ebd341ff18ecc6b9b003b74bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets <code>need_smooth</code> to <code>true</code> for all vertices to perform global relaxation (only effective until the next <code><a class="el" href="classhexed_1_1Mesh.html#aee55ffd3b0dff849f5f7f315fe76b450" title="Updates tree mesh based on user-supplied (un)refinement criteria.">update()</a></code> cycle) <br /></td></tr>
<tr class="separator:a0c2306ebd341ff18ecc6b9b003b74bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4accd9af409be6e7401ba9849c724a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#aa4accd9af409be6e7401ba9849c724a3">relax</a> (double factor=0.9)=0</td></tr>
<tr class="memdesc:aa4accd9af409be6e7401ba9849c724a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relax the vertices to improve mesh quality.  <a href="classhexed_1_1Mesh.html#aa4accd9af409be6e7401ba9849c724a3">More...</a><br /></td></tr>
<tr class="separator:aa4accd9af409be6e7401ba9849c724a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2d99625f2882f76c9af3c9f1617682"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#aca2d99625f2882f76c9af3c9f1617682">surface_bc_sn</a> ()=0</td></tr>
<tr class="separator:aca2d99625f2882f76c9af3c9f1617682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">observers</div></td></tr>
<tr class="memitem:aaf2e379daf26b826b045f94cbf4b11de"><td class="memItemLeft" align="right" valign="top"><a id="aaf2e379daf26b826b045f94cbf4b11de"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#aaf2e379daf26b826b045f94cbf4b11de">n_elements</a> ()=0</td></tr>
<tr class="memdesc:aaf2e379daf26b826b045f94cbf4b11de"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elements currently in the mesh <br /></td></tr>
<tr class="separator:aaf2e379daf26b826b045f94cbf4b11de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dee7ff404064623d050a665c0668a1f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhexed_1_1Mesh_1_1Connection__validity.html">Connection_validity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a2dee7ff404064623d050a665c0668a1f">valid</a> ()=0</td></tr>
<tr class="memdesc:a2dee7ff404064623d050a665c0668a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="classhexed_1_1Mesh_1_1Connection__validity.html" title="An object to provide information about whether the mesh connectivity is valid and if not,...">Connection_validity</a></code> object describing whether the mesh connectivity is valid.  <a href="classhexed_1_1Mesh.html#a2dee7ff404064623d050a665c0668a1f">More...</a><br /></td></tr>
<tr class="separator:a2dee7ff404064623d050a665c0668a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1178de2759eae814279e6438f78c286e"><td class="memItemLeft" align="right" valign="top"><a id="a1178de2759eae814279e6438f78c286e"></a>
virtual std::vector&lt; <a class="el" href="structhexed_1_1Mesh_1_1elem__handle.html">elem_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a1178de2759eae814279e6438f78c286e">elem_handles</a> ()=0</td></tr>
<tr class="memdesc:a1178de2759eae814279e6438f78c286e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get handles for all elements currently in the mesh, in no particular order (mostly for testing/debugging) <br /></td></tr>
<tr class="separator:a1178de2759eae814279e6438f78c286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>write this mesh to a file to be reused in another simulation </p>
</div></td></tr>
<tr class="memitem:a52a5d0d5a5d8d7aa9bf12d441d076280"><td class="memItemLeft" align="right" valign="top"><a id="a52a5d0d5a5d8d7aa9bf12d441d076280"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (std::string file_name)=0</td></tr>
<tr class="separator:a52a5d0d5a5d8d7aa9bf12d441d076280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174c88acb7afe18c7b732e18d7fa3fa6"><td class="memItemLeft" align="right" valign="top"><a id="a174c88acb7afe18c7b732e18d7fa3fa6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Mesh.html#a174c88acb7afe18c7b732e18d7fa3fa6">export_polymesh</a> (std::string dir_name)=0</td></tr>
<tr class="memdesc:a174c88acb7afe18c7b732e18d7fa3fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the mesh in the OpenFOAM PolyMesh format <br /></td></tr>
<tr class="separator:a174c88acb7afe18c7b732e18d7fa3fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac605c88b09b91031fa7e137ec656c3b8"><td class="memItemLeft" align="right" valign="top"><a id="ac605c88b09b91031fa7e137ec656c3b8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>reset_verts</b> ()=0</td></tr>
<tr class="separator:ac605c88b09b91031fa7e137ec656c3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c17aa3f05b65ce59e9008031b9315b9"><td class="memItemLeft" align="right" valign="top"><a id="a0c17aa3f05b65ce59e9008031b9315b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>restore_verts</b> ()=0</td></tr>
<tr class="separator:a0c17aa3f05b65ce59e9008031b9315b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a collection of interconnected elements. This class is an interface which supports only manipulation of the mesh itself, not access to the elements it contains. One common theme in this interface is the use of "serial numbers" to identify objects owned by the <code><a class="el" href="classhexed_1_1Mesh.html">Mesh</a></code> object. These "serial numbers" are unique (among objects of a specified class), nonnegative, and permanent, but otherwise arbitrary. Unlike indices, which are expected to be consecutive, the serial numbers remain valid regardless of any addition or deletion of objects. They are also preferable to pointers or references because they preclude (illegal) attempts to relate objects owned by different meshes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a26aaf2fbbc6d8faa4ac4d494a72a0c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26aaf2fbbc6d8faa4ac4d494a72a0c53">&#9670;&nbsp;</a></span>add_boundary_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int hexed::Mesh::add_boundary_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *&#160;</td>
          <td class="paramname"><em>flow_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Mesh__bc.html">Mesh_bc</a> *&#160;</td>
          <td class="paramname"><em>mesh_bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquires owenership of <code>*flow_bc</code> and <code>*mesh_bc</code> and constructs a <code><a class="el" href="classhexed_1_1Boundary__condition.html">Boundary_condition</a></code> from them. Returns a serial number which uniquely identifies the new boundary condition among this <code><a class="el" href="classhexed_1_1Mesh.html">Mesh</a></code>'s boundary conditions. It is recommended to use this with <code>new</code>, like the constructor for <code>std::unique_ptr</code>. </p>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a6ea3d96d4fd9dcb85e205f005c58bcdd">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="a8fd53d5f29f47e9a826f977324cea4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd53d5f29f47e9a826f977324cea4a6">&#9670;&nbsp;</a></span>add_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int hexed::Mesh::add_element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_deformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an element at specified nominal position and serial number which uniquely identifies it among elements of this mesh with the same refinement level and deformedness. </p>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a3effbd55bbf2c058f389d3ac8eb64fa9">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="a3dcaa709d3c08d62e01b2015b9ce071b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcaa709d3c08d62e01b2015b9ce071b">&#9670;&nbsp;</a></span>add_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void hexed::Mesh::add_tree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt;&#160;</td>
          <td class="paramname"><em>extremal_bcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;&#160;</td>
          <td class="paramname"><em>origin</em> = <code><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;::Zero(3)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes meshing with bin/quad/<a href="https://en.wikipedia.org/wiki/Octree">octree</a> topology. </p>
<p>Creates a tree initialized with one element with ref level 0. Technically, free-form elements can also be created in the same mesh, but they will not be connected to the tree. Only one tree can be created. Connections and boundary conditions are set automatically for tree elements, so tree meshes should always automatically be valid unless you explicitly invalidate it with <code><a class="el" href="classhexed_1_1Mesh.html#a6777399f709f4e04937aad4d0812dbd0" title="delete all boundary connections involving a certain boundary condition">Mesh::disconnect_boundary</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extremal_bcs</td><td>Boundary conditions to apply to elements with exposed faces at the extremal boundaries of the tree. Takes ownership of objects that the vector entries point to. It must contain exactly <code>2*n_dim</code> entries. E.g. <code>extremal_bcs[0]</code> is the boundary condition to apply to the minimum \(x_0\) face, <code>extremal_bcs[1]</code> is the BC for the maximum \(x_0\) face, <code>extremal_bcs[2]</code> is for minimum \(x_1\). </td></tr>
    <tr><td class="paramname">origin</td><td>The minimal corner of the tree root will be located at <code>origin</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a35b061d00acf3595b6c1ba9aaf257f36">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="ae3c8266c6f822f81660f3fb516635316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c8266c6f822f81660f3fb516635316">&#9670;&nbsp;</a></span>connect_boundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void hexed::Mesh::connect_boundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_deformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>element_serial_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bc_serial_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect a face of an element to a boundary condition. This BC will now be applied to that face. <code>i_dim</code> and <code>face_sign</code> are used to identify which face of the element is participating in the boundary condition. </p>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#afc87bb841d80af3862fac169703b12b0">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="a3096fabc8a2771e3b735d66277fe3707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3096fabc8a2771e3b735d66277fe3707">&#9670;&nbsp;</a></span>connect_cartesian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void hexed::Mesh::connect_cartesian </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 2 &gt;&#160;</td>
          <td class="paramname"><em>serial_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Element.html">Element</a> &gt;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; bool, 2 &gt;&#160;</td>
          <td class="paramname"><em>is_deformed</em> = <code>{false,&#160;false}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify that two elements are connected via a Cartesian face. Note: although the interface is stipulated to be Cartesian, the elements themselves can be deformed </p>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a85439beaa6ec6be4644fe16eff7c31a9">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="a6a742b360e5885827d2c07d0f2d82e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a742b360e5885827d2c07d0f2d82e0f">&#9670;&nbsp;</a></span>connect_hanging()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void hexed::Mesh::connect_hanging </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarse_ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarse_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>fine_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a>&lt; <a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>coarse_deformed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>fine_deformed</em> = <code>{false,&#160;false,&#160;false,&#160;false}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; bool, 2 &gt;&#160;</td>
          <td class="paramname"><em>stretch</em> = <code>{false,&#160;false}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>specify that an element of refinement level <code>coarse_ref_level</code> is connected to some elements of refinement level <code>coarse_ref_level + 1</code>. Coarse element comes first in <code><a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a></code>. <code>coarse_deformed</code> and <code>fine_deformed</code> specify whether the elements are Cartesian or deformed. If any of the elements are Cartesian, the entire face is assumed to be Cartesian. In this case, all the vertices must occupy their nominal positions and the <code><a class="el" href="classhexed_1_1Con__dir.html">Con_dir</a></code> must be appropriate for a Cartesian connection. If these requirements are not satisfied, the invocation is incorrect. The number of fine elements can be any power of 2 (with a maximum of 2^(<code>n_dim - 1</code>)). In order to match the faces when less than the maximum number of elements is used, <code>stretch</code> specifies along which dimensions the fine elements are to be stretched to match the coarse. Only the first <code>n_dim - 1</code> elements of <code>stretch</code> are meaningful. The rest are ignored. </p>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a7e4a24c118927a27e206ed8cbc30ec4d">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="a370e64cb387b9e5d64d0faff056a10f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370e64cb387b9e5d64d0faff056a10f2">&#9670;&nbsp;</a></span>extrude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void hexed::Mesh::extrude </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collapse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extrudes a layer of elements from unconnected faces:</p><ol type="1">
<li>Extrudes one deformed element from every unconnected face of every deformed element.</li>
<li>Connects the new elements to the faces they were generated from.</li>
<li>Connects the new elements to each other to maintain the connectivity of the faces they were generated from.</li>
<li>If the parent elements have any boundary connections, those are also applied to the corresponding faces of the extruded elements. When this is complete, the number of unconnected faces (of deformed elements) remains unchanged, but the unconnected faces now belong to new, extruded elements which can be snapped to surface geometry in a well-conditioned fashion. If <code>collapse == true</code> then the new elements will be collapsed in the extrusion direction, such that they have zero volume and exist purely on the extruded face. If the mesh has already been extruded once and <code>offset</code> is specified, the interior vertices of the extruded element will then be moved some distance toward the interior neighbor depending on the value of <code>offset</code>, where <code>offset == 0</code> yields no motion and <code>offset == 1</code> moves them exactly to the neighbor. If the mesh has not been extruded, the vertices shall be moved in an unspecified manner (but maintaining a valid mesh state). Offsetting thus provides a rudimentary way of creating anisotropic wall layers. If <code>force == false</code> (default) then in a tree mesh, only tree elements will be extruded from (which is necessary because some of the extruded elements from the previous refinement sweep may have non-surface-facing exposed faces). If <code>force == true</code> then all exposed faces will be extruded from. </li>
</ol>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a472153bc396bbbc2ae6b50818dc87615">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="aa4accd9af409be6e7401ba9849c724a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4accd9af409be6e7401ba9849c724a3">&#9670;&nbsp;</a></span>relax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void hexed::Mesh::relax </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>0.9</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relax the vertices to improve mesh quality. </p>
<p>By default, relaxation is performed incrementally &ndash; only vertices of elements that are new in the most recent <code><a class="el" href="classhexed_1_1Mesh.html#aee55ffd3b0dff849f5f7f315fe76b450" title="Updates tree mesh based on user-supplied (un)refinement criteria.">update()</a></code> cycle are smoothed. To smooth all, call <code><a class="el" href="classhexed_1_1Mesh.html#a0c2306ebd341ff18ecc6b9b003b74bb2" title="sets need_smooth to true for all vertices to perform global relaxation (only effective until the next...">set_all_smooth()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>A larger number yields more change in the mesh. 0 =&gt; no update, 1 =&gt; "full" update, &gt; 1 allowed but suspect </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a4fe952d543dc73dfe1ae683428abf4fd">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="afa4b58fbf44b95a693c392312afa5911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4b58fbf44b95a693c392312afa5911">&#9670;&nbsp;</a></span>root_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double hexed::Mesh::root_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Nominal size ( \(\Delta h\)) of elements with refinement level 0. </dd></dl>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#aae6e7b4d0bb2d83c76310d3d7d46cd75">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="a5b62dd6ec4bbedaba0901bf7e6235118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b62dd6ec4bbedaba0901bf7e6235118">&#9670;&nbsp;</a></span>set_surface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void hexed::Mesh::set_surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> *&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *&#160;</td>
          <td class="paramname"><em>surface_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#ga8554c6170729f01c7572574837ecf618">Eigen::VectorXd</a>&#160;</td>
          <td class="paramname"><em>flood_fill_start</em> = <code><a class="elRef" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#a422ddeef58bedc7bddb1d4357688d761">Eigen::VectorXd::Zero</a>(3)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the surface geometry to be meshed as a boundary. </p>
<p>Acquires ownership of the objects pointed to <code>geometry</code> and <code>surface_bc</code>. The geometric surface represented by <code>geometry</code> is now a boundary of the domain and its boundary condition is <code>surface_bc</code>. The flood fill algorithm is then executed starting at <code>flood_fill_start</code> to determine which elements are in the domain and extrusion is executed to create a suitably body-fitted mesh. <code>flood_fill_start</code> must have at least <code>n_dim</code> entries and extra entries are ignored. If the mesh is excessively coarse, there may be no elements in the domain as they are all too close to the surfaces. So, <code><a class="el" href="classhexed_1_1Mesh.html#aee55ffd3b0dff849f5f7f315fe76b450" title="Updates tree mesh based on user-supplied (un)refinement criteria.">Mesh::update</a></code> should be calling a few times before <code>Mesh::set_surfaces</code>. Any surfaces defined by previous invokations of <code>set_surface</code> are forgotten. sets the <code><a class="el" href="classhexed_1_1Element.html#a3d44aa7a67b705b7f5132fb2664c9dfc" title="if this is set to true, Mesh_interface::update() won&#39;t unrefine it">Element::unrefinement_locked</a></code> member of all elements </p>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a8bbb6de6ed43d840d5fc0e742a94997c">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="aca2d99625f2882f76c9af3c9f1617682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2d99625f2882f76c9af3c9f1617682">&#9670;&nbsp;</a></span>surface_bc_sn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int hexed::Mesh::surface_bc_sn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>what is the serial number of the geometry surface BC? </p>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#a6b183489199fb7c8b402a835f42bfdc5">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="aee55ffd3b0dff849f5f7f315fe76b450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee55ffd3b0dff849f5f7f315fe76b450">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool hexed::Mesh::update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>refine_criterion</em> = <code><a class="el" href="namespacehexed_1_1criteria.html#a86ceaaf056ff2cec5d7ebb2c32f3d4cd">criteria::always</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classhexed_1_1Element.html">Element</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>unrefine_criterion</em> = <code><a class="el" href="namespacehexed_1_1criteria.html#acf972478516de191c744fb288460c0f4">criteria::never</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates tree mesh based on user-supplied (un)refinement criteria. </p>
<p>Evaluates <code>refine_criterion</code> and <code>unrefine_criterion</code> on every element in the tree (if a tree exists). Whenever <code>refine_criterion</code> is <code>true</code> and <code>unrefine_criterion</code> is <code>false</code>, that element is refined. Whenever <code>unrefine_criterion</code> is <code>true</code> and <code>refine_criterion</code> is <code>false</code> for a complete group of sibling elements, that group is unrefined. Since extruded elements cannot be directly refined or unrefined, their extrusion parents inherit their (un)refinement flags and any unrefinement locks. In order to satisfy some criteria regarding the refinement level of neighbors, some additional elements may be refined and some elements may not be unrefined. Both criteria must be thread-safe and must not depend on the order in which elements are processed. The flood fill and extrusion are also updated. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the mesh was changed, else <code>false</code> </dd></dl>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#af0468319f657ad8aa9732c42eead1091">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<a id="a2dee7ff404064623d050a665c0668a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dee7ff404064623d050a665c0668a1f">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classhexed_1_1Mesh_1_1Connection__validity.html">Connection_validity</a> hexed::Mesh::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="classhexed_1_1Mesh_1_1Connection__validity.html" title="An object to provide information about whether the mesh connectivity is valid and if not,...">Connection_validity</a></code> object describing whether the mesh connectivity is valid. </p>
<p>Suggested uses:</p><ul>
<li><code>if (mesh.valid()) {\\...do something that requires a valid mesh}</code></li>
<li><code>mesh.valid().assert_valid();</code> </li>
</ul>

<p>Implemented in <a class="el" href="classhexed_1_1Accessible__mesh.html#ac3180165c91e00a1f3b193dab13a3651">hexed::Accessible_mesh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/micaiah/orgs/artlab/hexed/include/Mesh.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehexed.html">hexed</a></li><li class="navelem"><a class="el" href="classhexed_1_1Mesh.html">Mesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
