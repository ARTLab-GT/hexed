<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hexed: hexed::Solver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hexed
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhexed_1_1Solver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhexed_1_1Solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hexed::Solver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main class that basically runs everything.  
 <a href="classhexed_1_1Solver.html#details">More...</a></p>

<p><code>#include &lt;Solver.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7fe06e75e037aaa83efcbecb586214d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ac7fe06e75e037aaa83efcbecb586214d">Solver</a> (int n_dim, int row_size, double root_mesh_size, bool local_time_stepping=false, <a class="el" href="classhexed_1_1Transport__model.html">Transport_model</a> viscosity_model=<a class="el" href="namespacehexed.html#adfc99352c3a0cc7f6e721448c6a8d3da">inviscid</a>, <a class="el" href="classhexed_1_1Transport__model.html">Transport_model</a> thermal_conductivity_model=<a class="el" href="namespacehexed.html#adfc99352c3a0cc7f6e721448c6a8d3da">inviscid</a>, std::shared_ptr&lt; <a class="el" href="classhexed_1_1Namespace.html">Namespace</a> &gt; space=std::make_shared&lt; <a class="el" href="classhexed_1_1Namespace.html">Namespace</a> &gt;(), std::shared_ptr&lt; <a class="el" href="classhexed_1_1Printer.html">Printer</a> &gt; printer=std::make_shared&lt; <a class="el" href="classhexed_1_1Stream__printer.html">Stream_printer</a> &gt;(), bool implicit=false)</td></tr>
<tr class="separator:ac7fe06e75e037aaa83efcbecb586214d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">setup</div></td></tr>
<tr class="memitem:a6d3b809cb4f1562099f62fb7ad503f81"><td class="memItemLeft" align="right" valign="top"><a id="a6d3b809cb4f1562099f62fb7ad503f81"></a>
<a class="el" href="classhexed_1_1Namespace.html">Namespace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nspace</b> ()</td></tr>
<tr class="separator:a6d3b809cb4f1562099f62fb7ad503f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab105c8a279cc945de54857632424aca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ab105c8a279cc945de54857632424aca7">mesh</a> ()</td></tr>
<tr class="memdesc:ab105c8a279cc945de54857632424aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the namespace which can be used to edit user-defined parameters.  <a href="classhexed_1_1Solver.html#ab105c8a279cc945de54857632424aca7">More...</a><br /></td></tr>
<tr class="separator:ab105c8a279cc945de54857632424aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57eee18f37e1da2e272b3d90a0dc18d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#aa57eee18f37e1da2e272b3d90a0dc18d">read_mesh</a> (std::string file_name, std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt; extremal_bcs, <a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> *=nullptr, <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *surface_bc=nullptr)</td></tr>
<tr class="memdesc:aa57eee18f37e1da2e272b3d90a0dc18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads mesh from file  <a href="classhexed_1_1Solver.html#aa57eee18f37e1da2e272b3d90a0dc18d">More...</a><br /></td></tr>
<tr class="separator:aa57eee18f37e1da2e272b3d90a0dc18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfecc9e5d83d6aaf051cbf5f0eaae50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a6cfecc9e5d83d6aaf051cbf5f0eaae50">read_state</a> (std::string file_name)</td></tr>
<tr class="memdesc:a6cfecc9e5d83d6aaf051cbf5f0eaae50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads flow state from file.  <a href="classhexed_1_1Solver.html#a6cfecc9e5d83d6aaf051cbf5f0eaae50">More...</a><br /></td></tr>
<tr class="separator:a6cfecc9e5d83d6aaf051cbf5f0eaae50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90a17cdca662f54ebcb95eae57cca11"><td class="memItemLeft" align="right" valign="top"><a id="af90a17cdca662f54ebcb95eae57cca11"></a>
<a class="el" href="classhexed_1_1Storage__params.html">Storage_params</a>&#160;</td><td class="memItemRight" valign="bottom"><b>storage_params</b> ()</td></tr>
<tr class="separator:af90a17cdca662f54ebcb95eae57cca11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5555e64f39378aa5184742803e94848"><td class="memItemLeft" align="right" valign="top"><a id="ad5555e64f39378aa5184742803e94848"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ad5555e64f39378aa5184742803e94848">snap_faces</a> ()</td></tr>
<tr class="memdesc:ad5555e64f39378aa5184742803e94848"><td class="mdescLeft">&#160;</td><td class="mdescRight">warps the boundary elements such that the element faces coincide with the boundary at their quadrature points. <br /></td></tr>
<tr class="separator:ad5555e64f39378aa5184742803e94848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4739390b8368d46790f68514e379e41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ac4739390b8368d46790f68514e379e41">calc_jacobian</a> (bool <a class="el" href="classhexed_1_1Solver.html#ad5555e64f39378aa5184742803e94848">snap_faces</a>=true)</td></tr>
<tr class="memdesc:ac4739390b8368d46790f68514e379e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Jacobian of all elements based on the current position of the vertices and value of any face warping.  <a href="classhexed_1_1Solver.html#ac4739390b8368d46790f68514e379e41">More...</a><br /></td></tr>
<tr class="separator:ac4739390b8368d46790f68514e379e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa9fd49c2aed6a7dc3080ea09751154"><td class="memItemLeft" align="right" valign="top"><a id="a8aa9fd49c2aed6a7dc3080ea09751154"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a8aa9fd49c2aed6a7dc3080ea09751154">initialize</a> (const <a class="el" href="classhexed_1_1Spacetime__func.html">Spacetime_func</a> &amp;)</td></tr>
<tr class="memdesc:a8aa9fd49c2aed6a7dc3080ea09751154"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the flow state <br /></td></tr>
<tr class="separator:a8aa9fd49c2aed6a7dc3080ea09751154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c2b9dda6d24be8e60635d2a02ea53f"><td class="memItemLeft" align="right" valign="top"><a id="af1c2b9dda6d24be8e60635d2a02ea53f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#af1c2b9dda6d24be8e60635d2a02ea53f">set_art_visc_off</a> ()</td></tr>
<tr class="memdesc:af1c2b9dda6d24be8e60635d2a02ea53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">turns off artificial viscosity <br /></td></tr>
<tr class="separator:af1c2b9dda6d24be8e60635d2a02ea53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070798e655682bd6955336b3e1dc0980"><td class="memItemLeft" align="right" valign="top"><a id="a070798e655682bd6955336b3e1dc0980"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a070798e655682bd6955336b3e1dc0980">set_art_visc_constant</a> (double)</td></tr>
<tr class="memdesc:a070798e655682bd6955336b3e1dc0980"><td class="mdescLeft">&#160;</td><td class="mdescRight">turns on artificial viscosity and initializes coefficient to a uniform value <br /></td></tr>
<tr class="separator:a070798e655682bd6955336b3e1dc0980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf2b549560adebfc4cbdfd9aee72dc0"><td class="memItemLeft" align="right" valign="top"><a id="aadf2b549560adebfc4cbdfd9aee72dc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#aadf2b549560adebfc4cbdfd9aee72dc0">set_art_visc_row_size</a> (int)</td></tr>
<tr class="memdesc:aadf2b549560adebfc4cbdfd9aee72dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the polynomial order of smoothness-based artificial viscosity (must be &lt;= row size of discretization (which is the default)) <br /></td></tr>
<tr class="separator:aadf2b549560adebfc4cbdfd9aee72dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96f1c9ba8f10a3d723d49c7f0c61983"><td class="memItemLeft" align="right" valign="top"><a id="ab96f1c9ba8f10a3d723d49c7f0c61983"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ab96f1c9ba8f10a3d723d49c7f0c61983">set_fix_admissibility</a> (bool)</td></tr>
<tr class="memdesc:ab96f1c9ba8f10a3d723d49c7f0c61983"><td class="mdescLeft">&#160;</td><td class="mdescRight">turns on/off the thermodynamic admissibility-preserving scheme (increases robustness at some computational overhead) <br /></td></tr>
<tr class="separator:ab96f1c9ba8f10a3d723d49c7f0c61983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c6c110ccb0854c196759b3aca149f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ab0c6c110ccb0854c196759b3aca149f8">set_uncertainty</a> (const <a class="el" href="classhexed_1_1Element__func.html">Element_func</a> &amp;func)</td></tr>
<tr class="memdesc:ab0c6c110ccb0854c196759b3aca149f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set <code><a class="el" href="classhexed_1_1Element.html#ad9e510917cc62bf7956c51a251d819fc" title="Pointer to state data at faces. Must be populated by user.">Element::uncertainty</a></code> for each element according to <code>func</code>.  <a href="classhexed_1_1Solver.html#ab0c6c110ccb0854c196759b3aca149f8">More...</a><br /></td></tr>
<tr class="separator:ab0c6c110ccb0854c196759b3aca149f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef508ded435c692dc0165ef546b3fe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#adef508ded435c692dc0165ef546b3fe1">set_uncert_surface_rep</a> (int bc_sn)</td></tr>
<tr class="memdesc:adef508ded435c692dc0165ef546b3fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set uncertainty metric based on surface representation quality.  <a href="classhexed_1_1Solver.html#adef508ded435c692dc0165ef546b3fe1">More...</a><br /></td></tr>
<tr class="separator:adef508ded435c692dc0165ef546b3fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed72189cecdbb2fc8363ac78414c8b4"><td class="memItemLeft" align="right" valign="top"><a id="aaed72189cecdbb2fc8363ac78414c8b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#aaed72189cecdbb2fc8363ac78414c8b4">synch_extruded_uncert</a> ()</td></tr>
<tr class="memdesc:aaed72189cecdbb2fc8363ac78414c8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">set uncertainty of each element to be at least the maximum uncertainty of any elements extruded from it <br /></td></tr>
<tr class="separator:aaed72189cecdbb2fc8363ac78414c8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">time marching</div></td></tr>
<tr class="memitem:ad1b1d8ad6985b4c658724e840c2574f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ad1b1d8ad6985b4c658724e840c2574f5">update</a> ()</td></tr>
<tr class="separator:ad1b1d8ad6985b4c658724e840c2574f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322a721a3a7b02ceb31828f8a99bcabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a322a721a3a7b02ceb31828f8a99bcabb">update_implicit</a> ()</td></tr>
<tr class="memdesc:a322a721a3a7b02ceb31828f8a99bcabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) performs an implicit time step  <a href="classhexed_1_1Solver.html#a322a721a3a7b02ceb31828f8a99bcabb">More...</a><br /></td></tr>
<tr class="separator:a322a721a3a7b02ceb31828f8a99bcabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30814bd93442571d86da6238fd23011b"><td class="memItemLeft" align="right" valign="top"><a id="a30814bd93442571d86da6238fd23011b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compute_residual</b> ()</td></tr>
<tr class="separator:a30814bd93442571d86da6238fd23011b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ba8f9152948f15c94b34edae72f3ad"><td class="memItemLeft" align="right" valign="top"><a id="a14ba8f9152948f15c94b34edae72f3ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a14ba8f9152948f15c94b34edae72f3ad">is_admissible</a> ()</td></tr>
<tr class="memdesc:a14ba8f9152948f15c94b34edae72f3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether flowfield is admissible (e.g. density and energy are positive) <br /></td></tr>
<tr class="separator:a14ba8f9152948f15c94b34edae72f3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f39d1d1312635e9629dfe934804879"><td class="memItemLeft" align="right" valign="top"><a id="a25f39d1d1312635e9629dfe934804879"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a25f39d1d1312635e9629dfe934804879">update_art_visc_smoothness</a> (double advect_length)</td></tr>
<tr class="memdesc:a25f39d1d1312635e9629dfe934804879"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the aritificial viscosity coefficient based on smoothness of the flow variables <br /></td></tr>
<tr class="separator:a25f39d1d1312635e9629dfe934804879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c3a1d0feded2eed22613b309d4a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#adb1c3a1d0feded2eed22613b309d4a36">update_art_visc_elwise</a> (double width, bool pde_based=false)</td></tr>
<tr class="memdesc:adb1c3a1d0feded2eed22613b309d4a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) sets artificial viscosity based on elementwise smoothness  <a href="classhexed_1_1Solver.html#adb1c3a1d0feded2eed22613b309d4a36">More...</a><br /></td></tr>
<tr class="separator:adb1c3a1d0feded2eed22613b309d4a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94354a21cf357c3e8769d47bc064dc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a94354a21cf357c3e8769d47bc064dc65">set_art_visc_admis</a> ()</td></tr>
<tr class="memdesc:a94354a21cf357c3e8769d47bc064dc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">an object providing all available information about the status of the time marching iteration.  <a href="classhexed_1_1Solver.html#a94354a21cf357c3e8769d47bc064dc65">More...</a><br /></td></tr>
<tr class="separator:a94354a21cf357c3e8769d47bc064dc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea45eceb14b28e267f6a6e41398b972"><td class="memItemLeft" align="right" valign="top"><a id="acea45eceb14b28e267f6a6e41398b972"></a>
<a class="el" href="classhexed_1_1Iteration__status.html">Iteration_status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iteration_status</b> ()</td></tr>
<tr class="separator:acea45eceb14b28e267f6a6e41398b972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1203426b9dcf0bdf2e060e7e08907b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a1203426b9dcf0bdf2e060e7e08907b60">reset_counters</a> ()</td></tr>
<tr class="separator:a1203426b9dcf0bdf2e060e7e08907b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">output</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>functions that compute some form of output data </p>
</div></td></tr>
<tr class="memitem:a8d4e90f6b0dc3bb6698cfcae0d7520b7"><td class="memItemLeft" align="right" valign="top"><a id="a8d4e90f6b0dc3bb6698cfcae0d7520b7"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a8d4e90f6b0dc3bb6698cfcae0d7520b7">sample</a> (int ref_level, bool is_deformed, int serial_n, int i_qpoint, const <a class="el" href="classhexed_1_1Qpoint__func.html">Qpoint_func</a> &amp;)</td></tr>
<tr class="memdesc:a8d4e90f6b0dc3bb6698cfcae0d7520b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate arbitrary functions at arbitrary locations <br /></td></tr>
<tr class="separator:a8d4e90f6b0dc3bb6698cfcae0d7520b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68904736b8fc4109d54c79c55d6ecb30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a68904736b8fc4109d54c79c55d6ecb30">sample</a> (int ref_level, bool is_deformed, int serial_n, const <a class="el" href="classhexed_1_1Element__func.html">Element_func</a> &amp;)</td></tr>
<tr class="separator:a68904736b8fc4109d54c79c55d6ecb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9720e91d63ca5329bf6f734af1df3b9"><td class="memItemLeft" align="right" valign="top"><a id="af9720e91d63ca5329bf6f734af1df3b9"></a>
const <a class="el" href="classhexed_1_1Stopwatch__tree.html">Stopwatch_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#af9720e91d63ca5329bf6f734af1df3b9">stopwatch_tree</a> ()</td></tr>
<tr class="memdesc:af9720e91d63ca5329bf6f734af1df3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain performance data <br /></td></tr>
<tr class="separator:af9720e91d63ca5329bf6f734af1df3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dffa9daa037351f998431fb64e8751"><td class="memItemLeft" align="right" valign="top"><a id="aa0dffa9daa037351f998431fb64e8751"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#aa0dffa9daa037351f998431fb64e8751">integral_field</a> (const <a class="el" href="classhexed_1_1Qpoint__func.html">Qpoint_func</a> &amp;integrand)</td></tr>
<tr class="memdesc:aa0dffa9daa037351f998431fb64e8751"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute an integral over the entire flow field at the current time <br /></td></tr>
<tr class="separator:aa0dffa9daa037351f998431fb64e8751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f0c6619ca15591d4247efe75428162"><td class="memItemLeft" align="right" valign="top"><a id="ac7f0c6619ca15591d4247efe75428162"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ac7f0c6619ca15591d4247efe75428162">integral_surface</a> (const <a class="el" href="classhexed_1_1Boundary__func.html">Boundary_func</a> &amp;integrand, int bc_sn)</td></tr>
<tr class="memdesc:ac7f0c6619ca15591d4247efe75428162"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute an integral over all surfaces where a particular boundary condition has been enforced <br /></td></tr>
<tr class="separator:ac7f0c6619ca15591d4247efe75428162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298f1a3dbe9e8feff9967533364e18c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; double, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a298f1a3dbe9e8feff9967533364e18c6">bounds_field</a> (const <a class="el" href="classhexed_1_1Qpoint__func.html">Qpoint_func</a> &amp;, int n_sample=20)</td></tr>
<tr class="separator:a298f1a3dbe9e8feff9967533364e18c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fc1715451ddcdde240d203303055d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#ac2fc1715451ddcdde240d203303055d5">visualize_field</a> (std::string format, std::string name, const <a class="el" href="classhexed_1_1Qpoint__func.html">Qpoint_func</a> &amp;output_variables, int n_sample=10, bool wireframe=false)</td></tr>
<tr class="memdesc:ac2fc1715451ddcdde240d203303055d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a visualization file describing the entire flow field (but not identifying surfaces)  <a href="classhexed_1_1Solver.html#ac2fc1715451ddcdde240d203303055d5">More...</a><br /></td></tr>
<tr class="separator:ac2fc1715451ddcdde240d203303055d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352e80e4b97bb93d4e36f6ee3b83dc85"><td class="memItemLeft" align="right" valign="top"><a id="a352e80e4b97bb93d4e36f6ee3b83dc85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a352e80e4b97bb93d4e36f6ee3b83dc85">visualize_surface</a> (std::string format, std::string name, int bc_sn, const <a class="el" href="classhexed_1_1Boundary__func.html">Boundary_func</a> &amp;, int n_sample=10, bool wireframe=false)</td></tr>
<tr class="memdesc:a352e80e4b97bb93d4e36f6ee3b83dc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a visualization file describing all surfaces where a particular boundary condition has been enforced. <br /></td></tr>
<tr class="separator:a352e80e4b97bb93d4e36f6ee3b83dc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44611b4ef716956a0c97d7cce07627ca"><td class="memItemLeft" align="right" valign="top"><a id="a44611b4ef716956a0c97d7cce07627ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a44611b4ef716956a0c97d7cce07627ca">vis_cart_surf</a> (std::string format, std::string name, int bc_sn, const <a class="el" href="classhexed_1_1Boundary__func.html">Boundary_func</a> &amp;func=<a class="el" href="classhexed_1_1Uncertainty.html">Uncertainty</a>())</td></tr>
<tr class="memdesc:a44611b4ef716956a0c97d7cce07627ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">visualize the Cartesian surface which theoretically exists after element deletion but before any vertex snapping <br /></td></tr>
<tr class="separator:a44611b4ef716956a0c97d7cce07627ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf69424e67d4dc41532bd83eb4eefab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a5bf69424e67d4dc41532bd83eb4eefab">vis_lts_constraints</a> (std::string format, std::string name, int n_sample=10)</td></tr>
<tr class="memdesc:a5bf69424e67d4dc41532bd83eb4eefab"><td class="mdescLeft">&#160;</td><td class="mdescRight">visualize the local time step constraints imposed by convection and diffusion, respectively  <a href="classhexed_1_1Solver.html#a5bf69424e67d4dc41532bd83eb4eefab">More...</a><br /></td></tr>
<tr class="separator:a5bf69424e67d4dc41532bd83eb4eefab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3dc816dfed5e670f9aee3d801fc80f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Solver.html#a3c3dc816dfed5e670f9aee3d801fc80f">write_state</a> (std::string file_name)</td></tr>
<tr class="memdesc:a3c3dc816dfed5e670f9aee3d801fc80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes flow state to file.  <a href="classhexed_1_1Solver.html#a3c3dc816dfed5e670f9aee3d801fc80f">More...</a><br /></td></tr>
<tr class="separator:a3c3dc816dfed5e670f9aee3d801fc80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main class that basically runs everything. </p>
<p>If you want to run a simulation with hexed through the C++ API, your workflow should be roughly the following:</p><ol type="1">
<li>construct a <code><a class="el" href="classhexed_1_1Solver.html" title="The main class that basically runs everything.">Solver</a></code> object</li>
<li>interact with the <code><a class="el" href="classhexed_1_1Solver.html#ab105c8a279cc945de54857632424aca7" title="Reference to the namespace which can be used to edit user-defined parameters.">mesh()</a></code> object to build the mesh topology and/or snap vertices</li>
<li>call <code><a class="el" href="classhexed_1_1Solver.html#ac4739390b8368d46790f68514e379e41" title="compute the Jacobian of all elements based on the current position of the vertices and value of any f...">calc_jacobian()</a></code> to initialize internal parameters based on the mesh</li>
<li>call <code><a class="el" href="classhexed_1_1Solver.html#a8aa9fd49c2aed6a7dc3080ea09751154" title="set the flow state">initialize()</a></code> to initialize the flow state</li>
<li>call <code><a class="el" href="classhexed_1_1Solver.html#ad1b1d8ad6985b4c658724e840c2574f5">update()</a></code> repeatedly to progress the simulation</li>
<li>call the some of the functions in output section to get the data you want from the simulation </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac7fe06e75e037aaa83efcbecb586214d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fe06e75e037aaa83efcbecb586214d">&#9670;&nbsp;</a></span>Solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hexed::Solver::Solver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>root_mesh_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local_time_stepping</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Transport__model.html">Transport_model</a>&#160;</td>
          <td class="paramname"><em>viscosity_model</em> = <code><a class="el" href="namespacehexed.html#adfc99352c3a0cc7f6e721448c6a8d3da">inviscid</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Transport__model.html">Transport_model</a>&#160;</td>
          <td class="paramname"><em>thermal_conductivity_model</em> = <code><a class="el" href="namespacehexed.html#adfc99352c3a0cc7f6e721448c6a8d3da">inviscid</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhexed_1_1Namespace.html">Namespace</a> &gt;&#160;</td>
          <td class="paramname"><em>space</em> = <code>std::make_shared&lt;<a class="el" href="classhexed_1_1Namespace.html">Namespace</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhexed_1_1Printer.html">Printer</a> &gt;&#160;</td>
          <td class="paramname"><em>printer</em> = <code>std::make_shared&lt;<a class="el" href="classhexed_1_1Stream__printer.html">Stream_printer</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_dim</td><td>number of dimensions </td></tr>
    <tr><td class="paramname">row_size</td><td>row size of the basis (see <a class="el" href="conventions.html#Terminology">Terminology</a>) </td></tr>
    <tr><td class="paramname">root_mesh_size</td><td>sets the value of <code>Mesh::root_mesh_size()</code> </td></tr>
    <tr><td class="paramname">local_time_stepping</td><td>whether to use local or global time stepping </td></tr>
    <tr><td class="paramname">viscosity_model</td><td>determines whether the flow has viscosity (natural, not artificial) and if so, how it depends on temperature </td></tr>
    <tr><td class="paramname">thermal_conductivity_model</td><td>determines whether the flow has thermal conductivity and if so, how it depends on temperature </td></tr>
    <tr><td class="paramname">space</td><td><code><a class="el" href="classhexed_1_1Namespace.html">Namespace</a></code> containing any user-defined parameters affecting the behavior of the solver. If no namespace is provided, a new blank namespace is creqated. Any optional parameters which are not found in the namespace shall be created with their default values. </td></tr>
    <tr><td class="paramname">printer</td><td>what to do with any information the solver wants to print for the user to see </td></tr>
    <tr><td class="paramname">implicit</td><td>if <code>true</code>, allocate storage for solving with an implicit method (experimental feature &ndash; not ready for production use)</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>viscosity_model</code> and <code>thermal_conductivity_model</code> are both <code>inviscid</code> <em>and</em> you don't turn on artificial viscosity, you will be solving the pure inviscid flow equations. Otherwise, you will be solving the viscous flow equations using the LDG scheme, potentially with some of the diffusion coefficients (artificial viscosity, natural viscosity, thermal conductivity) set to zero. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a298f1a3dbe9e8feff9967533364e18c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298f1a3dbe9e8feff9967533364e18c6">&#9670;&nbsp;</a></span>bounds_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; double, 2 &gt; &gt; hexed::Solver::bounds_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhexed_1_1Qpoint__func.html">Qpoint_func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_sample</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the min and max of variables over entire flow field. layout: <code>{{var0_min, var0_max}, {var1_min, var1_max}, ...}</code> bounds are approximated by uniformly sampling a block <code>n_sample</code>-on-a-side in each element </p>

</div>
</div>
<a id="ac4739390b8368d46790f68514e379e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4739390b8368d46790f68514e379e41">&#9670;&nbsp;</a></span>calc_jacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::calc_jacobian </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snap_faces</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Jacobian of all elements based on the current position of the vertices and value of any face warping. </p>
<p><a class="el" href="classhexed_1_1Mesh.html">Mesh</a> topology must be valid (no duplicate or missing connections) before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snap_faces</td><td>if <code>true</code>, this function will go ahead and perform face snapping for you </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab105c8a279cc945de54857632424aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab105c8a279cc945de54857632424aca7">&#9670;&nbsp;</a></span>mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Mesh.html">Mesh</a> &amp; hexed::Solver::mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to the namespace which can be used to edit user-defined parameters. </p>
<p>fetch the <code><a class="el" href="classhexed_1_1Mesh.html">Mesh</a></code>.</p>
<p>An object the user can use to build the mesh. Note that whenever elements are added, the flow state, and Jacobian are uninitialized, the time step scale is uniformly 1, and the mesh quality may be poor. The functions below must be used to complete the setup before any flow calculation can begin. </p>

</div>
</div>
<a id="aa57eee18f37e1da2e272b3d90a0dc18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57eee18f37e1da2e272b3d90a0dc18d">&#9670;&nbsp;</a></span>read_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::read_mesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> * &gt;&#160;</td>
          <td class="paramname"><em>extremal_bcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Surface__geom.html">Surface_geom</a> *&#160;</td>
          <td class="paramname"><em>geom</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhexed_1_1Flow__bc.html">Flow_bc</a> *&#160;</td>
          <td class="paramname"><em>surface_bc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads mesh from file </p>
<p>Wipes old mesh and flow state. File must be in the native (HDF5-based) mesh format, which you can generate from a previous simulation with <code>Mesh::write</code>. <code>.mesh.h5</code> will be automatically appended to <code>file_name</code>. New mesh must match the <code><a class="el" href="classhexed_1_1Storage__params.html" title="the parameters of the numerical scheme that are necessary to determine storage requirements">Storage_params</a></code> of the current one, but the root mesh size will be replaced with that of the new mesh. You still have to <code>initialize</code> (even if you already did before reading the new mesh), but you don't have to <code>calc_jacobian</code> unless you further modify the mesh. </p>

</div>
</div>
<a id="a6cfecc9e5d83d6aaf051cbf5f0eaae50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfecc9e5d83d6aaf051cbf5f0eaae50">&#9670;&nbsp;</a></span>read_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::read_state </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads flow state from file. </p>
<p>Essentially a substitute for <code>initialize</code>. <code>.state.h5</code> will be appended to file name </p>

</div>
</div>
<a id="a1203426b9dcf0bdf2e060e7e08907b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1203426b9dcf0bdf2e060e7e08907b60">&#9670;&nbsp;</a></span>reset_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::reset_counters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>reset any variables in <code>iteration_status()</code> that count something since the last call to <code><a class="el" href="classhexed_1_1Solver.html#a1203426b9dcf0bdf2e060e7e08907b60">reset_counters()</a></code> (e.g. number of artificial viscosity iterations) </p>

</div>
</div>
<a id="a68904736b8fc4109d54c79c55d6ecb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68904736b8fc4109d54c79c55d6ecb30">&#9670;&nbsp;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; hexed::Solver::sample </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_deformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>serial_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhexed_1_1Element__func.html">Element_func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a94354a21cf357c3e8769d47bc064dc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94354a21cf357c3e8769d47bc064dc65">&#9670;&nbsp;</a></span>set_art_visc_admis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::set_art_visc_admis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an object providing all available information about the status of the time marching iteration. </p>
<p>The <code><a class="el" href="classhexed_1_1Iteration__status.html#ad99f044b551ea80b1ed04aac71b07cf8" title="Unix epoch time that set_time was called.">Iteration_status::start_time</a></code> member will refer to when the <code><a class="el" href="classhexed_1_1Solver.html" title="The main class that basically runs everything.">Solver</a></code> object was created (specifically at the start of the <code><a class="el" href="classhexed_1_1Solver.html#ac7fe06e75e037aaa83efcbecb586214d">Solver::Solver</a></code> body).</p>
<p>set the Laplacian artificial viscosity to a minimal value that will encourage thermodynamic admissibility </p>

</div>
</div>
<a id="adef508ded435c692dc0165ef546b3fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef508ded435c692dc0165ef546b3fe1">&#9670;&nbsp;</a></span>set_uncert_surface_rep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::set_uncert_surface_rep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bc_sn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set uncertainty metric based on surface representation quality. </p>
<p>For all deformed elements contacting the boundary specified by <code>bc_sn</code>, computes the unit surface normals at the faces and compares to neighboring elements. <code><a class="el" href="classhexed_1_1Element.html#ad9e510917cc62bf7956c51a251d819fc" title="Pointer to state data at faces. Must be populated by user.">Element::uncertainty</a></code> is set to the total difference between unit normals with all neighbors, where in 3D the total on each edge is computed by Gaussian quadrature in reference space. </p><dl class="section note"><dt>Note</dt><dd>Connections between deformed elements and Cartesian elements are ignored. Fully Cartesian connections trivially contribute zero to this metric of uncertainty. </dd></dl>

</div>
</div>
<a id="ab0c6c110ccb0854c196759b3aca149f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c6c110ccb0854c196759b3aca149f8">&#9670;&nbsp;</a></span>set_uncertainty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::set_uncertainty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhexed_1_1Element__func.html">Element_func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set <code><a class="el" href="classhexed_1_1Element.html#ad9e510917cc62bf7956c51a251d819fc" title="Pointer to state data at faces. Must be populated by user.">Element::uncertainty</a></code> for each element according to <code>func</code>. </p>
<p><a class="el" href="classhexed_1_1Uncertainty.html" title="function to fetch the value of the uncertainty member of the Element.">Uncertainty</a> metric can be evaluated via <code>sample(ref_level, is_deformed, serial_n, Uncertainty())</code>. This function does some additional work to enforce some conditions on the uncertainty of neighboring elements. Thus, use this function rather than just <code>sample(ref_level, is_deformed, serial_n, func)</code> directly. </p>

</div>
</div>
<a id="ad1b1d8ad6985b4c658724e840c2574f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b1d8ad6985b4c658724e840c2574f5">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>March the simulation forward by a time step equal to <code>time_step</code> or <code>max_safety</code> times the estimated maximum stable time step, whichever is smaller. Also, the safety factor is <b>not</b> the same as the CFL number (it is scaled by the max allowable CFL for the chosen DG scheme which is often O(1e-2)). </p>

</div>
</div>
<a id="adb1c3a1d0feded2eed22613b309d4a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1c3a1d0feded2eed22613b309d4a36">&#9670;&nbsp;</a></span>update_art_visc_elwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::update_art_visc_elwise </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pde_based</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) sets artificial viscosity based on elementwise smoothness </p>
<p>Based on the work of Persson et al. on artificial viscosity with elementwise smoothness indicators. Implemented primarily for evaluating the difference between grid-independent artificial viscosity and conventional methods. </p><dl class="section warning"><dt>Warning</dt><dd>Not recommended for use in practice. Use <code><a class="el" href="classhexed_1_1Solver.html#a25f39d1d1312635e9629dfe934804879" title="updates the aritificial viscosity coefficient based on smoothness of the flow variables">Solver::update_art_visc_smoothness</a></code>, which was developed to supplant this type of approach. </dd></dl>

</div>
</div>
<a id="a322a721a3a7b02ceb31828f8a99bcabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322a721a3a7b02ceb31828f8a99bcabb">&#9670;&nbsp;</a></span>update_implicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::update_implicit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) performs an implicit time step </p>
<dl class="section warning"><dt>Warning</dt><dd>Experimental! Interesting for reasearch, not effective in practice (yet, anyway). </dd></dl>

</div>
</div>
<a id="a5bf69424e67d4dc41532bd83eb4eefab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf69424e67d4dc41532bd83eb4eefab">&#9670;&nbsp;</a></span>vis_lts_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::vis_lts_constraints </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_sample</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>visualize the local time step constraints imposed by convection and diffusion, respectively </p>
<dl class="section warning"><dt>Warning</dt><dd>This function overwrites the reference state, which will invalidate any residual evaluation until <code>update</code> is called again. </dd></dl>

</div>
</div>
<a id="ac2fc1715451ddcdde240d203303055d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fc1715451ddcdde240d203303055d5">&#9670;&nbsp;</a></span>visualize_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::visualize_field </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhexed_1_1Qpoint__func.html">Qpoint_func</a> &amp;&#160;</td>
          <td class="paramname"><em>output_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_sample</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wireframe</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a visualization file describing the entire flow field (but not identifying surfaces) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Which format to write the visualization file in. Accepted values are <code>"xdmf"</code> and <code>"tecplot"</code> </td></tr>
    <tr><td class="paramname">name</td><td>name of file to write (not including extension) </td></tr>
    <tr><td class="paramname">output_variables</td><td>what variables to write </td></tr>
    <tr><td class="paramname">n_sample</td><td>each element will contain an <code>n_sample</code> by <code>n_sample</code> array of uniformly-spaced sample points </td></tr>
    <tr><td class="paramname">wireframe</td><td>if <code>true</code>, visualize the mesh edges as a wireframe instead of the filled surface/solid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c3dc816dfed5e670f9aee3d801fc80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3dc816dfed5e670f9aee3d801fc80f">&#9670;&nbsp;</a></span>write_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Solver::write_state </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes flow state to file. </p>
<p><code>.state.h5</code> will be appended to <code>file_name</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/micaiah/orgs/artlab/hexed/include/Solver.hpp</li>
<li>/home/micaiah/orgs/artlab/hexed/src/Solver.cpp</li>
<li>/home/micaiah/orgs/artlab/hexed/src/Solver_snap_faces.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehexed.html">hexed</a></li><li class="navelem"><a class="el" href="classhexed_1_1Solver.html">Solver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
