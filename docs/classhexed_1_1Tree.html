<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hexed: hexed::Tree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hexed
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhexed_1_1Tree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classhexed_1_1Tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hexed::Tree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Bin/quad/octree data structure.  
 <a href="classhexed_1_1Tree.html#details">More...</a></p>

<p><code>#include &lt;Tree.hpp&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hexed::Tree:</div>
<div class="dyncontent">
<div class="center"><img src="classhexed_1_1Tree__coll__graph.png" border="0" usemap="#ahexed_1_1Tree_coll__map" alt="Collaboration graph"/></div>
<map name="ahexed_1_1Tree_coll__map" id="ahexed_1_1Tree_coll__map">
<area shape="rect" title="Bin/quad/octree data structure." alt="" coords="2885,193,2981,220"/>
<area shape="rect" href="classhexed_1_1Deformed__element.html" title="Represents an Element which is not a perfect axis&#45;aligned square/cube." alt="" coords="2577,151,2772,177"/>
<area shape="rect" href="classhexed_1_1Element.html" title="Stores data associated with one mesh element." alt="" coords="2405,151,2528,177"/>
<area shape="rect" href="classhexed_1_1Kernel__element.html" title="Represents an element as the kernels see it." alt="" coords="2127,5,2298,32"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/classEigen_1_1Matrix.html" title=" " alt="" coords="2121,56,2304,112"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/classEigen_1_1PlainObjectBase.html" title=" " alt="" coords="1809,56,2072,112"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/structEigen_1_1doxygen_1_1dense__xpr__base__dispatcher_3_01Matrix_3_01__Scalar_00_01__Rows_00_0116fa1ae814876cf66b62915b437740e6.html" title=" " alt="" coords="1552,41,1760,127"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/classEigen_1_1MatrixBase.html" title=" " alt="" coords="1352,63,1503,105"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html" title=" " alt="" coords="1100,71,1303,97"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html" title=" " alt="" coords="800,63,1051,105"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html" title=" " alt="" coords="540,63,751,105"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html" title=" " alt="" coords="252,63,491,105"/>
<area shape="rect" target="_parent" href="https://eigen.tuxfamily.org/dox/structEigen_1_1EigenBase.html" title=" " alt="" coords="5,71,203,97"/>
<area shape="rect" href="classhexed_1_1Mutual__ptr.html" title=" " alt="" coords="2125,136,2300,192"/>
<area shape="rect" href="classhexed_1_1Storage__params.html" title="the parameters of the numerical scheme that are necessary to determine storage requirements" alt="" coords="2125,216,2300,243"/>
<area shape="rect" href="classhexed_1_1Lock.html" title="wrapper for OpenMP lock routines." alt="" coords="2163,267,2262,293"/>
<area shape="rect" href="classhexed_1_1Mutual__ptr.html" title=" " alt="" coords="2599,201,2750,257"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab7d776dda57115b407f5791154e6823c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#ab7d776dda57115b407f5791154e6823c">Tree</a> (int n_dim, double root_size, <a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt; origin=<a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;::Zero(3))</td></tr>
<tr class="memdesc:ab7d776dda57115b407f5791154e6823c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the root element of a tree.  <a href="classhexed_1_1Tree.html#ab7d776dda57115b407f5791154e6823c">More...</a><br /></td></tr>
<tr class="separator:ab7d776dda57115b407f5791154e6823c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">basic instance information</div></td></tr>
<tr class="memitem:a7c70a5559293823f039a01ff4c0b4213"><td class="memItemLeft" align="right" valign="top"><a id="a7c70a5559293823f039a01ff4c0b4213"></a>
<a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>origin</b> () const</td></tr>
<tr class="separator:a7c70a5559293823f039a01ff4c0b4213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5332a019fcc9f6c7a65002727d0418"><td class="memItemLeft" align="right" valign="top"><a id="ace5332a019fcc9f6c7a65002727d0418"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#ace5332a019fcc9f6c7a65002727d0418">refinement_level</a> () const</td></tr>
<tr class="memdesc:ace5332a019fcc9f6c7a65002727d0418"><td class="mdescLeft">&#160;</td><td class="mdescRight">how many calls of <code>refine</code> were required to generate this element. E.g. the root element has refinement level 0. <br /></td></tr>
<tr class="separator:ace5332a019fcc9f6c7a65002727d0418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963fb816d2a1dff71deb021a4bfe7139"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a963fb816d2a1dff71deb021a4bfe7139">coordinates</a> () const</td></tr>
<tr class="memdesc:a963fb816d2a1dff71deb021a4bfe7139"><td class="mdescLeft">&#160;</td><td class="mdescRight">coordinates of vertex 0 of this element relative to <code>origin</code> in multiples of the cell size  <a href="classhexed_1_1Tree.html#a963fb816d2a1dff71deb021a4bfe7139">More...</a><br /></td></tr>
<tr class="separator:a963fb816d2a1dff71deb021a4bfe7139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9c3164a257474060dbf77dbb707e37"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a0b9c3164a257474060dbf77dbb707e37">nominal_size</a> () const</td></tr>
<tr class="memdesc:a0b9c3164a257474060dbf77dbb707e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">the size of the element in physical coordinates (before any deformation of the actual DG element)  <a href="classhexed_1_1Tree.html#a0b9c3164a257474060dbf77dbb707e37">More...</a><br /></td></tr>
<tr class="separator:a0b9c3164a257474060dbf77dbb707e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54d5761469e23f1842acfb743c48b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#ad54d5761469e23f1842acfb743c48b15">nominal_position</a> () const</td></tr>
<tr class="memdesc:ad54d5761469e23f1842acfb743c48b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">the position of vertex 0 of the element in physical coordinates  <a href="classhexed_1_1Tree.html#ad54d5761469e23f1842acfb743c48b15">More...</a><br /></td></tr>
<tr class="separator:ad54d5761469e23f1842acfb743c48b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55319ba2f5602a536098c559766937ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a55319ba2f5602a536098c559766937ec">center</a> () const</td></tr>
<tr class="separator:a55319ba2f5602a536098c559766937ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">parent/child status</div></td></tr>
<tr class="memitem:a71a9b66dc5274ec6b64655bfeafb0a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a71a9b66dc5274ec6b64655bfeafb0a90">parent</a> ()</td></tr>
<tr class="separator:a71a9b66dc5274ec6b64655bfeafb0a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907c6f923732b8dd9baaf0b2dd23db4c"><td class="memItemLeft" align="right" valign="top"><a id="a907c6f923732b8dd9baaf0b2dd23db4c"></a>
std::vector&lt; <a class="el" href="classhexed_1_1Tree.html">Tree</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a907c6f923732b8dd9baaf0b2dd23db4c">children</a> ()</td></tr>
<tr class="memdesc:a907c6f923732b8dd9baaf0b2dd23db4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this cell has been refined, then this vector contains pointers to its children. If it has not, the vector is empty. <br /></td></tr>
<tr class="separator:a907c6f923732b8dd9baaf0b2dd23db4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339ca339a0d3f4fdfaa062daf281aa7d"><td class="memItemLeft" align="right" valign="top"><a id="a339ca339a0d3f4fdfaa062daf281aa7d"></a>
<a class="el" href="classhexed_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a339ca339a0d3f4fdfaa062daf281aa7d">root</a> ()</td></tr>
<tr class="memdesc:a339ca339a0d3f4fdfaa062daf281aa7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">fetch the root element of this tree <br /></td></tr>
<tr class="separator:a339ca339a0d3f4fdfaa062daf281aa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53d05ae7417588ff7c52b5850a1bf98"><td class="memItemLeft" align="right" valign="top"><a id="ac53d05ae7417588ff7c52b5850a1bf98"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#ac53d05ae7417588ff7c52b5850a1bf98">is_root</a> () const</td></tr>
<tr class="memdesc:ac53d05ae7417588ff7c52b5850a1bf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">gives the same result as <code>!parent()</code> <br /></td></tr>
<tr class="separator:ac53d05ae7417588ff7c52b5850a1bf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e2c3c06b4328f1ef0f0c7da295bc8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a71e2c3c06b4328f1ef0f0c7da295bc8a">is_leaf</a> () const</td></tr>
<tr class="separator:a71e2c3c06b4328f1ef0f0c7da295bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">modifiers</div></td></tr>
<tr class="memitem:a1742fe161314764b7904dd28644ae716"><td class="memItemLeft" align="right" valign="top"><a id="a1742fe161314764b7904dd28644ae716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a1742fe161314764b7904dd28644ae716">refine</a> ()</td></tr>
<tr class="memdesc:a1742fe161314764b7904dd28644ae716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates \(2^{\verb|n_dim|}\) child elements with refinement level one greater than this element and cover the same volume. Must be leaf. <br /></td></tr>
<tr class="separator:a1742fe161314764b7904dd28644ae716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da3629aaff2a42eb188d8e02ad6342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a12da3629aaff2a42eb188d8e02ad6342">unrefine</a> ()</td></tr>
<tr class="separator:a12da3629aaff2a42eb188d8e02ad6342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">traversing functions</div></td></tr>
<tr class="memitem:aaaf2e8869d649001b51a1f000e57028e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#aaaf2e8869d649001b51a1f000e57028e">find_leaf</a> (int ref_level, <a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a> coords, <a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a> bias=<a class="elRef" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#a422ddeef58bedc7bddb1d4357688d761">Eigen::VectorXi::Zero</a>(3))</td></tr>
<tr class="memdesc:aaaf2e8869d649001b51a1f000e57028e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a leaf which contains a specified set of integer coordinates.  <a href="classhexed_1_1Tree.html#aaaf2e8869d649001b51a1f000e57028e">More...</a><br /></td></tr>
<tr class="separator:aaaf2e8869d649001b51a1f000e57028e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ae23c2b059321baacc4f203beaa852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a23ae23c2b059321baacc4f203beaa852">find_leaf</a> (<a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt; <a class="el" href="classhexed_1_1Tree.html#ad54d5761469e23f1842acfb743c48b15">nominal_position</a>)</td></tr>
<tr class="memdesc:a23ae23c2b059321baacc4f203beaa852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a leaf which contains a specified point in physical space.  <a href="classhexed_1_1Tree.html#a23ae23c2b059321baacc4f203beaa852">More...</a><br /></td></tr>
<tr class="separator:a23ae23c2b059321baacc4f203beaa852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8742470dfa8231138ec0512918af6002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhexed_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a8742470dfa8231138ec0512918af6002">find_neighbor</a> (<a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a> direction)</td></tr>
<tr class="memdesc:a8742470dfa8231138ec0512918af6002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a leaf neighbor of this element in the specified direction.  <a href="classhexed_1_1Tree.html#a8742470dfa8231138ec0512918af6002">More...</a><br /></td></tr>
<tr class="separator:a8742470dfa8231138ec0512918af6002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f09ef5a27c3ed084944799e18a1414"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classhexed_1_1Tree.html">Tree</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a29f09ef5a27c3ed084944799e18a1414">find_neighbors</a> (<a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a> direction)</td></tr>
<tr class="memdesc:a29f09ef5a27c3ed084944799e18a1414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all leaf neighbors of this element in a specified direction.  <a href="classhexed_1_1Tree.html#a29f09ef5a27c3ed084944799e18a1414">More...</a><br /></td></tr>
<tr class="separator:a29f09ef5a27c3ed084944799e18a1414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319484112583969e76afab16b8b9894c"><td class="memItemLeft" align="right" valign="top"><a id="a319484112583969e76afab16b8b9894c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a319484112583969e76afab16b8b9894c">count</a> ()</td></tr>
<tr class="memdesc:a319484112583969e76afab16b8b9894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of tree elements descended from this tree (including itself) <br /></td></tr>
<tr class="separator:a319484112583969e76afab16b8b9894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5cbb45f2a14e4f6afa661d81bad58316"><td class="memItemLeft" align="right" valign="top"><a id="a5cbb45f2a14e4f6afa661d81bad58316"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>n_dim</b></td></tr>
<tr class="separator:a5cbb45f2a14e4f6afa661d81bad58316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef01b66b60ed9cd772bad96ce432cb8"><td class="memItemLeft" align="right" valign="top"><a id="a2ef01b66b60ed9cd772bad96ce432cb8"></a>
<a class="el" href="classhexed_1_1Mutual__ptr.html">Mutual_ptr</a>&lt; <a class="el" href="classhexed_1_1Tree.html">Tree</a>, <a class="el" href="classhexed_1_1Element.html">Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a2ef01b66b60ed9cd772bad96ce432cb8">elem</a></td></tr>
<tr class="memdesc:a2ef01b66b60ed9cd772bad96ce432cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classhexed_1_1Element.html" title="Stores data associated with one mesh element.">Element</a></code> generated from this tree (to be managed by the user of this class) <br /></td></tr>
<tr class="separator:a2ef01b66b60ed9cd772bad96ce432cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b765d4800c4b76f004c8747efd5fad4"><td class="memItemLeft" align="right" valign="top"><a id="a9b765d4800c4b76f004c8747efd5fad4"></a>
<a class="el" href="classhexed_1_1Deformed__element.html">Deformed_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a9b765d4800c4b76f004c8747efd5fad4">def_elem</a> = nullptr</td></tr>
<tr class="memdesc:a9b765d4800c4b76f004c8747efd5fad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>elem</code> points to a deformed element, this can also be set to allow it to be accessed as deformed <br /></td></tr>
<tr class="separator:a9b765d4800c4b76f004c8747efd5fad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dc989cdd31b53a29d54e76f90fc72f"><td class="memItemLeft" align="right" valign="top"><a id="ad7dc989cdd31b53a29d54e76f90fc72f"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#ad7dc989cdd31b53a29d54e76f90fc72f">misc_data</a></td></tr>
<tr class="memdesc:ad7dc989cdd31b53a29d54e76f90fc72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">As the name implies, used to store whatever random information you want. <br /></td></tr>
<tr class="separator:ad7dc989cdd31b53a29d54e76f90fc72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">flood fill algorithm</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp56f676d2f6bab74efb167867eba4acb3"></a>The flood fill algorithm sets an integer "status" attribute of a connected group of leaf elements. This is useful to distinguish inside, outside, and boundary elements in the mesh. A status value of <code>unprocessed</code> indicates an element that has not been processed by the flood fill. Identify the boundary elements by manually setting their status to any other value. Then, to identify a connected region bounded by the elements you have set, invoke <code><a class="el" href="classhexed_1_1Tree.html#ace29bf94fd7bb34c80fc3e8665141880" title="Executes flood fill algorithm starting with this element.">flood_fill()</a></code> on one of the elements in the region you want. </p>
</td></tr>
<tr class="memitem:aa8882d07250490bf7744c0e12981b541"><td class="memItemLeft" align="right" valign="top"><a id="aa8882d07250490bf7744c0e12981b541"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>unprocessed</b> = -1</td></tr>
<tr class="separator:aa8882d07250490bf7744c0e12981b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00bd31b3a63b78b0ea4ed4fac807d77"><td class="memItemLeft" align="right" valign="top"><a id="af00bd31b3a63b78b0ea4ed4fac807d77"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#af00bd31b3a63b78b0ea4ed4fac807d77">get_status</a> ()</td></tr>
<tr class="memdesc:af00bd31b3a63b78b0ea4ed4fac807d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the flood fill status value (initialized to <code>unprocessed</code>). <br /></td></tr>
<tr class="separator:af00bd31b3a63b78b0ea4ed4fac807d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6d620781cfd37c41f145ae97208ab8"><td class="memItemLeft" align="right" valign="top"><a id="a3b6d620781cfd37c41f145ae97208ab8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a3b6d620781cfd37c41f145ae97208ab8">set_status</a> (int)</td></tr>
<tr class="memdesc:a3b6d620781cfd37c41f145ae97208ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the flood fill status value <br /></td></tr>
<tr class="separator:a3b6d620781cfd37c41f145ae97208ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29bf94fd7bb34c80fc3e8665141880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#ace29bf94fd7bb34c80fc3e8665141880">flood_fill</a> (int status)</td></tr>
<tr class="memdesc:ace29bf94fd7bb34c80fc3e8665141880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes flood fill algorithm starting with this element.  <a href="classhexed_1_1Tree.html#ace29bf94fd7bb34c80fc3e8665141880">More...</a><br /></td></tr>
<tr class="separator:ace29bf94fd7bb34c80fc3e8665141880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779a27b020bc62bc8088c0fa04edddd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhexed_1_1Tree.html#a779a27b020bc62bc8088c0fa04edddd9">clear_status</a> ()</td></tr>
<tr class="separator:a779a27b020bc62bc8088c0fa04edddd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Bin/quad/octree data structure. </p>
<p>Used to compute the mesh topology, i.e. which cells are connected to which and how. Only knows about the nominal position and size of elements, not deformity or flow variables. In other words, this structure represents the Cartesian elements before any deformation happens. This structure also does not know about any extrusion (for now, anyway). A few general notes about the API:</p><ul>
<li>Each <code><a class="el" href="classhexed_1_1Tree.html" title="Bin/quad/octree data structure.">Tree</a></code> instance is referred to as an "element" of the tree. It's <code><a class="el" href="classhexed_1_1Tree.html#a907c6f923732b8dd9baaf0b2dd23db4c" title="If this cell has been refined, then this vector contains pointers to its children....">children()</a></code>, their <code><a class="el" href="classhexed_1_1Tree.html#a907c6f923732b8dd9baaf0b2dd23db4c" title="If this cell has been refined, then this vector contains pointers to its children....">children()</a></code>, etc. are referred to as its "descendents". It's <code><a class="el" href="classhexed_1_1Tree.html#a71a9b66dc5274ec6b64655bfeafb0a90">parent()</a></code>, their <code><a class="el" href="classhexed_1_1Tree.html#a71a9b66dc5274ec6b64655bfeafb0a90">parent()</a></code>s, etc. are referred to as its "ancestors".</li>
<li>Most of the recursive traversal functions look only down, not up. That is, they search the element you invoke them on and all its descendents, but not its ancestors. Thus if you want to search the whole tree, you should call the function on the root (which hopefully you would have done anyway). The notable exception is <code><a class="el" href="classhexed_1_1Tree.html#a8742470dfa8231138ec0512918af6002" title="Finds a leaf neighbor of this element in the specified direction.">find_neighbor()</a></code>, which <em>does</em> go all the way up to the root before starting the recursive search.</li>
<li><a class="el" href="classhexed_1_1Tree.html" title="Bin/quad/octree data structure.">Tree</a> elements are never reallocated, so any pointer to a tree element remains valid when the tree is modified as long as that element is not deleted with <code><a class="el" href="classhexed_1_1Tree.html#a12da3629aaff2a42eb188d8e02ad6342">unrefine()</a></code>. Of course, <code><a class="el" href="classhexed_1_1Tree.html#a12da3629aaff2a42eb188d8e02ad6342">unrefine()</a></code> deletes tree elements so it can create dangling pointers.</li>
</ul>
<p><b>Thread safety</b></p>
<p>Multiple calls to traversing functions may be made concurrently, and multiple elements may be modified concurrently. However, concurrent attempts to modify the same element (directly or indirectly) or modifying elements and calling a traversing function concurrently may result in data races. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab7d776dda57115b407f5791154e6823c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d776dda57115b407f5791154e6823c">&#9670;&nbsp;</a></span>Tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hexed::Tree::Tree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>root_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;&#160;</td>
          <td class="paramname"><em>origin</em> = <code><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;::Zero(3)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the root element of a tree. </p>
<p>All other elements will be descendents of this one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_dim</td><td>number of spatial dimensions of the tree. <code>n_dim = 1</code> =&gt; bintree, <code>n_dim = 2</code> =&gt; quadtree, etc. </td></tr>
    <tr><td class="paramname">root_size</td><td>sets the <code>nominal_size</code> of the root element. </td></tr>
    <tr><td class="paramname">origin</td><td>sets the origin of the physical coordinate system. That is, the root element will have <code><a class="el" href="classhexed_1_1Tree.html#ad54d5761469e23f1842acfb743c48b15" title="the position of vertex 0 of the element in physical coordinates">nominal_position()</a> == origin()</code>. <code>origin</code> must have at least <code>n_dim</code> elements, and only the first <code>n_dim</code> will be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a55319ba2f5602a536098c559766937ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55319ba2f5602a536098c559766937ec">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a> hexed::Tree::center </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the center of this tree element </p>

</div>
</div>
<a id="a779a27b020bc62bc8088c0fa04edddd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779a27b020bc62bc8088c0fa04edddd9">&#9670;&nbsp;</a></span>clear_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Tree::clear_status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sets the flood fill status of this and all child elements to <code>unprocessed</code> </p>

</div>
</div>
<a id="a963fb816d2a1dff71deb021a4bfe7139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963fb816d2a1dff71deb021a4bfe7139">&#9670;&nbsp;</a></span>coordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a> hexed::Tree::coordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>coordinates of vertex 0 of this element relative to <code>origin</code> in multiples of the cell size </p>
<p>Combined with the <code>refinement_level</code>, this is the minimal amount of information required to locate a tree element. By vertex 0 we mean the vertex with the smallest coordinates in every dimension, e.g. the lower left corner in 2D. For example, in 2D, the root element has coordinates {0, 0}. The root element's children will have coordinates {0, 0}, {0, 1}, {1, 0}, {1, 1}. If those cells are all refined, their children will have coordinates ranging from {0, 0}, to {3, 3}. </p>

</div>
</div>
<a id="aaaf2e8869d649001b51a1f000e57028e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf2e8869d649001b51a1f000e57028e">&#9670;&nbsp;</a></span>find_leaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Tree.html">Tree</a> * hexed::Tree::find_leaf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a>&#160;</td>
          <td class="paramname"><em>bias</em> = <code><a class="elRef" href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#a422ddeef58bedc7bddb1d4357688d761">Eigen::VectorXi::Zero</a>(3)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a leaf which contains a specified set of integer coordinates. </p>
<dl class="section note"><dt>Note</dt><dd>Only considers this element and its descendents, not neighbors that share the same root.</dd></dl>
<p>Recursively searches this tree and its descendents for a leaf element which contains the point determined by <code>coords</code> and <code>ref_level</code>. If no element is found (i.e. if the specified coordinates are outside this cell) then <code>nullptr</code> is returned. For each dimension, if the corresponding element of <code>bias</code> is 0, then the point is permitted to lie on the lower face of that dimension but not the upper face. If the corresponding element of <code>bias</code> is 1, then it may lie on the upper face but not the lower. Example: The element with refinement level 2 and coordinates {1, 2}:</p><ul>
<li>contains <code>{ref_level = 2, coords = {1, 2}, bias = {0, 0}}</code></li>
<li>does not contain <code>{ref_level = 2, coords = {2, 2}, bias = {0, 0}}</code></li>
<li>contains <code>{ref_level = 2, coords = {2, 2}, bias = {1, 0}}</code></li>
<li>does not contain <code>{ref_level = 2, coords = {2, 2}, bias = {1, 1}}</code></li>
<li>contains <code>{ref_level = 3, coords = {3, 5}}</code> regardless of <code>bias</code>.</li>
</ul>
<p>The arguments <code>coords</code> and <code>bias</code> must have at least <code>n_dim</code> elements and only the first <code>n_dim</code> are read. All elements of <code>bias</code> must be either 0 or 1, or the behavior is unspecified. <code>ref_level</code> must be nonnegative, but there are no restrictions on how it relates to the refinement levels of the cells to be searched. </p>

</div>
</div>
<a id="a23ae23c2b059321baacc4f203beaa852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ae23c2b059321baacc4f203beaa852">&#9670;&nbsp;</a></span>find_leaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Tree.html">Tree</a> * hexed::Tree::find_leaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a>&lt;&gt;&#160;</td>
          <td class="paramname"><em>nominal_position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a leaf which contains a specified point in physical space. </p>
<dl class="section note"><dt>Note</dt><dd>Only considers this element and its descendents, not neighbors that share the same root.</dd></dl>
<p>Recursively searches this tree and its descendents for a leaf element that contains <code>nominal_position</code>. If no element is found (i.e. if the specified coordinates are outside this cell) then <code>nullptr</code> is returned. Elements are considered to contain points which are on their boundary. If multiple elements contain the specified point (i.e. it is on a boundary shared by multiple elements) then which one you get is unspecified. You are only guaranteed to get <em>an</em> element that contains the point. </p>

</div>
</div>
<a id="a8742470dfa8231138ec0512918af6002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8742470dfa8231138ec0512918af6002">&#9670;&nbsp;</a></span>find_neighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Tree.html">Tree</a> * hexed::Tree::find_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a>&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a leaf neighbor of this element in the specified direction. </p>
<p>Recursively searches the entire <code><a class="el" href="classhexed_1_1Tree.html" title="Bin/quad/octree data structure.">Tree</a></code> (all decendents of this element's root) for the nearest element which is a leaf and whose vertex 0 is in the direction specified by <code>direction</code> from this element's vertex 0. All elements of <code>direction</code> must be -1, 0, 1. If no neighbor is found, <code>nullptr</code> is returned. </p><dl class="section note"><dt>Note</dt><dd>If exactly one element of <code>direction</code> is nonzero, this function finds a face neighbor. If there are multiple neighbors on the same face, the one with the lowest coordinates is returned and other neighbors can be found by locating the appropriate neighbors of that cell. If more than one element of <code>direction</code> is nonzero, then edge or vertex neighbors are returned. </dd></dl>

</div>
</div>
<a id="a29f09ef5a27c3ed084944799e18a1414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f09ef5a27c3ed084944799e18a1414">&#9670;&nbsp;</a></span>find_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classhexed_1_1Tree.html">Tree</a> * &gt; hexed::Tree::find_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__matrixtypedefs.html#gaf20e523ca57ee8ef0a945cd4703d2bfd">Eigen::VectorXi</a>&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all leaf neighbors of this element in a specified direction. </p>
<p>Finds all elements in the entire tree which border on this one in a given direction. If the neighbors have the same or lower refinement level, this vector will contain one element which is equal to <code>find_neighbor(direction)</code>. If the neighbors have a higher refinement level, it will find all of them instead of returning the one with the lowest coordinates. In particular, if exactly one element of <code>direction</code> is nonzero, you will get a vector of all the neighbors on a specific face. If no neighbors are found, the vector will be empty. Neighbors are returned in a depth-first, row-major order. </p>

</div>
</div>
<a id="ace29bf94fd7bb34c80fc3e8665141880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace29bf94fd7bb34c80fc3e8665141880">&#9670;&nbsp;</a></span>flood_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Tree::flood_fill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes flood fill algorithm starting with this element. </p>
<p>Sets this element's status to the specified value. It will then check the status of all face neighbors. For any neighbors with status <code>unprocessed</code>, it will continue the flood fill algorithm from those elements including setting their status and evaluating their neighbors. If the element you call this function on is not a leaf, it will instead start the flood fill on the leaf descendent of this cell with the smallest coordinates (e.g. for the root in 2D, it will start with the lower-left element). The parameter <code>status</code> must not be equal to <code>unprocessed</code>. If the start element has a status value which is not <code>unprocessed</code>, the algorithm does nothing. </p>

</div>
</div>
<a id="a71e2c3c06b4328f1ef0f0c7da295bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e2c3c06b4328f1ef0f0c7da295bc8a">&#9670;&nbsp;</a></span>is_leaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hexed::Tree::is_leaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>gives the same result as <code><a class="el" href="classhexed_1_1Tree.html#a907c6f923732b8dd9baaf0b2dd23db4c" title="If this cell has been refined, then this vector contains pointers to its children....">children()</a>.empty()</code> </p>

</div>
</div>
<a id="ad54d5761469e23f1842acfb743c48b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54d5761469e23f1842acfb743c48b15">&#9670;&nbsp;</a></span>nominal_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehexed.html#a6fea0d4042598f888d1d4165619fa4e8">Mat</a> hexed::Tree::nominal_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the position of vertex 0 of the element in physical coordinates </p>
<p>Note that this expressed in floating point format whereas <code>coordinates</code> is in integer format. As an example, in 2D the root element has nominal position origin + {0, 0} and its children have coordinates origin + {0, 0}, origin + {0, .5}, origin + {.5, 0}, origin + {.5, .5}. </p>

</div>
</div>
<a id="a0b9c3164a257474060dbf77dbb707e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9c3164a257474060dbf77dbb707e37">&#9670;&nbsp;</a></span>nominal_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hexed::Tree::nominal_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the size of the element in physical coordinates (before any deformation of the actual DG element) </p>
<p>Equal to \(2^{-\verb|n_dim|}\verb|root_size|\). </p>

</div>
</div>
<a id="a71a9b66dc5274ec6b64655bfeafb0a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a9b66dc5274ec6b64655bfeafb0a90">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhexed_1_1Tree.html">Tree</a> * hexed::Tree::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this element is not the root, then this is a pointer to the element which was refined to obtain this element. If it is the root, then this is <code>nullptr</code>. </p>

</div>
</div>
<a id="a12da3629aaff2a42eb188d8e02ad6342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12da3629aaff2a42eb188d8e02ad6342">&#9670;&nbsp;</a></span>unrefine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hexed::Tree::unrefine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all child elements (and descendents thereof). This element is now a leaf. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/micaiah/orgs/artlab/hexed/include/Tree.hpp</li>
<li>/home/micaiah/orgs/artlab/hexed/src/Tree.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehexed.html">hexed</a></li><li class="navelem"><a class="el" href="classhexed_1_1Tree.html">Tree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
