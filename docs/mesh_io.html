<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hexed: Mesh I/O</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hexed
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('mesh_io.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Mesh I/O </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Hexed has a few functions for input and output of mesh files. This is useful both for saving the simulation state to be restarted later, and for interacting with other meshers and/or solvers. Because, to my knowledge, there is no existing file format capable of representing all the information in a Hexed mesh, including hanging nodes, octree hierarchy, and face warping, it primarily uses its own custom file format, described below. If you wish to use Hexed as a mesher for your own solver, or to use the Hexed solver with a custom mesh, your best bet is probably to write a parser for the native format. Hexed also has limited support for exporting meshes in the native formats for other solvers (see <a class="el" href="mesh_io.html#mesh_export">below</a>), but such export formats lose information. Currently, importing files from other formats is not supported.</p>
<h1><a class="anchor" id="mesh_format"></a>
Native file format</h1>
<p>The native file format for Hexed meshes is based on <a href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format#HDF5">HDF5</a>. One could argue that it doesn't even deserve to be called a file format&mdash;a Hexed mesh file is an ordinary HDF5 file that you can interact with via the <a href="https://www.hdfgroup.org/solutions/hdf5/">HDF5 library</a> or any of the other HDF tools, but with a specific structure. Before launching into the details of the file format itself, we should explain conceptually how Hexed represents its mesh.</p>
<h2><a class="anchor" id="mesh_repr"></a>
Mesh representation</h2>
<h3><a class="anchor" id="Elements"></a>
Elements</h3>
<p>A Hexed mesh contains a collection of elements, each of which is either a line segment, a quadrilateral, or a hexahedron. The shape of each element is defined by a parametric mapping \( \vec{x}(\vec{\xi}) \), where \( \vec{\xi} \) is the vector of <em>reference coordinates</em> in the <em>reference element</em> (which is always the unit interval, square, or cube) and \( \vec{x} \) is the vector of <em>physical coordinates</em> in the <em>physical element</em> (the actual element with it's real size and shape). In Hexed, reference coordinates go from 0 to 1, not -1 to 1 as they do in some formulations. I.e. \( \xi_i \in [0, 1]\ :\ \forall i \). For an example, see the plot below. The mapping \( \vec{x}(\vec{\xi}) \) is always a polynomial. </p><div class="image">
<object type="image/svg+xml" data="ref_coords.svg" style="pointer-events: none;"></object>
<div class="caption">
Element if reference space with isocontours of physical coordinates.</div></div>
 <div class="image">
<object type="image/svg+xml" data="phys_coords.svg" style="pointer-events: none;"></object>
<div class="caption">
Element if physical space with isocontours of reference coordinates.</div></div>
<p>In a Hexed mesh, many of the elements are perfect squares/cubes. That is, \( \vec{x}(\vec{\xi}) = a \vec{\xi} + \vec{b} \) for scalar constant \( a \) and vector constant \( b \). Such elements are referred to as <em>Cartesian</em> elements. Any elements that do not fit this description are called <em>deformed</em>. Hexed makes this distinction in order to exploit time and memory-saving simplifications of the numerical scheme for Cartesian elements. In many of the deformed elements, \( \vec{x} \) is a degree 1 (a.k.a. <a href="https://en.wikipedia.org/wiki/Multilinear_polynomial">multilinear</a>) polynomial that can be obtained by <a href="https://en.wikipedia.org/wiki/Bilinear_interpolation">multilinear interpolation</a> of the vertex coordinates. (Some people might be tempted to call this a "linear" polynomial, but it is technically not linear.) However, elements that are extruded to the surface geometry will have \( \vec{x} \) of full degree \(p\) in order to better fit the surface by warping their faces. As described in our most recent publications, face warping is represented by a polynomial on each face which essentially gives the deviation of the warped face from the unwarped face.</p>
<p>The following two sections explain the calculation of the coordinate transformation in more detail. As is often the case for computational science, the procedure is more neatly represented in code than in equations. So, some Python examples are included to demonstrate the process in 3D. Of course, you can also look at the real implementations in C++, but it is more complex due to the low-level language constructs, the dimensionality-independent formulation, and the context of how it fits into larger algorithms. I hope the Python snippets make it a bit more clear what the actual calculations are.</p>
<h3><a class="anchor" id="vertex_def"></a>
Vertex deformation</h3>
<p>In Hexed, all field data, including the physical coordinates \( \vec{x} \), is represented by a degree \( p \) polynomial in each element in a nodal basis. To define the physical coordinates, or any other field, means to compute their value at the element's quadrature points, which are chosen to be the tensor product Gauss-Legendre nodes mapped to [0, 1] (in reference space). Quadrature points are also arranged in a row-major array format ("z"-index changes the fastest). (Technically, because the physical coordinates at the quadrature points aren't directly used by the computational kernel, they aren't permanently stored, but they are still computed temporarily.) As mentioned above, for an element without face warping, the physical coordinates defined by degree 1 interpolation between the coordinates of the vertices. The vertices of each element are ordered in a row-major, array-based manner (the last coordinate changes the fastest). For example, the vertices of the unit square are {(0, 0), (0, 1), (1, 0), (1, 1)} and the vertices of the unit cube are {(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)}. To further clarify, the following Python code snippet illustrates an example of computing quadrature point coordinates for a 3D element without face warping. For the actual implementation of this calculation in C++, see <code><a class="el" href="classhexed_1_1Deformed__element.html#a5ab9901af4f3bb69ca35bea20e880992" title="override that actually accounts for vertex positions and face warping">hexed::Deformed_element::position</a></code> in <a href="https://github.com/ARTLab-GT/hexed/blob/main/src/Deformed_element.cpp">src/Deformed_element.cpp</a>. </p><div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">from</span> sympy.integrals.quadrature <span class="keyword">import</span> gauss_legendre</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line">degree = 3 <span class="comment"># degree p of the polynomials</span></div>
<div class="line">row_size = degree + 1 <span class="comment"># computationally, it is usually more convenient to work in terms of the size of each row of quadrature points</span></div>
<div class="line">nodes, weights = gauss_legendre(row_size, 20) <span class="comment"># fetch the Gauss-Legendre nodes</span></div>
<div class="line">nodes = (np.array(nodes).astype(np.float64) + 1)/2 <span class="comment"># map from [-1, 1] (the standard convention) to [0, 1] (the Hexed convention)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>physical_qpoint_coords(vertex_coords):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot; compute the physical coordinates of the element quadrature points from the coordinates of the element vertices &quot;&quot;&quot;</span></div>
<div class="line">    phys_coords = np.zeros((3, row_size**3))</div>
<div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(row_size):</div>
<div class="line">        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(row_size):</div>
<div class="line">            <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(row_size):</div>
<div class="line">                <span class="comment"># start with the coordinates of all vertices, and then perform linear interpolation one dimension at a time</span></div>
<div class="line">                qpoint_coords = vertex_coords + 0</div>
<div class="line">                <span class="keywordflow">for</span> i_dimension <span class="keywordflow">in</span> range(3):</div>
<div class="line">                    node = nodes[(i, j, k)[i_dimension]]</div>
<div class="line">                    <span class="comment"># perform linear interpolation along `i_dimension`, reducing the number of points left to interpolate by a factor of 2</span></div>
<div class="line">                    qpoint_coords = (1 - node)*qpoint_coords[:qpoint_coords.shape[0]//2, :] + node*qpoint_coords[qpoint_coords.shape[0]//2:, :]</div>
<div class="line">                <span class="comment"># having performed linear interpolation three times (trilinear interpolation),</span></div>
<div class="line">                <span class="comment"># we have now gone from 8 points to just 1 point with 3 values (the 3 coordinates)</span></div>
<div class="line">                phys_coords[:, ((i*row_size) + j)*row_size + k] = qpoint_coords</div>
<div class="line">    <span class="keywordflow">return</span> phys_coords</div>
<div class="line"> </div>
<div class="line"><span class="comment"># vertices for an example element which is a frustrum of a pyramid (the top/+z face is shrunk by 0.2 in the x and y directions)</span></div>
<div class="line">example_vertices = np.array([</div>
<div class="line">    [0., 0., 0.],</div>
<div class="line">    [.2, .2, 1.],</div>
<div class="line">    [0., 1., 0.],</div>
<div class="line">    [.2, .8, 1.],</div>
<div class="line">    [1., 0., 0.],</div>
<div class="line">    [.8, .2, 1.],</div>
<div class="line">    [1., 1., 0.],</div>
<div class="line">    [.8, .8, 1.],</div>
<div class="line">])</div>
<div class="line"><span class="comment"># plot the vertices</span></div>
<div class="line">ax = plt.gcf().add_subplot(projection = <span class="stringliteral">&quot;3d&quot;</span>)</div>
<div class="line">ax.scatter(example_vertices[:, 0], example_vertices[:, 1], example_vertices[:, 2])</div>
<div class="line"><span class="comment"># compute the quadrature point positions of this example element</span></div>
<div class="line">example_qpoints = physical_qpoint_coords(example_vertices)</div>
<div class="line"><span class="comment"># plot the quadrature points</span></div>
<div class="line">ax.scatter(example_qpoints[0, :], example_qpoints[1, :], example_qpoints[2, :])</div>
<div class="line">ax.set_xlabel(<span class="stringliteral">&quot;$x_0$&quot;</span>)</div>
<div class="line">ax.set_ylabel(<span class="stringliteral">&quot;$x_1$&quot;</span>)</div>
<div class="line">ax.set_zlabel(<span class="stringliteral">&quot;$x_2$&quot;</span>)</div>
<div class="line">plt.show()</div>
</div><!-- fragment --> <h3><a class="anchor" id="face_warping"></a>
Face warping</h3>
<p>The face warping is represented as described in our 2024 SciTech meshing paper, with two exceptions:</p>
<ol type="1">
<li>The warping function is stored at Gauss-Legendre points instead of Gauss-Lobatto. They are still originally computed on Gauss-Lobatto points to ensure continuity between elements, but they are then mapped to Gauss-Legendre points, for consistency with the field polynomials.</li>
<li>Warping functions can be applied to any face, not just the +x face. In fact, for simplicity, warping values are stored for <em>all</em> faces of all deformed elements, even though they will only be nonzero for at most one face on each element, or in the case that you have anisotropic layers, sometimes two opposite faces.</li>
</ol>
<p>These distinctions do not constitute inconsistencies with the paper. The underlying mathematics is completely equivalent, but the best way to represent that math in equations is not the same as the best way to represent it in code. In any case, the warping function is represented as an adjustment to the unwarped position of the face quadrature points. Note that the face quadrature points are an array of Gauss-Legendre points on the faces, which is <b>not</b> a subset of the interior quadrature points&mdash;extrapolation is required to obtain values of field variables at face quadrature points. As in the publication, the face warping is a one-dimensional adjustment in the direction of increasing face-normal reference coordinate. Specifically, if \( \vec{x}_- \) and \( \vec{x}_+ \) are the positions of a matching pair of quadrature points on the negative and positive-facing x, y, or z faces, and \( w_- \) and \( w_+ \) are the warping functions at those faces, then the warping can be formulated as </p><p class="formulaDsp">
\[ \vec{x}_{-, \text{warped}} = \vec{x}_- + w_-(\vec{x}_+ - \vec{x}_-) \]
</p>
 <p class="formulaDsp">
\[ \vec{x}_{+, \text{warped}} = \vec{x}_+ + w_+(\vec{x}_+ - \vec{x}_-) \]
</p>
<p> and the corresponding adjustments to the interior quadrature points are computed by linear interpolation between the adjustments to the faces. The following Python snippet shows an example, whereas the real implementation is in <code><a class="el" href="classhexed_1_1Deformed__element.html#a5ab9901af4f3bb69ca35bea20e880992" title="override that actually accounts for vertex positions and face warping">hexed::Deformed_element::position</a></code> in <a href="https://github.com/ARTLab-GT/hexed/blob/main/src/Deformed_element.cpp">src/Deformed_element.cpp</a>. </p><div class="fragment"><div class="line"><span class="keyword">def </span>warped_qpoint_coords(vertex_coords, face_warping):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot; computes the physical quadrature point coordinates again, but this time with face warping &quot;&quot;&quot;</span></div>
<div class="line">    unwarped_coords = physical_qpoint_coords(vertex_coords) <span class="comment"># start with the unwarped coordinates; face warping is a perturbation to these</span></div>
<div class="line">    warped_coords = unwarped_coords + 0 <span class="comment"># will adjust these as we go along</span></div>
<div class="line">    <span class="keywordflow">for</span> i_dimension <span class="keywordflow">in</span> range(3): <span class="comment"># start with warping for -/+ x faces, then y, etc</span></div>
<div class="line">        <span class="comment"># the interior quadrature points are a 3D array, whereas the face quadrature points are a 2D array</span></div>
<div class="line">        <span class="comment"># we need to compute some strides in order to map face quadrature points to the corresponding 1D slice of interior quadrature points</span></div>
<div class="line">        interior_stride = row_size**(2 - i_dimension) <span class="comment"># stride between two interior quadrature points in the interior slice</span></div>
<div class="line">        <span class="comment"># stride between two interior quadrature points corresponding to consecutive rows of face quadrature points</span></div>
<div class="line">        <span class="keywordflow">if</span> (i_dimension == 0): face_row_stride = row_size</div>
<div class="line">        <span class="keywordflow">else</span>: face_row_stride = row_size**2</div>
<div class="line">        <span class="comment"># stride between two interior quadrature points corresponding to consecutive columns of face quadrature points</span></div>
<div class="line">        <span class="keywordflow">if</span> (i_dimension == 2): face_col_stride = row_size</div>
<div class="line">        <span class="keywordflow">else</span>: face_col_stride = 1</div>
<div class="line">        <span class="comment"># loop through face quadrature points (do - and + faces for the same dimension simultaneously)</span></div>
<div class="line">        <span class="keywordflow">for</span> face_row <span class="keywordflow">in</span> range(row_size):</div>
<div class="line">            <span class="keywordflow">for</span> face_col <span class="keywordflow">in</span> range(row_size):</div>
<div class="line">                <span class="comment"># compute the slice of interior quadrature points</span></div>
<div class="line">                slice_start = face_row*face_row_stride + face_col*face_col_stride</div>
<div class="line">                interior_slice = slice(slice_start, slice_start + row_size*interior_stride, interior_stride)</div>
<div class="line">                interior_coords = unwarped_coords[:, interior_slice]</div>
<div class="line">                <span class="comment"># extrapolate the unwarped coordinates of interior quadrature points to faces</span></div>
<div class="line">                unwarped_face_coords = np.zeros((3, 2)) <span class="comment"># column 0 is - face, column 1 is + face</span></div>
<div class="line">                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(row_size):</div>
<div class="line">                    <span class="keywordflow">for</span> face_sign <span class="keywordflow">in</span> [0, 1]: <span class="comment"># face_sign == 0 indicates negative-facing face whereas face_sign == 1 indicates positive-facing</span></div>
<div class="line">                        unwarped_face_coords[:, face_sign] += interior_coords[:, i]*np.array([(face_sign - nodes[j])/(nodes[i] - nodes[j]) <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(row_size) <span class="keywordflow">if</span> j != i]).prod()</div>
<div class="line">                interp_coefs = [1 - nodes[np.newaxis, :], nodes[np.newaxis, :]]</div>
<div class="line">                <span class="comment"># compute the difference between coordinates of corresponding quadrature points on opposite faces (\xi_+ - \xi_-)</span></div>
<div class="line">                diff = unwarped_face_coords[:, [1]] - unwarped_face_coords[:, [0]]</div>
<div class="line">                <span class="comment"># interpolate back to interior quadrature points</span></div>
<div class="line">                <span class="keywordflow">for</span> face_sign <span class="keywordflow">in</span> [0, 1]:</div>
<div class="line">                    warped_coords[:, interior_slice] += interp_coefs[face_sign]*face_warping[i_dimension, face_sign, face_row*row_size + face_col]*diff</div>
<div class="line">    <span class="keywordflow">return</span> warped_coords</div>
<div class="line"> </div>
<div class="line"><span class="comment"># compute an example warping function which is a simple quadratic warping of the -y face</span></div>
<div class="line">example_warping = np.zeros((3, 2, row_size**2)) <span class="comment"># first index is face dimension, second index is face sign, last index is the quadrature point of the face</span></div>
<div class="line">example_warping[1, 0, :] = 1.5*(nodes[:, np.newaxis]*(1 - nodes[:, np.newaxis])*np.ones(row_size)).flatten()</div>
<div class="line"><span class="comment"># plot the vertices</span></div>
<div class="line">ax = plt.gcf().add_subplot(projection = <span class="stringliteral">&quot;3d&quot;</span>)</div>
<div class="line">ax.scatter(example_vertices[:, 0], example_vertices[:, 1], example_vertices[:, 2])</div>
<div class="line"><span class="comment"># compute the quadrature point positions of this example element</span></div>
<div class="line">example_qpoints = warped_qpoint_coords(example_vertices, example_warping)</div>
<div class="line"><span class="comment"># plot the quadrature points</span></div>
<div class="line">ax.scatter(example_qpoints[0, :], example_qpoints[1, :], example_qpoints[2, :])</div>
<div class="line">ax.set_xlabel(<span class="stringliteral">&quot;$x_0$&quot;</span>)</div>
<div class="line">ax.set_ylabel(<span class="stringliteral">&quot;$x_1$&quot;</span>)</div>
<div class="line">ax.set_zlabel(<span class="stringliteral">&quot;$x_2$&quot;</span>)</div>
<div class="line">plt.show()</div>
</div><!-- fragment --> <h3><a class="anchor" id="Tree"></a>
Tree</h3>
<p>Tree refinement (bintree in 1D, quadtree in 2D, and <a href="https://en.wikipedia.org/wiki/Octree">octree</a> in 3D) is a key concept in the Hexed meshing scheme. This is represented by a recursive data structure (implemented as <code><a class="el" href="classhexed_1_1Tree.html" title="Bin/quad/octree data structure.">hexed::Tree</a></code>), where each <code>Tree</code> object optionally contains pointers to 2/4/8 other <code>Tree</code> objects representing its children and/or a pointer to another <code>Tree</code> object representing its parent. The child pointers are in the same row-major array order as the vertices of an element, according to their spatial position. A tree with no parent is called the <em>root</em> (the tree structure as a whole naturally contains exactly one of these), and a tree with no children is called a <em>leaf</em>. The <em>refinement level</em> of a <code>Tree</code> object is the number of generations it is from the root. I.e., the root will have refinement level 0, its children will have refinement level 1, etc..</p>
<p>A <code>Tree</code> can also contain a pointer to a computational element, as described above. The Hexed meshing scheme involves starting with a Cartesian tree mesh, cutting holes in it, and extruding new elements, meaning that not all <code>Tree</code>s have elements, and not all elements have <code>Tree</code>s. <code>Tree</code> objects are implicitly associated with a box in physical space, which, if the <code>Tree</code> is associated with a Cartesian element, will coincide with that element. If the <code>Tree</code> is associated with a deformed element, that element will usually be close to but not exactly coincide with the <code>Tree</code>. To fully define the mapping from <code>Tree</code> objects to physical space, <a class="anchor" id="origin"></a>the tree as a whole also has an <em>origin</em>, which is the physical coordinates of the minimum (least x, y, and z) vertex of the root, and also a <em>root size</em>, which is the edge length of the root. The <em>nominal position</em> of a <code>Tree</code> is a vector of 1/2/3 non-negative integers representing its displacement relative to the tree origin in units of that <code>Tree</code> object's edge length (not the root size). The association between elements and <code>Tree</code>s leads to elements also having a refinement level and nominal position, which is equal to that of their <code>Tree</code>, if they have one. Extruded elements without <code>Tree</code>s still have a refinement level and nominal position with is computed based on their relation to the element they were extruded from (their <em>extrusion parent</em>). E.g. if you extrude an element from the +x face of its extrusion parent, then the x-coordinate of its nominal position will be 1 greater than that of its extrusion parent.</p>
<h3><a class="anchor" id="Connections"></a>
Connections</h3>
<p>Any mesh representation must have some way to indicate the connections between elements. Although you could, in principle, infer this information from the vertex list of the elements and the tree structure, Hexed identifies the connections explicitly in both the <code><a class="el" href="classhexed_1_1Accessible__mesh.html" title="A mesh that supports access to the actual elements with the numerical data they contain.">hexed::Accessible_mesh</a></code> object and the mesh file. If you are trying to read a Hexed mesh into your own solver, you may opt to simply ignore the connection data and just use the element/vertex data. Furthermore, Hexed does not allow completely arbitrary connections between elements&mdash;it only supports the manners of connections required to generate a tree mesh and to extrude elements from it.</p>
<p><a class="anchor" id="conformal_connection"></a>A <b>conformal</b> connection (one between two elements of the same refinement level) is specified by 6 pieces of data:</p>
<ol type="1">
<li>a pointer to the first element</li>
<li>a pointer to the second element</li>
<li>the index of the dimension of the face of the first element that is being connected (0 if it is an x-face, 1 for y, 2 for z)</li>
<li>the dimension index of the second face</li>
<li>the sign of the face of the first element (0 if the face faces in the negative x/y/z direction, 1 if it faces in the positive direction)</li>
<li>the sign of the second face</li>
</ol>
<p>Either the dimensions or the signs of the two faces involved must be different. Connecting the +x face of one element to the +x face of another, for example, is not allowed. Of course, connecting two faces of the same element is also not allowed. This connection format doesn't explicitly specify the orientation of the faces that are connected (which vertex maps to which vertex). Instead, it is always assumed to be what you might call the "laziest possible orientation". Consider each element restored to its original Cartesian shape and location (coincident with its <code>Tree</code>, if it has one). Now, merge the vertices of the connected faces while only changing the coordinates corresponding to the dimensions of the connected faces. So, for example, if you are connecting a y-face to a z-face, then merge the vertices without changing the x-coordinate. In other words, connect the faces by only stretching the elements and not twisting them. Of course, in the actual mesh, the vertex coordinates are arbitrary&mdash;the principle of moving vertices without changing one of the coordinates is just a thought experiment to explain what I mean by the "laziest possible orientation". Note also that if you're just trying to read a Hexed mesh into your code, you don't necessarily have to worry about this orientation problem, since you can compare the vertices of the neighboring elements and see which are the same. However, if you're trying to create a mesh file for Hexed, you will need to make sure the orientation condition is satisfied.</p>
<p><a class="anchor" id="refined_connection"></a>A <b>refined</b> connection connects a coarse element with some elements that are 1 level finer. You cannot create a refined connection with elements that differ by more than 1 refinement level. A refined connection can accept up to 1/2/4 elements in 1/2/3 dimensions. It can also accept half as many fine elements, causing the remaining ones to be "stretched" by a factor of 2 to cover the coarse face. This occurs when you have extruded elements of different refinement levels. As a result, in 2D sometimes you will have one coarse element connected to one finer element, but this is still considered to be a refined connection, not a conformal one, since the elements have different refinement levels. Thus, a refined connection is specified by 11 pieces of data:</p><ol type="1">
<li>a pointer to the coarse element</li>
<li>up to 4 pointers to the fine elements<ul>
<li>The fine elements are in row-major array order. That is, elements that come first in the list of child pointers of their parent tree will come first in the fine element list of a refined connection.</li>
</ul>
</li>
<li>boolean flag indicating whether the fine elements are stretched along the lesser dimension, i.e. the first of the (up to two) indices of the array of fine elements.<ul>
<li>If this is true, there will be half as many fine elements as there otherwise would be.</li>
</ul>
</li>
<li>boolean flag indicating whether the fine elements are stretched along the greater dimension, i.e. the second of the two indices of the array of fine elements, and only applicable in 3D.<ul>
<li>If this is true, there will be half as many fine elements as there otherwise would be.</li>
</ul>
</li>
<li>dimension index of the face of the coarse element that is being connected</li>
<li>dimension index of the fine faces<ul>
<li>This is only a single number. It is assumed that the <em>same</em> face of all the fine elements is being connected.</li>
</ul>
</li>
<li>sign of the coarse face</li>
<li>sign of the fine faces<ul>
<li>again, only one number for all the fine elements</li>
</ul>
</li>
</ol>
<p><a class="anchor" id="boundary_connection"></a>Finally, a <b>boundary</b> connection specifies that a face of an element is on a domain boundary. This is specified by 4 pieces of data:</p><ol type="1">
<li>pointer to the element whose face is being connected</li>
<li>pointer to the boundary condition</li>
<li>dimension index of the face</li>
<li>sign of the face</li>
</ol>
<h2><a class="anchor" id="file_format"></a>
File format</h2>
<p>A Hexed mesh file is an HDF5 file, with a name ending in <code>.mesh.h5</code> by convention. Note that some of the attributes in this file aren't conceptually part of the mesh, but they are numerical scheme parameters that affect how much memory the mesh object needs to allocate. Its contents are the following:</p>
<p><b>group</b> <code>/</code>:</p><ul>
<li><b>attribute</b> <code>n_dim</code> (1 \(\times\) 1 <code>int</code>): number of dimension</li>
<li><b>attribute</b> <code>row_size</code> (1 \(\times\) 1 <code>int</code>): polynomial degree + 1</li>
<li><b>attribute</b> <code>n_forcing</code> (1 \(\times\) 1 <code>int</code>): number of artificial viscosity forcing functions (numerical scheme parameter). Usually 4.</li>
<li><b>attribute</b> <code>n_stage</code> (1 \(\times\) 1 <code>int</code>): number of time integration stages (numerical scheme parameter). Usually 2.</li>
<li><b>attribute</b> <code>n_var</code> (1 \(\times\) 1 <code>int</code>): number of physical flow variables (numerical scheme parameter). Usually <code>n_dim + 2</code>.</li>
<li><b>attribute</b> <code>root_size</code> (1 \(\times\) 1 <code>double</code>): edge length of the root tree element</li>
<li><b>attribute</b> <code>version_major</code> (1 \(\times\) 1 <code>int</code>): major version of the Hexed executable used to create this file (if applicable).</li>
<li><b>attribute</b> <code>version_minor</code> (1 \(\times\) 1 <code>int</code>): minor version of the Hexed executable used to create this file (if applicable).</li>
<li><b>attribute</b> <code>version_patch</code> (1 \(\times\) 1 <code>int</code>): patch version of the Hexed executable used to create this file (if applicable).</li>
<li><b>group</b> <code>vertices</code>:<ul>
<li><b>dataset</b> <code>position</code> (n \(\times\) 3): Coordinates of the vertices. There are always 3 even for 1D and 2D meshes. Trailing coordinates are set to 0.</li>
</ul>
</li>
<li><b>group</b> <code>elements</code>:<ul>
<li><b>dataset</b> <code>is_deformed</code> (n \(\times\) 1 <code>bool</code>) One entry for each element. If that element is perfectly Cartesian, the value is 0. If it is deformed, the value is 1.</li>
<li><b>dataset</b> <code>nominal_position</code> (n \(\times\) <code>n_dim</code> <code>int</code>) one entry for each element giving its nominal position</li>
<li><b>dataset</b> <code>refinement_level</code> (n \(\times\) 1 <code>int</code>) one entry for each element giving its refinement level</li>
<li><b>dataset</b> <code>vertices</code> (n \(\times\) \( 2^\verb|n_dim| \) <code>int</code>) One row for each element giving the indices (in the <code>/vertices/position</code> dataset) of its vertices in standard row-major array order. For elements that are connected, these will actually point to the same vertices, so if you are reading a mesh file you can use this to infer the connectivity information, if you choose (although hanging nodes might make that tricky).</li>
<li><b>group</b> <code>face_warping</code>:<ul>
<li><b>dataset</b> <code>element_indices</code> (n \(\times\) 1 <code>int</code>) One entry for each <em>deformed</em> element. Each entry is the index of the element (in the datasets <code>is_deformed</code>, <code>nominal_position</code>, etc.) that this is warping referring to (the <code>node_adjustments</code> dataset gives the actual warping values). The entry of <code>is_deformed</code> at that index <b>must</b> be 1. There should not be multiple face warping entries referring to the same element.</li>
<li><b>dataset</b> <code>node_adjustments</code> (n \(\times\) \( \verb|n_dim*2*row_size|^{\verb|n_dim| - 1} \) <code>double</code>) Face warping values for the element specified by the corresponding entry in the <code>element_indices</code> dataset. These warping values behave as described in <a class="el" href="mesh_io.html#face_warping">Face warping</a>, where the row-major <code>n_dim</code> \(\times\) 2 \(\times\) \( \verb|row_size|^{\verb|n_dim| - 1} \) array of values for each face (the face dimension index changes the slowest) has been flattened into a single array of values for all faces.</li>
</ul>
</li>
</ul>
</li>
<li><b>group</b> <code>connections</code>:<ul>
<li><b>dataset</b> <code>conformal</code> (n \(\times\) 6 <code>int</code>): Each row provides the data for 1 <a class="el" href="mesh_io.html#conformal_connection">conformal connection</a>. In each row, entries 0 and 1 are the indices of the elements participating in the connection. Entries 2 and 3 are the dimension of the faces involved, and entries 4 and 5 are the signs of the faces (0|1). If either of the elements are marked as Cartesian (via <code>/elements/is_deformed</code>), then there are additional restrictions: both face dimensions must be the same, the first face sign must be 1, and the second face sign must be 0. If you're writing a mesh file and that is inconvenient, you can just mark all elements as deformed, although this can add a modest performance overhead in the solver.</li>
<li><b>dataset</b> <code>refined</code> (n \(\times\) 11 <code>int</code>): Each row provides the data for 1 <a class="el" href="mesh_io.html#refined_connection">refined connection</a>. In each row, entry 0 is the index of the coarse element. Entries 1, 2, 3, 4 are the indices of the fine elements in the connection. If there are less than 4 fine elements (because the mesh is 2D or there is stretching) then the unused entries are set to -1. Entries 5 and 6 indicate whether the fine elements are stretched in the first and second (if applicable) face dimensions. Entries 7 and 8 are the dimension indices of the pertinent faces of the coarse and fine elements, respectively. Entries 9 and 10 are the signs of the faces of the coarse and fine elements (0|1). As is the case for conformal connections, if any of the elements involved are Cartesian, the face dimensions must be the same. However, the Cartesian restriction of face signs does not apply (because the coarse element is required to come first, regardless of which face is being connected).</li>
<li><b>dataset</b> <code>boundary</code> (n \(\times\) 4 <code>int</code>): Each row provides the data for 1 boundary connection. Entry 0 is the index of the element being connected. Entry 1 is the index of the boundary condition being applied. Entry 3 is the face dimension index. Entry 4 is the face sign (0|1). The mesh file does not record what the boundary conditions are&mdash;those are specific to each simulation. However, there is a convention for mapping boundary condition indices to input file parameters:<ul>
<li>Boundary conditions [0, <code>2*n_dim</code>) are the extremal <a class="el" href="parameters.html#extremal_bc">boundary conditions</a>. In particular, <code>extremal_bcIJ</code> is index <code>2*I + J</code> (the order of mesh extremes is analogous to the order of element faces).</li>
<li>Boundary condition <code>2*n_dim</code>, if it exists, is the <a class="el" href="parameters.html#surface_bc">surface_bc</a>.</li>
</ul>
</li>
</ul>
</li>
<li><b>group</b> <code>tree</code>:<ul>
<li><b>dataset</b> <code>origin</code> (1 \(\times\) <code>n_dim</code> <code>double</code>): <a class="el" href="mesh_io.html#origin">origin</a> of the tree</li>
<li><b>dataset</b> <code>children</code> (n \(\times\) \( 2 + 2^\verb|n_dim| \) <code>int</code>): Represents the actual topology of the tree via the child lists, plus a little extra data they gets tacked on. Each row represents one <code><a class="el" href="classhexed_1_1Tree.html" title="Bin/quad/octree data structure.">hexed::Tree</a></code> object. Entry 0 in the row is the index if the computational element (i.e. a row in the <code>/elements</code> datasets) associated with this tree, if there is one. If the tree does not have an element, then entry 0 is set to -1. Entry 1 is the <a class="el" href="classhexed_1_1Tree.html#af00bd31b3a63b78b0ea4ed4fac807d77">flood fill status</a> of the tree (-1 &rArr; unprocessed | 0 &rArr; deleted | 1 &rArr; in domain). The remaining entries are the indices of the children of the tree, if they exist, and are otherwise set to -1. So, if a tree is a leaf, all entries after 1 will be -1. If, for example, entry 2 were equal to 946, that would mean that you can find information about the first child of this tree on row 946 of the same dataset. Note that there is no information about parents, since a single recursive traversal through the <code>children</code> dataset is sufficient to fully reconstruct the tree structure including parent relations.</li>
</ul>
</li>
</ul>
<p>For the implementation of reading and writing a mesh file, see <code>hexed::Accessible_mesh::read_file</code> and <code>hexed::Accessible_mesh::write</code> in <a href="https://github.com/ARTLab-GT/hexed/blob/main/src/Accessible_mesh.cpp">src/Accessible_mesh.cpp</a>.</p>
<h1><a class="anchor" id="mesh_export"></a>
Export formats</h1>
<p>So far, Hexed has limited support for exporting the mesh into other formats, which it can write but not read. The challenge is finding formats that support hanging nodes, which are critical to the Hexed meshing scheme. Implementing an algorithm to remove the hanging nodes (only for exporting) may be of interest in the future, but that is a nontrivial task.</p>
<p>Currently, the only export format currently supported is <a href="https://www.openfoam.com/">OpenFOAM</a>'s <a href="https://www.openfoam.com/documentation/user-guide/4-mesh-generation-and-conversion/4.1-mesh-description">PolyMesh</a>. Technically, the hanging nodes are implemented using polyhedral elements with more than 6 faces. At this time, only 3D is supported. OpenFOAM is an inherently 3D solver and 2D meshes have to be extruded to create a 1 cell thick slab, a capability that I have not yet implemented.</p>
<p>I have been considering adding support for ANSYS Fluent <a href="https://www.afs.enea.it/project/neptunius/docs/fluent/html/ug/node1461.htm">case files</a>, which I believe support genuine hanging nodes. If this would be useful to you, or you know of another format that you believe would work, feel free to discuss it with <a class="el" href="index.html#Contact">me</a> so that I can factor it into future development plans. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
