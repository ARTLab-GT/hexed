<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hexed: Solver Parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hexed
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('parameters.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Solver Parameters </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="inputs"></a>
Input Parameters</h1>
<p>This section lists variables that directly affect the behavior of the solver. Some of them are preset to default values with the intent that you should override them, and some are <b>not</b> defined and <b>must</b> be defined by you.</p>
<h2><a class="anchor" id="important_inputs"></a>
Important Input Parameters</h2>
<p>Setting these parameters appropriately is critical to get the right answer, and you should generally think about them every time you run a simulation.</p>
<hr  />
 <h3><a class="anchor" id="n_dim"></a>
n_dim</h3>
<p><b>type:</b> integer <br  />
Number of dimensions. Must be at least 1 and at most 3.</p>
<hr  />
 <h3><a class="anchor" id="done"></a>
done</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{println {Error: you forgot to a set stop condition} &amp; throw}</code> <br  />
Termination condition. This should be a macro that evaluates to an integer. It will be evaluated at each iteration, and the simulation will continue iff it evaluates to <a class="el" href="hil.html#false">false</a>. As should be clear from the default value, you <b>must</b> set this variable yourself. You can consider setting it based on the <a class="el" href="parameters.html#iteration">iteration count</a>, <a class="el" href="parameters.html#normalized_residual">residual</a>, and/or <a class="el" href="parameters.html#monitor_vars">output variable history</a>.</p>
<hr  />
 <h3><a class="anchor" id="local_time"></a>
local_time</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#true">true</a> <br  />
If <a class="el" href="hil.html#true">true</a>, use local time stepping, otherwase use global. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="max_safety"></a>
max_safety</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 0.7 <br  />
Maximum allowable safety factor on the <a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">CFL condition</a> for time step determination. The time step will be either this number times the estimated maximum stable time step or <a class="el" href="parameters.html#max_time_step">max_time_step</a>, whichever is smaller. This parameter is applicable to both local and global time stepping. If the actual safety factor (accounting for <a class="el" href="parameters.html#max_time_step">max_time_step</a> constraints) is greater than 1 the scheme will almost certainly be unstable. Thus even if you intend for your time integration not to be CFL-driven, it is strongly recommended that you keep this parameter less than 1 and simply make your <a class="el" href="parameters.html#max_time_step">max_time_step</a> small enough to be the active constraint. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="max_time_step"></a>
max_time_step</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <a class="el" href="hil.html#huge">huge</a> <br  />
Maximum allowable time step. The time step will be either this number or <a class="el" href="parameters.html#max_safety">max_safety</a> times the estimated maximum stable time step, whichever is smaller. This parameter is only meaningful for global time stepping. If you intend for your time stepping to be CFL driven, simply keep this number large enough not to be the active constraint. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="transport_model"></a>
transport_model</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{inviscid}</code> <br  />
Specifies model to use for molecular transport coefficients (viscosity and thermal conductivity). Accepted values:</p><ul>
<li><code>{inviscid}</code></li>
<li><code>{sutherland}</code>: Uses sutherland's law for air (non-constant Prandtl number)</li>
</ul>
<hr  />
 <h3><a class="anchor" id="thermal_bc"></a>
thermal_bc</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{heat_flux = 0.}</code> <br  />
Only applicable when <a class="el" href="parameters.html#surface_bc">surface_bc</a> = <code>{no_slip}</code>. Specifies thermal boundary condition. Default gives an adiabatic wall. Accepted values:</p><ul>
<li><code>{heat_flux = x}</code>: Prescribes the wall heat flux (out of the domain, into the wall) to be <code>x</code>.</li>
<li><code>{temperature = x}</code>: Prescribes the temperature at the wall to be <code>x</code>.</li>
<li><code>{internal_energy = x}</code>: Prescribes the internal energy at the wall to be <code>x</code>. For now, since you're stuck in the CPG world, this is equivalent to <code>{temperature = x*(heat_rat - 1)/specific_gas_air}</code>.</li>
<li><code>{emissivity = x; conduction = y; temperature = z}</code>:<a class="anchor" id="thermal_equilibrium_bc"></a> Specifies that the wall is in thermal equalibrium according to a simple 1D heat equation. Specifically, sets the heat flux equal to the sum of the radiative cooling flux and the thermal conduction through the wall. The radiative cooling flux is determined by the <a href="https://en.wikipedia.org/wiki/Stefan%E2%80%93Boltzmann_law">Stefan-Boltzmann Law</a> with the emissivity \( \sigma \) given by <code>emissivity</code>. The conductive flux is determined by assuming that the wall has a small but finite thickness and the temperature on the non-air side is known. Specifically, it is equal to \( kL(T_w - T_p) \) where \( k \) is the thermal conductivity of the wall material, \( L \) is the wall thickness, \( T_w \) is the current wall temperature, and \( T_p \) is the prescribed temperature. The product \( kL \) is equal to <code>conduction</code> and the prescribed temperature \( T_p \) is <code>temperature</code>. You don't have to specify all 3 parameters&mdash;they all default to 0. You may specify <code>emissivity</code> <b>and/or</b> you may specify the other parameters, but if you specify either <code>conduction</code> or <code>temperature</code> you must specify both. If your wall is highly conductive, you might need to reduce <a class="el" href="parameters.html#heat_flux_coercion">heat_flux_coercion</a> to maintain stability.</li>
</ul>
<hr  />
 <h3><a class="anchor" id="row_size"></a>
row_size</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 6 <br  />
<a class="el" href="conventions.html#basis_row_size">Row size</a> of polynomial basis. Must be at lead 2 and at most <code><a class="el" href="namespacehexed_1_1config.html#ae2b5f6cd69b37a5ec8d33f6361f0025b" title="maximum row size that a Basis is allowed to have">hexed::config::max_row_size</a></code>.</p>
<hr  />
 <h3><a class="anchor" id="attack"></a>
attack</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <code>0.</code> <br  />
Angle of attack (radian, as specified in <a class="el" href="conventions.html#units">Units and physical quantities</a>).</p>
<hr  />
 <h3><a class="anchor" id="sideslip"></a>
sideslip</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <code>0.</code> <br  />
Sideslip angle (radian, as specified in <a class="el" href="conventions.html#units">Units and physical quantities</a>).</p>
<hr  />
 <h3><a class="anchor" id="art_visc_width"></a>
art_visc_width</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <code>-1.</code> <br  />
If set to a positive number, turns on aritificial viscosity with a smoothness-based coefficient and sets the smoothness width to <code>art_visc_width</code>.</p>
<hr  />
 <h3><a class="anchor" id="refine_if"></a>
refine_if</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{false}</code> <br  />
Mesh refinement criterion. Should be an expression that can be evaluated for each mesh element in an environment that includes the variables assigned by <code><a class="el" href="namespacehexed_1_1hil__properties.html#a523b3ce4706bddd336b023d9f38b878c">hexed::hil_properties::element()</a></code>. If this expression evaluates to <a class="el" href="hil.html#true">true</a> (and <a class="el" href="parameters.html#unrefine_if">unrefine_if</a> evaluates to <a class="el" href="hil.html#false">false</a>), the element will be refined. Otherwise it will not.</p>
<hr  />
 <h3><a class="anchor" id="mesh_extreme"></a>
mesh_extreme00, mesh_extreme01, mesh_extreme10, mesh_extreme11, mesh_extreme20, mesh_extreme21</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 0, 1, 0, 1, 0, 1 <br  />
Mesh extremes. That is, all elements will have coordinates \( x_0, x_1, x_2 \) such that <code>mesh_extreme00</code> \( \le x_0 \le \) <code>mesh_extreme01</code>, etc. If each mesh dimension is an integer multiple of the initial element size, then the above inequalities are equalities. Of course, only the first <a class="el" href="parameters.html#n_dim">n_dim</a> dimensions are considered.</p>
<h3><a class="anchor" id="extremal_bc"></a>
extremal_bc00, extremal_bc01, extremal_bc10, extremal_bc11, extremal_bc20, extremal_bc21</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{characteristic}</code> <br  />
Boundary conditions for extremal boundaries (defined by <a class="el" href="parameters.html#mesh_extreme">mesh_extreme00, mesh_extreme01, mesh_extreme10, mesh_extreme11, mesh_extreme20, mesh_extreme21</a>). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="boundary_conditions.html">Boundary Conditions</a></dd></dl>
<hr  />
 <h3><a class="anchor" id="n_cheby_flow"></a>
n_cheby_flow</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 1 <br  />
Number of Chebyshev acceleration stages to use for physical flow. Increasing this number will help the flow converge faster when/where it is diffusion-dominated but slow it down when/where it is convection-dominated. Also, it seems to be difficult to maintain stability if this number is greater than roughly 10. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="n_cheby_av"></a>
n_cheby_av</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 0.7 <br  />
Number of Chebyshev acceleration stages to use for diffusion equation for smoothness-based artificial viscosity. Increasing this number will help the artificial viscosity coefficient converge faster but cause a larger fraction of the time to be spent in the aritificial viscosity calculation. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="av_advect_iters"></a>
av_advect_iters</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 1 <br  />
Number of pseudotime iterations to run in artificial viscosity advection equation per nominal iteration (i.e. per <code><a class="el" href="classhexed_1_1Solver.html#a25f39d1d1312635e9629dfe934804879" title="updates the aritificial viscosity coefficient based on smoothness of the flow variables">hexed::Solver::update_art_visc_smoothness</a></code> call). Increasing this number will help the artificial viscosity coefficient converge faster but cause a larger fraction of the CPU time to be spent in the aritificial viscosity calculation. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="flow_iters"></a>
flow_iters</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 1 <br  />
Number of physical flow iterations to run per nominal iteration (i.e. per <code><a class="el" href="classhexed_1_1Solver.html#ad1b1d8ad6985b4c658724e840c2574f5">hexed::Solver::update</a></code> call). Increasing this number can help balance the amount of CPU time spent in the physical flow relative to the artificial viscosity iteration if <code>n_cheby_av</code> is larger than <code>n_cheby_flow</code>. The disadvantage is it can cause the <a class="el" href="parameters.html#iteration">iteration</a> count to be misleading. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="init_layer_splits"></a>
init_layer_splits</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 0 <br  />
Number of times to call <a class="el" href="parameters.html#split_layers">split_layers</a> during initial mesh generation (immediately after surface-based refinement but before state initialization). If you don't edit <a class="el" href="parameters.html#layer_split_points">layer_split_points</a>, then the wall spacing will be \( 3^{-\mathtt{\text{init_layer_splits}}} \) times the local isotropic mesh spacing. The default value of 0 is appropriate for inviscid simulations, but for high Reynolds-number viscous simulations it should be greater than zero. There currently is not a well-established best practice for how large it needs to be, but having the boundary layer be one or two wall layers thick often works well for subsonic simulations, and significantly more layers are often required for hypersonic simulations with a cold wall.</p>
<hr  />
 <h3><a class="anchor" id="max_ref_level"></a>
max_ref_level</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 10 <br  />
When performing geometry-based refinement with <a class="el" href="parameters.html#set_geometry_refinement">set_geometry_refinement</a>, elements will not be refined beyond this refinement level. This prevents excessive refinement in certain no-win scenarios such as sharp edges. This parameter must often be adjusted based on the scale of the geometry.</p>
<hr  />
<h2><a class="anchor" id="useful_inputs"></a>
Useful Input Parameters</h2>
<p>You will probably want to adjust these parameters for some simulations, but you can often leave them alone.</p>
<hr  />
 <h3><a class="anchor" id="init_ref_level"></a>
init_ref_level</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 3 <br  />
Number of levels to refine the mesh in <a class="el" href="parameters.html#init_refinement">init_refinement</a> before surface geometry is introduced. May be any nonnegative integer, up to time and memory constraints.</p>
<hr  />
 <h3><a class="anchor" id="surface_bc"></a>
surface_bc</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{auto}</code> <br  />
Specifies surface boundary condition. If <code>{auto}</code>, surface boundary condition will be determined automatically depending on the value of <a class="el" href="parameters.html#transport_model">transport_model</a>. <code>{inviscid}</code> &rarr; <code>{nonpenetration}</code> and <code>{sutherland}</code> &rarr; <code>{no_slip}</code>. Otherwise, the name of a supported <a class="el" href="boundary_conditions.html">Boundary condition type</a>.</p>
<hr  />
 <h3><a class="anchor" id="monitor_vars"></a>
monitor_vars</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{}</code> <br  />
<a class="el" href="classhexed_1_1Struct__expr.html#struct_expr">Structured expression</a> defining variables to monitor the convergence history of. For each variable <code>myvar</code>, after every <a class="el" href="parameters.html#update">update</a>, variables <code>myvar_min</code> and <code>myvar_max</code> will be assigned to the minimum and maximum of <code>myvar</code> over the last <a class="el" href="parameters.html#monitor_window">monitor_window</a> fraction of the iterations among at most <a class="el" href="parameters.html#monitor_samples">monitor_samples</a> evenly-spaced (roughly) samples. For additional details, see the implementation in <code><a class="el" href="classhexed_1_1History__monitor.html" title="monitors the history of some variable over iterations and computes the bounds over a specified window">hexed::History_monitor</a></code>.</p>
<hr  />
 <h3><a class="anchor" id="temperature_offset"></a>
temperature_offset</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <code>0.</code> <br  />
Applicable when altitude is specified. Sets the temperature offset passed to <code><a class="el" href="namespacehexed.html#a37e4a0200dca501e4e3d29f78a45aaff" title="computes the ICAO Standard atmosphere">hexed::standard_atmosphere</a></code>.</p>
<hr  />
 <h3><a class="anchor" id="geometry_uncertainty"></a>
geometry_uncertainty</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 3e-3 <br  />
When performing geometry-based refinement with <a class="el" href="parameters.html#set_geometry_refinement">set_geometry_refinement</a>, a nondimensional uncertainty metric for the surface representation will be compared to this value, and any elements with a larger value will be refined. Thus reducing this number results in a finer mesh and vice versa, although the default value produces reasonable results in a wide range of cases, in my opinion.</p>
<hr  />
 <h3><a class="anchor" id="art_visc_constant"></a>
art_visc_constant</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <code>-1.</code> <br  />
If set to a positive number, turns on aritificial viscosity and sets the artificial viscosity coefficient to be uniformly equal to <code>art_visc_constant</code>.</p>
<hr  />
 <h3><a class="anchor" id="fix_therm_admis"></a>
fix_therm_admis</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#false">false</a> <br  />
If <a class="el" href="hil.html#true">true</a>, check thermodynamic admissibility (positive density, nonnegative energy, non-NaN state) after every time integration stage and if problems are found, run as many Laplacian smearing iterations as neccessary to restore admissibility. Results in a major robustness improvement for hypersonic cases and comes at a modest performance cost.</p>
<hr  />
 <h3><a class="anchor" id="working_dir"></a>
working_dir</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{hexed_out/}</code> <br  />
Directory in which to write output files. Path can be relative or absolute. If the directory does not exist, it will be created. Any modifications to this variable must take place before the solver is initialized.</p>
<hr  />
 <h3><a class="anchor" id="vis_freq"></a>
vis_freq</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 10000 <br  />
Visualization files will be written every <code>vis_freq</code> iterations.</p>
<hr  />
 <h3><a class="anchor" id="write_freq"></a>
write_freq</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 10000 <br  />
Mesh and state files will be written every <code>vis_freq</code> iterations.</p>
<hr  />
 <h3><a class="anchor" id="print_freq"></a>
print_freq</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 100 <br  />
Solver status will be printed to stdout every <code>print_freq</code> iterations.</p>
<hr  />
 <h3><a class="anchor" id="unrefine_if"></a>
unrefine_if</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{false}</code> <br  />
Mesh unrefinement criterion. Behaves the same as <a class="el" href="parameters.html#refine_if">refine_if</a> except that if this expression evaluates to <a class="el" href="hil.html#true">true</a> (and <a class="el" href="parameters.html#refine_if">refine_if</a> evaluates to <a class="el" href="hil.html#false">false</a>), the element will be unrefined (subject to refinement level constraints).</p>
<hr  />
 <h3><a class="anchor" id="max_refinement_iters"></a>
max_refinement_iters</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 100 <br  />
Maximum number of refinement sweeps to run if refinement convergence is not achieved.</p>
<hr  />
 <h3><a class="anchor" id="n_smooth"></a>
n_smooth</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 30 <br  />
Number of mesh smoothing iterations to run after every surface-geometry-based refinement sweep.</p>
<hr  />
 <h3><a class="anchor" id="geom_n_segments"></a>
geom_n_segments</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 1000 <br  />
Number of subdivisions to use when discretizing 2D CAD geometry with <code><a class="el" href="classhexed_1_1Occt.html#aa5b58a03c28320a2c2d5f2ed5d4f3e03" title="Discretizes the curves in a TopoDS_Shape into segments of a polygonal line.">hexed::Occt::segments</a></code>.</p>
<hr  />
 <h3><a class="anchor" id="vis_surface"></a>
vis_surface</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#true">true</a> <br  />
Whether to visualize surface data when <a class="el" href="parameters.html#visualize">visualize</a> is invoked.</p>
<hr  />
 <h3><a class="anchor" id="vis_field"></a>
vis_field</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#true">true</a> <br  />
Whether to visualize field data when <a class="el" href="parameters.html#visualize">visualize</a> is invoked.</p>
<hr  />
 <h3><a class="anchor" id="vis_tecplot"></a>
vis_tecplot</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#false">false</a> <br  />
If <a class="el" href="hil.html#true">true</a>, write visualization files in Tecplot format (requires compilation with <code>use_tecplot</code> <code>ON</code>).</p>
<hr  />
 <h3><a class="anchor" id="vis_xdmf"></a>
vis_xdmf</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#true">true</a> <br  />
If <a class="el" href="hil.html#true">true</a>, write visualization files in XDMF format (requires compilation with <code>use_xdmf</code> <code>ON</code>).</p>
<hr  />
 <h3><a class="anchor" id="vis_skew"></a>
vis_skew</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#false">false</a> <br  />
If <a class="el" href="hil.html#true">true</a>, write a (separate) visualization file with the <a class="el" href="classhexed_1_1Equiangle__skewness.html">equiangle skewness</a> as a field variable.</p>
<hr  />
 <h3><a class="anchor" id="vis_field_vars"></a>
vis_field_vars</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>state_vars + art_visc_expr</code> <br  />
<a class="el" href="classhexed_1_1Struct__expr.html#struct_expr">Structured expression</a> specifying which field variables to visualize.</p>
<hr  />
 <h3><a class="anchor" id="vis_surface_vars"></a>
vis_surface_vars</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>state_vars + visc_stress_expr + heat_flux_expr</code> <br  />
<a class="el" href="classhexed_1_1Struct__expr.html#struct_expr">Structured expression</a> specifying which surface variables to visualize.</p>
<hr  />
 <h3><a class="anchor" id="vis_n_sample"></a>
vis_n_sample</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 10 <br  />
Each element will be visualized at sample points distributed in a uniformly-spaced structured block with <code>vis_n_sample</code> points on each edge. If you want, you can think of this as the visualization <a class="el" href="conventions.html#basis_row_size">row size</a>.</p>
<hr  />
 <h3><a class="anchor" id="print_vars"></a>
print_vars</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>iteration_expr + residual_expr + av_advection_residual_expr + av_diffusion_residual_expr + flow_time_expr + time_step_expr</code> <br  />
<a class="el" href="classhexed_1_1Struct__expr.html#struct_expr">Structured expression</a> specifying what quantities to print when the solver status is printed.</p>
<hr  />
 <h3><a class="anchor" id="integrand_field"></a>
integrand_field</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{}</code> <br  />
<a class="el" href="classhexed_1_1Struct__expr.html#struct_expr">Structured expression</a> specifying what quantities integrate when field integrals are computed.</p>
<hr  />
 <h3><a class="anchor" id="integrand_surface"></a>
integrand_surface</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{}</code> <br  />
<a class="el" href="classhexed_1_1Struct__expr.html#struct_expr">Structured expression</a> specifying what quantities integrate when surface integrals are computed.</p>
<hr  />
 <h3><a class="anchor" id="max_angle"></a>
max_angle</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <code>10*degree</code> Maximum allowable angle between adjacent panels when discretizing 3D CAD geometry with <code><a class="el" href="classhexed_1_1Occt.html#abddbae6dddb2948217a4ffdd2e1e46ff" title="Creates an array of simplices that can be used to construct a Simplex_geom&lt;3&gt;.">hexed::Occt::triangles</a></code>.</p>
<hr  />
 <h3><a class="anchor" id="max_deflection"></a>
max_deflection</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <a class="el" href="hil.html#huge">huge</a> <br  />
Maximum allowable linear deflection of surface panels when discretizing 3D CAD geometry with <code><a class="el" href="classhexed_1_1Occt.html#abddbae6dddb2948217a4ffdd2e1e46ff" title="Creates an array of simplices that can be used to construct a Simplex_geom&lt;3&gt;.">hexed::Occt::triangles</a></code> (dimensional).</p>
<hr  />
 <h3><a class="anchor" id="flood_fill_start"></a>
flood_fill_start0, flood_fill_start1, flood_fill_start2</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <a class="el" href="hil.html#huge">huge</a>, huge, huge <br  />
Location to start the flood fill algorithm when <a class="el" href="parameters.html#add_geom">add_geom</a> is evaluated. If any of the coordinates are not within the <a class="el" href="parameters.html#mesh_extreme">mesh extremes</a> (which is the case by default), the flood fill start location will effectively default to the minimum corner of the domain (<code>mesh_extreme00</code>, <code>mesh_extreme10</code>, <code>mesh_extreme20</code>).</p>
<hr  />
 <h3><a class="anchor" id="init_cond"></a>
init_cond</h3>
<p><b>type:</b> string <br  />
<b>default:</b> </p><div class="fragment"><div class="line">{state0 = freestream0</div>
<div class="line"> state1 = freestream1</div>
<div class="line"> state2 = freestream2</div>
<div class="line"> state3 = freestream3</div>
<div class="line"> state4 = freestream4</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="classhexed_1_1Struct__expr.html#struct_expr">Structured expression</a> which sets the state variables <code>state0</code>, <code>state1</code>, ... to the desired initial condition. It shall be evaluated in an environment that includes the variables <code>pos0</code>, <code>pos1</code>, <code>pos2</code>, and <code>time</code>.</p>
<hr  />
 <h3><a class="anchor" id="fix_admis_max_safety"></a>
fix_admis_max_safety</h3>
<p><b>type:</b> float<br  />
<b>default:</b> 0.7 <br  />
Maximum safety factor for Laplacian smearing iterations when fixing thermodynamic admissibility. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parameters.html#fix_therm_admis">fix_therm_admis</a></dd></dl>
<hr  />
 <h3><a class="anchor" id="av_advect_max_safety"></a>
av_advect_max_safety</h3>
<p><b>type:</b> float<br  />
<b>default:</b> 0.7 <br  />
Maximum safety factor on pseudotime step in advection equation for smoothness-based artificial viscosity. Analogous to <a class="el" href="parameters.html#max_safety">max_safety</a>. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="av_diff_max_safety"></a>
av_diff_max_safety</h3>
<p><b>type:</b> float<br  />
<b>default:</b> 0.7 <br  />
Maximum safety factor on pseudotime step in diffusion equation for smoothness-based artificial viscosity. Analogous to <a class="el" href="parameters.html#max_safety">max_safety</a>. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="layer_split_points"></a>
layer_split_points</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{split0 = 1./3.;}</code> <br  />
<a class="el" href="classhexed_1_1Struct__expr.html#struct_expr">Structured expression</a> defining the aspect ratio of anisotropic wall layers created by <a class="el" href="parameters.html#split_layers">split_layers</a>. The values of the variables in the expression determine the split points in order from closest to the wall to farthest. The names of the variables are irrelevant.</p>
<hr  />
 <h3><a class="anchor" id="diffusive_admissibility"></a>
diffusive_admissibility</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#false">false</a> <br  />
Experimental feature, but shows potential to be very useful. If <a class="el" href="hil.html#true">true</a>, it will add a Laplacian artificial diffusion term triggered based on elementwise smoothness of the specific volume (reciprocal of density), with a very coarse tolerance. This appears to be very effective for stabilizing severely underresolved (or unresolvable) features without affecting well-resolved regions, including properly captured shocks. For example, this allows reasonable results to be obtained for inviscid flow around a square, which had thus far defeated the solver even with shock capturing. This feature introduces very little performance overhead in and of itself, but it will enable LDG, introducing significant overhead over pure inviscid problems.</p>
<hr  />
 <h3><a class="anchor" id="input_data"></a>
input_data</h3>
<p><b>type:</b> string <br  />
<b>default:</b> <code>{auto}</code> <br  />
Name of mesh and state files for <a class="el" href="parameters.html#read_mesh">read_mesh</a> and <a class="el" href="parameters.html#read_state">read_state</a>, <em>including the directory</em>, but not including the <code>.mesh.h5</code>/<code>.state.h5</code> suffix. If <code>{auto}</code>, it will be initialized to <code>working_dir + latest</code>, which is appropriate if you want to restart a previous simulation in the same working directory from the last available save point. Note that if you want to restart from mesh and state files with different names (questionable, since the state must be read with an exactly matching mesh), you can just change the value of this variable between calling <a class="el" href="parameters.html#read_mesh">read_mesh</a> and <a class="el" href="parameters.html#read_state">read_state</a> (or just rename your files).</p>
<hr  />
<h2><a class="anchor" id="esoteric_inputs"></a>
Esoteric Input Parameters</h2>
<p>You will probably never need to worry about these parameters. They are tunable in principle, but in practice the same values tend to work for pretty much every problem. In some cases, even I don't fully understand why the accepted defaults work.</p>
<hr  />
 <h3><a class="anchor" id="mesh_extreme_eps"></a>
mesh_extreme_eps</h3>
<p><b>type:</b> float <br  />
<b>default:</b> <code>1e-6</code> <br  />
Comparison tolerance to use when deterimining whether points are inside or outside mesh extremes. Relative to domain size.</p>
<hr  />
 <h3><a class="anchor" id="av_diff_iters"></a>
av_diff_iters</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 1 <br  />
Number of pseudotime iterations to run in artificial viscosity diffusion equation per nominal iteration (i.e. per <code><a class="el" href="classhexed_1_1Solver.html#a25f39d1d1312635e9629dfe934804879" title="updates the aritificial viscosity coefficient based on smoothness of the flow variables">hexed::Solver::update_art_visc_smoothness</a></code> call). Increasing this number will help the artificial viscosity coefficient converge faster but cause a larger fraction of the CPU time to be spent in the aritificial viscosity calculation. </p><dl class="section note"><dt>Note</dt><dd>This was useful before Chebyshev acceleration was discovered. Increasing <a class="el" href="parameters.html#n_cheby_av">n_cheby_av</a> instead will usually be more productive, up to the limit where stability falls apart. </dd>
<dd>
Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="av_diff_ratio"></a>
av_diff_ratio</h3>
<p><b>type:</b> float<br  />
<b>default:</b> 0.1 <br  />
Determines amount of to smear artificial viscosity coefficient for smoothness-based artificial viscosity. A larger number means that the artificial viscosity field will be smoother but also spread further from the shocks. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="av_visc_mult"></a>
av_visc_mult</h3>
<p><b>type:</b> float<br  />
<b>default:</b> 30. <br  />
Final linear scaling parameter on smoothness-based artificial viscosity coefficient. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="av_unscaled_max"></a>
av_unscaled_max</h3>
<p><b>type:</b> float<br  />
<b>default:</b> 2e-4 <br  />
Maximum amount of artificial viscosity allowed before dimensional scaling. If this value is too small, artificial viscosity will not be sufficient to fully capture shocks. If it is too large, excessively small time steps may be encountered during the initial transient phase of the simulation. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="av_advect_max_res"></a>
av_advect_max_res</h3>
<p><b>type:</b> float<br  />
<b>default:</b> 1e-3 <br  />
Limit on the residual in the advection equation for smoothness-based artificial viscosity determination to improve robustness when weak instabilities are encountered. </p><dl class="section note"><dt>Note</dt><dd>Not defined until <a class="el" href="parameters.html#create_solver">create_solver</a> is evaluated.</dd></dl>
<hr  />
 <h3><a class="anchor" id="vis_lts_constraints"></a>
vis_lts_constraints</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#false">false</a> <br  />
If <a class="el" href="hil.html#true">true</a>, visualize the local time step constraints due to convection and diffusion, respectively.</p>
<hr  />
 <h3><a class="anchor" id="iter_width"></a>
iter_width</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 10 <br  />
Visualization file names will contain iteration numbers with leading zeros added such that there are at least <code>iter_width</code> digits.</p>
<hr  />
 <h3><a class="anchor" id="heat_flux_coercion"></a>
heat_flux_coercion</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 2. <br  />
When weakly applying heat flux boundary conditions, this determines how strongly the heat flux is coerced to match the prescribed value. If this number is too large, the simulation might be unstable, but if it too small the boundary condition might not be fully satisfied. The default value is adequate for almost all cases, but there are rare situations in which it might need to be reduced.</p>
<hr  />
 <h3><a class="anchor" id="shock_sub_iters"></a>
shock_sub_iters</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 10 number of sub-iterations to run in each nominal iteration to get efficient Chebyshev-accelerated diffusion (when $<a class="el" href="parameters.html#set_shock">set_shock</a> has been called)</p>
<hr  />
 <h3><a class="anchor" id="ramping_initial_iters"></a>
ramping_initial_iters</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 1000 <br  />
number of initial iterations to run at a small safety factor (<a class="el" href="parameters.html#ramping_initial_safety">ramping_initial_safety</a>) to let the artificial viscosity catch up (when $<a class="el" href="parameters.html#set_ramping">set_ramping</a> has been called)</p>
<hr  />
 <h3><a class="anchor" id="ramping_initial_safety"></a>
ramping_initial_safety</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 3e-3 <br  />
safety factor to use in initial iterations</p>
<hr  />
 <h3><a class="anchor" id="ramping_final_safety"></a>
ramping_final_safety</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 0.7 <br  />
will revert to this factor after initial iterations are complete (when $<a class="el" href="parameters.html#set_ramping">set_ramping</a>)</p>
<hr  />
 <h3><a class="anchor" id="monitor_window"></a>
monitor_window</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 0.25 <br  />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="parameters.html#monitor_vars">monitor_vars</a></dd></dl>
<hr  />
 <h3><a class="anchor" id="monitor_samples"></a>
monitor_samples</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> 100 <br  />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="parameters.html#monitor_vars">monitor_vars</a></dd></dl>
<hr  />
 <h3><a class="anchor" id="elementwise_art_visc"></a>
elementwise_art_visc</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#false">false</a> <br  />
If <a class="el" href="hil.html#true">true</a>, artificial viscosity determined in an elementwise fasion based on the work of <a href="http://persson.berkeley.edu/pub/persson13transient_shocks.pdf">Persson</a>. This feature is provided purely for the purpose of comparing the discretization-independent artificial viscosity to conventional methods. It is not recommended for practical simulations with this solver.</p>
<hr  />
 <h3><a class="anchor" id="elementwise_art_visc_pde"></a>
elementwise_art_visc_pde</h3>
<p><b>type:</b> integer <br  />
<b>default:</b> <a class="el" href="hil.html#false">false</a> <br  />
If <a class="el" href="parameters.html#elementwise_art_visc">elementwise artificial viscosity</a> is used, if this variable is <a class="el" href="hil.html#true">true</a>, the artificial viscosity field will be regularized with PDE-based smoothing. Otherwise, it will be continuous and piecewise n-linear.</p>
<hr  />
 <h3><a class="anchor" id="elementwise_art_visc_diff_ratio"></a>
elementwise_art_visc_diff_ratio</h3>
<p><b>type:</b> float <br  />
<b>default:</b> 0.5 <br  />
If <a class="el" href="parameters.html#elementwise_art_visc_pde">PDE-based</a> <a class="el" href="parameters.html#elementwise_art_visc">elementwise artificial viscosity</a> is used, this controls the amount of diffusion used to smooth the artificial viscosity coefficient.</p>
<hr  />
<h1><a class="anchor" id="commands"></a>
Command Variables &amp; Macros</h1>
<p>The following variables are used to execute actions. Some are Heisenberg variables which, when evaluated, cause the solver to perform certain tasks, while others are simply HIL macros. Most of the time you shouldn't need to know about most of these variables. For an overview of what variables you actually need to run a typical simulation, see <a class="el" href="running.html">Running Hexed</a>. The remaining ones are used internally by other macros and/or are only necessary for specific situations, but all are made available to you to help you deal with edge cases that the default behavior does not cover. See example cases for standard best practices.</p>
<h2><a class="anchor" id="command_list"></a>
List of Command Variables</h2>
<hr  />
 <h3><a class="anchor" id="start"></a>
start</h3>
<p><b>type:</b> string (macro) <br  />
Performs basic initialization that has to happen before you can do anything with the solver (but after you've defined your parameters). Behavior is roughly the following:</p><ol type="1">
<li>creates working directory if it does not already exist</li>
<li>copies the inpute file to the working directory for the user's future reference</li>
<li>initializes automatically-determined parameters</li>
<li>calls <a class="el" href="parameters.html#create_solver">create_solver</a></li>
</ol>
<p>At this point, the mesh technically exists but contains only one element and no geometry.</p>
<h3><a class="anchor" id="mesh"></a>
mesh</h3>
<p>Generates the initial mesh (although you can continue to modify it).</p><ol type="1">
<li>calls <a class="el" href="parameters.html#init_refinement">init_refinement</a></li>
<li>calls <a class="el" href="parameters.html#add_geom">add_geom</a></li>
<li>calls <a class="el" href="parameters.html#refine">refine</a> as many times as appropriate</li>
<li>calls <a class="el" href="parameters.html#split_layers">split_layers</a> as many times as appropriate</li>
</ol>
<hr  />
 <h3><a class="anchor" id="run"></a>
run</h3>
<p><b>type:</b> string (macro) <br  />
Executes solution (requires <a class="el" href="parameters.html#start">start</a>, <a class="el" href="parameters.html#mesh">meshing</a>, and <a class="el" href="parameters.html#init_state">state initialization</a> to have been performed). Behavior is roughly the following:</p><ol type="1">
<li>writes mesh and state files</li>
<li>visualizes the solution</li>
<li>creates <a class="el" href="running.html#runtime_cmd">runtime_cmd.hil</a> if it does not already exist.</li>
<li>calls <a class="el" href="parameters.html#iterate">iterate</a> as many times as appropriate</li>
<li>writes mesh and state files</li>
<li>visualizes solution</li>
</ol>
<hr  />
 <h3><a class="anchor" id="iterate"></a>
iterate</h3>
<p><b>type:</b> string (macro) <br  />
Executes one iteration (called by <a class="el" href="parameters.html#run">run</a>). Behavior is roughly the following:</p><ol type="1">
<li>calls <a class="el" href="parameters.html#update">update</a></li>
<li>computes residuals</li>
<li>prints history variables</li>
<li>may writes mesh and state files, depending on <a class="el" href="parameters.html#write_freq">write_freq</a></li>
<li>may write visualization files, depending on <a class="el" href="parameters.html#vis_freq">vis_freq</a></li>
<li>executes any commands in <a class="el" href="running.html#runtime_cmd">runtime_cmd.hil</a> and empties the file</li>
</ol>
<p>The user can modify the behavior of the iteration loop by adding additional <a class="el" href="hil.html">HIL</a> code to the beginning or the end of this macro.</p>
<hr  />
 <h3><a class="anchor" id="create_solver"></a>
create_solver</h3>
<p><b>type:</b> Heisenberg integer <br  />
Creates a <code><a class="el" href="classhexed_1_1Solver.html" title="The main class that basically runs everything.">hexed::Solver</a></code> object and returns 0. Mesh contains a single element and the flow is uninitialized.</p>
<hr  />
 <h3><a class="anchor" id="init_refinement"></a>
init_refinement</h3>
<p><b>type:</b> Heisenberg integer <br  />
Performs initial refinment (not based on geometry surface) and returns 0.</p>
<hr  />
 <h3><a class="anchor" id="add_geom"></a>
add_geom</h3>
<p><b>type:</b> Heisenberg integer <br  />
Inserts geometry into mesh and returns 0. You can define 0 or more string variables named <code>geom0</code>, <code>geom1</code>, <code>geom2</code>, ... containing paths to geometry definition files. Paths can be absolute or relative to execution directory (not <a class="el" href="parameters.html#working_dir">working_dir</a>). Geometry variable numbers must start at 0 and be consecutive. E.g., if you define <code>geom0 = leading.txt</code>, <code>geom1 = main.txt</code>, <code>geom3 = trailing.txt</code>, then <code>geom3</code> will be ignored. If these geometries split the domain into disjoint regions, then the region containing the <a class="el" href="parameters.html#flood_fill_start">flood fill start</a> shall be meshed. Geometry file format is inferred from the file extension, which is case-insensitive. The following extension/format combinations are supported:</p><ul>
<li><code>.csv</code>: Comma Separated Value format (2D only). A comma-delimited table with at least 2 columns, which are interpreted as \( x_0 \) and \( x_1 \) coordinates of the nodes of a polygonal curve, in <a class="el" href="conventions.html#units">standard units</a>. Curve is treated as open &ndash; if you are trying to model a closed shape, simply make the first point (approximately) equal to the last.</li>
<li><code>.igs</code>, <code>.iges</code>: <a href="https://en.wikipedia.org/wiki/IGES">IGES</a> CAD <a href="https://www.govinfo.gov/content/pkg/GOVPUB-C13-7b81ba8b0f709555f162cb496aa63b3b/pdf/GOVPUB-C13-7b81ba8b0f709555f162cb496aa63b3b.pdf">format</a> (2D or 3D). For 2D simulations, the model edges will be extracted and projected onto the \( (x_0, x_1) \) plane. For 3D simulations, the model surfaces will be used. Units are read from the file and converted.</li>
<li><code>.stp</code>, <code>.step</code>: <a href="https://en.wikipedia.org/wiki/ISO_10303-21">STEP</a> CAD format. As above.</li>
<li><code>.stl</code>: <a href="https://en.wikipedia.org/wiki/STL_(file_format)">STL</a> 3D geometry format (3D only). ASCII or binary formats accepted. Units are assumed to be <a class="el" href="conventions.html#units">standard</a>.</li>
</ul>
<hr  />
 <h3><a class="anchor" id="refine"></a>
refine</h3>
<p><b>type:</b> Heisenberg integer <br  />
Performs one refinement sweep and returns 0. Elements are refined or unrefined based on <a class="el" href="parameters.html#refine_if">refine_if</a> and <a class="el" href="parameters.html#unrefine_if">unrefine_if</a>.</p>
<hr  />
 <h3><a class="anchor" id="init_state"></a>
init_state</h3>
<p><b>type:</b> Heisenberg integer <br  />
Initializes the solver state to <a class="el" href="parameters.html#init_cond">init_cond</a> and returns 0.</p>
<hr  />
 <h3><a class="anchor" id="visualize"></a>
visualize</h3>
<p><b>type:</b> Heisenberg integer <br  />
Writes visualization files and returns 0.</p>
<hr  />
 <h3><a class="anchor" id="compute_residuals"></a>
compute_residuals</h3>
<p><b>type:</b> Heisenberg string <br  />
Evaluates the residuals and assigns them to float variables <a class="el" href="parameters.html#residual_momentum">residual_momentum</a>, <a class="el" href="parameters.html#residual_density">residual_density</a>, <a class="el" href="parameters.html#residual_energy">residual_energy</a>. Returns the empty string.</p>
<hr  />
 <h3><a class="anchor" id="compute_forces"></a>
compute_forces</h3>
<p><b>type:</b> string (macro) <br  />
Computes aerodynamic forces and force coefficients. Will assign values to the following variables</p><ul>
<li><code>force0</code></li>
<li><code>force1</code></li>
<li><code>force2</code></li>
<li><code>drag</code></li>
<li><code>lift</code></li>
<li><code>side_force</code></li>
<li><code>drag_coef</code></li>
<li><code>lift_coef</code></li>
<li><code>side_force_coef</code></li>
</ul>
<p>Any of the above which are not applicable to the dimensionality of the problem are set to zero. This macro involves computing integrals, so it has non-negligible performance overhead if called very frequently.</p>
<hr  />
 <h3><a class="anchor" id="print_forces"></a>
print_forces</h3>
<p><b>type:</b> string (macro) <br  />
Calls <a class="el" href="parameters.html#compute_forces">compute_forces</a> and prints the results in a pretty way.</p>
<hr  />
 <h3><a class="anchor" id="plot_history"></a>
plot_history</h3>
<p><b>type:</b> string (macro) <br  />
Creates a real-time, interactive plot of the convergence history. Specifically, it starts a background process which creates a <code><a class="el" href="classhexed__utils_1_1History__plot.html" title="creates a real-time, interactive plot of the convergence history">hexed_utils.History_plot</a></code> instance in a Python interpreter. Usually, this macro should be executed before the <a class="el" href="parameters.html#start">start</a>, <a class="el" href="parameters.html#mesh">mesh</a>, <a class="el" href="parameters.html#init_state">init_state</a>, <a class="el" href="parameters.html#run">run</a> sequence.</p>
<hr  />
 <h3><a class="anchor" id="update"></a>
update</h3>
<p><b>type:</b> Heisenberg string <br  />
Executes <a class="el" href="parameters.html#print_freq">print_freq</a> solver iterations and returns an empty string. Each "solver iteration" consists of:</p><ol type="1">
<li>Calling <code><a class="el" href="classhexed_1_1Solver.html#a070798e655682bd6955336b3e1dc0980" title="turns on artificial viscosity and initializes coefficient to a uniform value">hexed::Solver::set_art_visc_constant</a></code>, if applicable.</li>
<li>Calling <code><a class="el" href="classhexed_1_1Solver.html#a25f39d1d1312635e9629dfe934804879" title="updates the aritificial viscosity coefficient based on smoothness of the flow variables">hexed::Solver::update_art_visc_smoothness</a></code>, if applicable.</li>
<li>Calling <code><a class="el" href="classhexed_1_1Solver.html#ad1b1d8ad6985b4c658724e840c2574f5">hexed::Solver::update</a></code>.</li>
</ol>
<hr  />
 <h3><a class="anchor" id="integrate_field"></a>
integrate_field</h3>
<p><b>type:</b> Heisenberg string <br  />
Computes integrals of the variables in <a class="el" href="parameters.html#integrand_field">integrand_field</a> over the domain by the native quadrature rule of the numerical scheme. The integrals of the variables are assigned to float variables names <code>integral_field_var</code> where <code>var</code> is the name of the variable. Returns an empty string.</p>
<hr  />
 <h3><a class="anchor" id="integrate_surface"></a>
integrate_surface</h3>
<p><b>type:</b> Heisenberg string <br  />
Computes integrals of the variables in <a class="el" href="parameters.html#integrand_surface">integrand_surface</a> over the geometry surface by the native quadrature rule of the numerical scheme. The integrals of the variables are assigned to float variables names <code>integral_surface_var</code> where <code>var</code> is the name of the variable. Returns an empty string.</p>
<hr  />
 <h3><a class="anchor" id="split_layers"></a>
split_layers</h3>
<p><b>type:</b> Heisenberg integer <br  />
Creates anisotropic wall layers by splitting the last wall layer (the layer of extruded elements closest to the geometry surface) into thinner layers. The layer will be split at user-specified set of points controlled by <a class="el" href="parameters.html#layer_split_points">layer_split_points</a>. For each split point, the layer will be cut by the level surface where the wall-normal reference coordinate equals that value. Thus split points should be strictly increasing and in the interval (0, 1). For example, to split the last wall layer into 4 approximately equal parts, you could set <code>layer_split_points = {split0 = 0.25; split1 = 0.5; split2 = 0.75}</code> and then evaluate <code>split_layers</code>. The state of the original layer will be interpolated into the new layers, so layer splitting can be performed dynamically as a simulation is running. Evaluates to 0.</p>
<hr  />
 <h3><a class="anchor" id="set_geometry_refinement"></a>
set_geometry_refinement</h3>
<p><b>type:</b> string (macro) <br  />
Sets <a class="el" href="parameters.html#refine_if">refine_if</a> and <a class="el" href="parameters.html#unrefine_if">unrefine_if</a> to refine elements in order to efficiently resolve the geometry surface. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="parameters.html#max_ref_level">max_ref_level</a> </dd>
<dd>
<a class="el" href="parameters.html#geometry_uncertainty">geometry_uncertainty</a></dd></dl>
<hr  />
 <h3><a class="anchor" id="set_shock"></a>
set_shock</h3>
<p><b>type:</b> string (macro) <br  />
Configures settings to be good for shock capturing (in particular turning on smoothness-based artificial viscosity).</p>
<hr  />
 <h3><a class="anchor" id="set_ramping"></a>
set_ramping</h3>
<p><b>type:</b> string (macro) <br  />
Implements a crude CFL ramping scheme. The CFL safety factor is initially set to a very small value (<a class="el" href="parameters.html#ramping_initial_safety">ramping_initial_safety</a>) and then after a set number of iterations (<a class="el" href="parameters.html#ramping_initial_iters">ramping_initial_iters</a>) it is instantaneously increased to a reasonable value (<a class="el" href="parameters.html#ramping_final_safety">ramping_final_safety</a>). The reason why this is necessary is that the artificial viscosity coefficient can take time to adjust to the flow conditions, so an initial condition where the flow does not satisfy the boundary conditions and the artificial viscosity coefficient is zero can cause robustness problems. It is usually only necessary in supersonic viscous simulations.</p>
<hr  />
 <h3><a class="anchor" id="set_aerothermo"></a>
set_aerothermo</h3>
<p><b>type:</b> string (macro) <br  />
Configures settings to be good for aerothermodynamics. Assumes $<a class="el" href="parameters.html#set_shock">set_shock</a> has already been called. Automaticall calls $<a class="el" href="parameters.html#set_ramping">set_ramping</a>.</p>
<hr  />
 <h3><a class="anchor" id="read_mesh"></a>
read_mesh</h3>
<p><b>type:</b> Heisenberg int <br  />
Reads the mesh from a <a class="el" href="mesh_io.html#file_format">Hexed mesh file</a> (which you can create using <a class="el" href="parameters.html#write_mesh">write_mesh</a>). This can be used in place of <a class="el" href="parameters.html#mesh">mesh</a>, but you will still have to call <a class="el" href="parameters.html#init_state">init_state</a> or <a class="el" href="parameters.html#read_state">read_state</a> to initialize the flow state. The file name of the mesh file given by <a class="el" href="parameters.html#input_data">input_data</a> with <code>.mesh.h5</code> appended. Evaluates to 0.</p>
<hr  />
 <h3><a class="anchor" id="read_state"></a>
read_state</h3>
<p><b>type:</b> Heisenberg int <br  />
Reads the flow state from a file created with the <a class="el" href="parameters.html#write_state">write_state</a> command. The file name is given by <a class="el" href="parameters.html#input_data">input_data</a> with <code>.state.h5</code> appended. The state file <b>must</b> have been created for the exact same mesh, meaning that if the state file was not created during the same simulation you're currently running, you need to first use <a class="el" href="parameters.html#read_mesh">read_mesh</a> to get the mesh. Two meshes that look the same might not actually be the same for a variety of reasons. For example, if elements were refined in a different order, then you cannot use the same state files, even if the mesh is geometrically identical. So, just play it safe and read the mesh first. This command can be used instead of <a class="el" href="parameters.html#init_state">init_state</a>. <code>read_mesh</code> and <code>read_state</code> together can be used to restart a previous simulation from where it left off. Evaluates to 0.</p>
<hr  />
 <h3><a class="anchor" id="write_mesh"></a>
write_mesh</h3>
<p><b>type:</b> Heisenberg int <br  />
Writes the mesh to a file in the <a class="el" href="mesh_io.html#file_format">Hexed mesh format</a>, which can then be used again in a future simulation using <a class="el" href="parameters.html#read_mesh">read_mesh</a>, or, in theory, imported into another program. The file name will be <code>iterXXXXXXXXXX.mesh.h5</code> in the working directory, where the <code>X</code>s are replaced with the current iteration number. Also creates a symlink <code>latest.mesh.h5</code> pointing to this file for convenience. Evaluates to 0.</p>
<hr  />
 <h3><a class="anchor" id="write_state"></a>
write_state</h3>
<p><b>type:</b> Heisenberg int <br  />
Writes the flow state to a file which can then be used in a future simulation using <a class="el" href="parameters.html#read_state">read_state</a>. The file name will be <code>iterXXXXXXXXXX.state.h5</code> in the working directory, where the <code>X</code>s are replaced with the current iteration number. Also creates a symlink <code>latest.state.h5</code> pointing to this file for convenience. Evaluates to 0.</p>
<hr  />
<h1><a class="anchor" id="outputs"></a>
Output Parameters</h1>
<p>The following variables are defined and/or updated by the solver in order to provide information to you. Some are Heisenberg variables whereas others are writable, but you should not write to them even if you are technically able to. Not all of these variables are defined at the start of the simulation. See individual documentation for details.</p>
<h2><a class="anchor" id="output_list"></a>
List of Output Parameters</h2>
<hr  />
 <h3><a class="anchor" id="input_file"></a>
input_file</h3>
<p><b>type:</b> string <br  />
If <a class="el" href="running.html#hexecute">hexecute</a> was invoked from an input file, <code>input_file</code> will be the path to the input file (relative or absolute as provided by user). If this is an interactive session, it will be an empty string.</p>
<hr  />
 <h3><a class="anchor" id="version"></a>
version</h3>
<p><b>type:</b> string <br  />
Version of Hexed you are running in <code>{major.minor.patch}</code> format.</p>
<hr  />
 <h3><a class="anchor" id="version_major"></a>
version_major</h3>
<p><b>type:</b> int <br  />
Major (first) component of <a class="el" href="parameters.html#version">version</a>.</p>
<hr  />
 <h3><a class="anchor" id="version_minor"></a>
version_minor</h3>
<p><b>type:</b> int <br  />
Minor (second) component of <a class="el" href="parameters.html#version">version</a>.</p>
<hr  />
 <h3><a class="anchor" id="version_patch"></a>
version_patch</h3>
<p><b>type:</b> int <br  />
Patch (third) component of <a class="el" href="parameters.html#version">version</a>.</p>
<hr  />
 <h3><a class="anchor" id="commit"></a>
commit</h3>
<p><b>type:</b> string <br  />
Commit hash of the source code your Hexed binary was compiled from. If you're running a release version, this should be redundant with <a class="el" href="parameters.html#version">version</a>, but if you're running a development version, it tells you how far ahead of the latest release you are.</p>
<hr  />
 <h3><a class="anchor" id="license"></a>
license</h3>
<p><b>type:</b> string <br  />
Information about the copyright of this software and the license, if any, under which it was provided to you.</p>
<hr  />
 <h3><a class="anchor" id="iteration"></a>
iteration</h3>
<p><b>type:</b> integer <br  />
Number of iterations executed since solver was created. Equal to <a class="el" href="parameters.html#print_freq">print_freq</a> times the number of <a class="el" href="parameters.html#update">update</a> evaluations.</p>
<hr  />
 <h3><a class="anchor" id="wall_time"></a>
wall_time</h3>
<p><b>type:</b> float <br  />
Wall clock time (seconds) elapsed since solver was created. Not to be confused with <a class="el" href="parameters.html#flow_time">flow_time</a> &mdash;if the distinction isn't clear, here is an example: if you start a simulation and then take a 5-minute break to make coffee, if your simulation is still running upon your return the wall time will be 5*60s = 300s.</p>
<hr  />
 <h3><a class="anchor" id="flow_time"></a>
flow_time</h3>
<p><b>type:</b> float <br  />
Amount of time (seconds) elapsed in the physical flow since the simulation started. Only meaningful for global time stepping. Not to be confused with <a class="el" href="parameters.html#wall_time">wall_time</a> &mdash;if the distinction isn't clear, here is an example: if you have a shock propagating at 100 m/s and run your simulation with global time stepping until the flow time reaches 0.01 s, then the shock will have propaged a distance of 1 m.</p>
<hr  />
 <h3><a class="anchor" id="time_step"></a>
time_step</h3>
<p><b>type:</b> float <br  />
Time step taken in the most recent iteration. Only meaningful for global time stepping.</p>
<hr  />
 <h3><a class="anchor" id="header"></a>
header</h3>
<p><b>type:</b> Heisenberg string <br  />
The names of the <a class="el" href="parameters.html#print_vars">print_vars</a> variables as a comma-delimited list.</p>
<hr  />
 <h3><a class="anchor" id="report"></a>
report</h3>
<p><b>type:</b> Heisenberg string <br  />
Evaluates <a class="el" href="parameters.html#compute_residuals">compute_residuals</a> and then returns the values of the <a class="el" href="parameters.html#print_vars">print_vars</a> variables as a comma-delimited list.</p>
<hr  />
 <h3><a class="anchor" id="residual_momentum"></a>
residual_momentum</h3>
<p><b>type:</b> float <br  />
Magnitude of the dimensional residual of the vector momentum equation. Begins the simulation uninitialized and is only assigned when <a class="el" href="parameters.html#compute_residuals">compute_residuals</a> is evaluated.</p>
<hr  />
 <h3><a class="anchor" id="residual_density"></a>
residual_density</h3>
<p><b>type:</b> float <br  />
Dimensional residual of the continuity equation. Begins the simulation uninitialized and is only assigned when <a class="el" href="parameters.html#compute_residuals">compute_residuals</a> is evaluated.</p>
<hr  />
 <h3><a class="anchor" id="residual_energy"></a>
residual_energy</h3>
<p><b>type:</b> float <br  />
Dimensional residual of the energy equation. Begins the simulation uninitialized and is only assigned when <a class="el" href="parameters.html#compute_residuals">compute_residuals</a> is evaluated.</p>
<hr  />
 <h3><a class="anchor" id="normalized_residual"></a>
normalized_residual</h3>
<p><b>type:</b> float <br  />
Average of momentum, density, and energy residuals, each normalized by their value after the first iteration.</p>
<hr  />
 <h3><a class="anchor" id="art_visc_residual"></a>
art_visc_residual</h3>
<p><b>type:</b> float <br  />
 \( L^2 \) norm of the most recent update to the artificial viscosity coefficient. This is a dimensional value that depends on the domain area and time step, but it can be useful to qualitatively asses the convergence of the simulation.</p>
<hr  />
 <h3><a class="anchor" id="n_elements"></a>
n_elements</h3>
<p><b>type:</b> Heisenberg integer <br  />
The number of elements currently in the mesh.</p>
<hr  />
 <h3><a class="anchor" id="performance_report"></a>
performance_report</h3>
<p><b>type:</b> Heisenberg string <br  />
Human-readable summary of kernel performance metrics for all iterations that have been run in the current simulation.</p>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
