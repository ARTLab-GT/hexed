#include <iostream>
#include <stdexcept>
#include <string>
#include <cmath>
#include <cstdlib>
#include <chrono>

#include <Vector_view.hpp>
#include <Gauss_lobatto.hpp>
#include <Kernel_settings.hpp>
#include <Deformed_element.hpp>

int main(int argc, char** argv)
{

if (argc != 4) throw std::runtime_error("Wrong number of arguments. 3 required.");

int dim = std::stoi(argv[1]);
int row_size = std::stoi(argv[2]);
int n_elem_side = std::stoi(argv[3]);
int n_elem = std::pow(n_elem_side, dim);
int n_qpoint = std::pow(row_size, dim);
int n_var = dim + 2;
int n_total = n_var*n_qpoint*n_elem;

cartdg::Storage_params storage_params {3, n_var, dim, row_size};

std::vector<double> read_vec (n_total);
std::vector<double> write_vec (n_total, 0.);
cartdg::elem_vec elem_vec;
cartdg::def_elem_vec def_elements;
for (int i_elem = 0; i_elem < n_elem; ++i_elem)
{
  elem_vec.emplace_back(new cartdg::Element {storage_params});
  def_elements.emplace_back(new cartdg::Deformed_element {storage_params});
  for (int i_stage : {0, 1}) {
    for (int i_dof = 0; i_dof < n_var*n_qpoint; ++i_dof)
    {
      double state = (rand()%1000)/1000. + 10.; // "+ 10." avoids NaN due to nonpositive density
      if (i_dof/n_qpoint == n_var - 1) state += 100; // Avoid NaN due to negative pressure
      elem_vec.back()->stage(0)[i_stage*n_var*n_qpoint + i_dof] = state;
      elem_vec.back()->stage(1)[i_stage*n_var*n_qpoint + i_dof] = state;
      def_elements.back()->stage(0)[i_stage*n_var*n_qpoint + i_dof] = state;
    }
  }
  for (int i_jac = 0; i_jac < dim*dim*n_qpoint; ++i_jac)
  {
    // generate numbers between 0.9 and 1.099 on the diagonal
    // and between -0.1 and 0.099 elsewhere
    double* jac = def_elements.back()->jacobian();
    *jac = ((rand()%200) - 100)/1000.;
    int i_entry = i_jac/n_qpoint;
    if ((i_entry/dim) == (i_entry%dim)) *jac += 1.;
  }
}
cartdg::Vector_view<cartdg::Element&, std::unique_ptr<cartdg::Element>, &cartdg::ptr_convert<cartdg::Element&, std::unique_ptr<cartdg::Element>>> elements {elem_vec};
#pragma omp parallel for
for (int i = 0; i < n_total; ++i)
{
  read_vec[i] = (rand()%1000)/1000. + 10.; // "+ 10." avoids NaN due to nonpositive density
  if (((i/n_qpoint)%n_var) == n_var - 1) read_vec[i] += 100; // Avoid NaN due to negative pressure
}
double* read = read_vec.data();
double* write = write_vec.data();
cartdg::elem_con_vec connections (dim);
cartdg::def_elem_con_vec def_connections;
for (int i_dim = 0; i_dim < dim; ++i_dim)
{
  for (int i_con = 0; i_con < n_elem; ++i_con)
  {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    connections[i_dim].push_back({});
    std::array<cartdg::Face_index, 2> face_inds;
    for (int i_side: {0, 1})
    {
      int i_elem = rand()%n_elem;
      connections[i_dim].back()[i_side] = elements[i_elem].face() + (2*i_dim + 1 - i_side)*n_qpoint/row_size;
      face_inds[i_side].element = def_elements[i_elem].get();
      face_inds[i_side].i_dim = rand()%dim;
      face_inds[i_side].is_positive = bool(rand()%2);
    }
    def_connections.emplace_back(face_inds);
    #pragma GCC diagnostic pop
  }
}

cartdg::Gauss_lobatto basis (row_size);
cartdg::Kernel_settings settings;
// some arbitrary values
settings.d_t = 0.7;
settings.rk_weight = 0.3;

// AUTOGENERATE

}
