#include <iostream>
#include <stdexcept>
#include <string>
#include <cmath>
#include <cstdlib>
#include <chrono>

#include <Gauss_lobatto.hpp>
#include <Kernel_settings.hpp>

int main(int argc, char** argv)
{

if (argc != 4) throw std::runtime_error("Wrong number of arguments. 3 required.");

int dim = std::stoi(argv[1]);
int row_size = std::stoi(argv[2]);
int n_elem_side = std::stoi(argv[3]);
int n_elem = std::pow(n_elem_side, dim);
int n_qpoint = std::pow(row_size, dim);
int n_visc = std::pow(2, dim);
int n_var = dim + 2;
int n_total = n_var*n_qpoint*n_elem;
int n_jacobian = n_elem*n_qpoint*dim*dim;

std::vector<double> jacobian_vec (n_jacobian, 0.);
std::vector<double> read_vec (n_total);
std::vector<double> write_vec (n_total, 0.);
std::vector<double> visc_vec (n_elem*n_visc, 0.);
#pragma omp parallel for
for (int i = 0; i < n_total; ++i)
{
  read_vec[i] = (rand()%1000)/1000. + 10.; // "+ 10." avoids NaN due to nonpositive density
  if (((i/n_qpoint)%n_var) == n_var - 1) read_vec[i] += 100; // Avoid NaN due to negative pressure
}
#pragma omp parallel for
for (int i = 0; i < n_jacobian; ++i)
{
  // generate numbers between 0.9 and 1.099 on the diagonal
  // and between -0.1 and 0.099 elsewhere
  jacobian_vec[i] = ((rand()%200) - 100)/1000.;
  int i_entry = (i/n_qpoint)%(dim*dim);
  if ((i_entry/dim) == (i_entry%dim)) i_entry += 1.;
}
double* jacobian = jacobian_vec.data();
double* read = read_vec.data();
double* write = write_vec.data();
double* visc = visc_vec.data();
std::vector<std::vector<double*>> con_r_vec2 (dim);
std::vector<std::vector<double*>> con_w_vec2 (dim);
std::vector<double**> con_r_vec1 (dim);
std::vector<double**> con_w_vec1 (dim);
std::vector<int> n_con_vec (dim);
for (int i_dim = 0; i_dim < dim; ++i_dim)
{
  n_con_vec[i_dim] = n_elem;
  for (int i_con = 0; i_con < n_elem; ++i_con)
  {
    int elem0 = (rand()%n_elem)*n_qpoint*n_var;
    int elem1 = (rand()%n_elem)*n_qpoint*n_var;
    con_r_vec2[i_dim].push_back(read + elem0);
    con_r_vec2[i_dim].push_back(read + elem1);
    con_w_vec2[i_dim].push_back(write + elem0);
    con_w_vec2[i_dim].push_back(write + elem1);
  }
  con_r_vec1[i_dim] = con_r_vec2[i_dim].data();
  con_w_vec1[i_dim] = con_w_vec2[i_dim].data();
}
double*** connections_r = con_r_vec1.data();
double*** connections_w = con_w_vec1.data();
int* n_connections = n_con_vec.data();

cartdg::Gauss_lobatto basis (row_size);
cartdg::Kernel_settings settings;

// AUTOGENERATE

}
